// Code generated by sources_gen/main.go. DO NOT EDIT.

// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func init() {
	sources = map[string][]byte{}
	sources["generate.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"errors"
	"fmt"
	"go/constant"
	"go/types"
	"io"
	"math/big"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"text/template"

	pkgs "golang.org/x/tools/go/packages"
)

// renderPackages renders a Scriggofile. It also returns a boolean indicating
// if the content contains packages. Ignores all main packages contained in
// the Scriggofile.
func renderPackages(w io.Writer, dir string, sf *scriggofile, goos string, flags buildFlags) error {

	type packageType struct {
		name string
		decl map[string]string
	}

	// Import the packages of the Go standard library.
	for i, imp := range sf.imports {
		if imp.stdlib {
			paths := stdLibPaths()
			imports := make([]*importCommand, len(sf.imports)+len(paths)-1)
			copy(imports[:i], sf.imports[:i])
			for j, path := range paths {
				imports[i+j] = &importCommand{path: path}
			}
			copy(imports[i+len(paths):], sf.imports[i+1:])
			sf.imports = imports
		}
	}

	importReflect := false

	explicitImports := []struct{ Name, Path string }{}
	for _, imp := range sf.imports {
		uniqueName := uniquePackageName(imp.path)
		if uniqueName != imp.path { // TODO: uniqueName should be compared to the package name and not to the package path.
			explicitImports = append(explicitImports, struct{ Name, Path string }{uniqueName, imp.path})
		} else {
			explicitImports = append(explicitImports, struct{ Name, Path string }{"", imp.path})
		}
		if imp.path == "reflect" {
			importReflect = true
		}
	}

	packages := map[string]*packageType{}
	for i, imp := range sf.imports {
		if flags.v {
			_, _ = fmt.Fprintf(os.Stderr, "%s\n", imp.path)
		}
		pkgName, decls, refToImport, err := loadGoPackage(imp.path, dir, goos, flags, imp.including, imp.excluding)
		if err != nil {
			return err
		}
		if !refToImport {
			explicitImports[i].Name = "_"
		}
		// No declarations at path: move on to next import path.
		if len(decls) == 0 {
			continue
		}
		if imp.notCapitalized {
			tmp := map[string]string{}
			for name, decl := range decls {
				newName := uncapitalize(name)
				if newName == "main" || newName == "init" {
					return fmt.Errorf("%q is not a valid identifier: remove 'uncapitalized' or change declaration name in package %q", newName, imp.path)
				}
				if isGoKeyword(newName) {
					return fmt.Errorf("%q is not a valid identifier as it conflicts with Go keyword %q: remove 'uncapitalized' or change declaration name in package %q", newName, newName, imp.path)
				}
				if isPredeclaredIdentifier(newName) {
					if newName == "print" || newName == "println" {
						// https://github.com/open2b/scriggo/issues/361.
					} else {
						return fmt.Errorf("%q is not a valid identifier as it conflicts with Go predeclared identifier %q: remove 'uncapitalized' or change declaration name in package %q", newName, newName, imp.path)
					}
				}
				tmp[newName] = decl
			}
			decls = tmp
		}

		// Determine which import path use: the default (the one specified in
		// source, used by Go) or a new one indicated in Scriggo comments.
		path := imp.path
		if imp.asPath != "" {
			path = imp.asPath
		}

		switch imp.asPath {
		case "main": // Add read declarations to package main as builtins.
			if packages["main"] == nil {
				packages["main"] = &packageType{"main", map[string]string{}}
			}
			for name, decl := range decls {
				if _, ok := packages["main"].decl[name]; ok {
					return fmt.Errorf("declaration name collision in package main: %q", name)
				}
				packages["main"].decl[name] = decl
			}
		default: // Add read declarations to the specified package.
			if packages[path] == nil {
				packages[path] = &packageType{
					decl: map[string]string{},
				}
			}
			for name, decl := range decls {
				if _, ok := packages[path].decl[name]; ok {
					return fmt.Errorf("declaration name collision: %q in package %q", name, imp.path)
				}
				packages[path].decl[name] = decl
				packages[path].name = pkgName
				name = filepath.Base(path)
			}
		}

	}

	if w == nil {
		return nil
	}

	// If no packages have been declared, just return.
	if len(packages) == 0 {
		return nil
	}

	// Render package content.
	paths := make([]string, 0, len(packages))
	hasMain := false
	for path := range packages {
		if path == "main" {
			hasMain = true
			continue
		}
		paths = append(paths, path)
	}
	sort.Strings(paths)
	if hasMain {
		paths = append([]string{"main"}, paths...)
	}
	type declaration struct {
		Name  string
		Value string
	}
	allPkgsContent := make([]*struct {
		Variable     string
		Path, Name   string
		Declarations []declaration
	}, len(paths))
	for i, path := range paths {
		pkg := packages[path]
		names := make([]string, 0, len(pkg.decl))
		for name := range pkg.decl {
			names = append(names, name)
		}
		sort.Strings(names)
		declarations := make([]declaration, len(pkg.decl))
		for j, name := range names {
			declarations[j] = declaration{
				Name:  name,
				Value: pkg.decl[name],
			}
		}
		allPkgsContent[i] = &struct {
			Variable     string
			Path, Name   string
			Declarations []declaration
		}{
			Variable:     sf.variable,
			Path:         strconv.Quote(path),
			Name:         strconv.Quote(pkg.name),
			Declarations: declarations,
		}
	}

	// Skeleton for a package group.
	const pkgsSkeleton = ` + "`" + `// Code generated by scriggo command. DO NOT EDIT.
//+build {{.GOOS}},{{.BaseVersion}},!{{.NextGoVersion}}

package {{.PkgName}}

import (
{{- range .ExplicitImports}}
	{{if ne .Name ""}}{{.Name}} {{end}}"{{.Path}}"
{{- end}}
)

import . "github.com/open2b/scriggo"
{{ if not .ImportReflect}}import "reflect"{{end}}

func init() {
	{{.Variable}} = make(Packages, {{len .PkgContent}})
	var decs map[string]interface{}

	{{- range .PkgContent}}
	// {{.Path}}
	decs = make(map[string]interface{}, {{len .Declarations}})
	{{- range .Declarations}}
	decs["{{.Name}}"] = {{.Value}}
	{{- end}}
	{{.Variable}}[{{.Path}}] = &MapPackage{
		PkgName: {{.Name}},
		Declarations: decs,
	}

	{{- end}}
}
` + "`" + `

	pkgOutput := map[string]interface{}{
		"GOOS":            goos,
		"BaseVersion":     goBaseVersion(runtime.Version()),
		"NextGoVersion":   nextGoVersion(runtime.Version()),
		"PkgName":         sf.pkgName,
		"ExplicitImports": explicitImports,
		"ImportReflect":   importReflect,
		"Variable":        sf.variable,
		"PkgContent":      allPkgsContent,
	}

	t := template.Must(template.New("packages").Parse(pkgsSkeleton))
	err := t.Execute(w, pkgOutput)

	return err
}

// loadGoPackage loads the Go package with the given path and returns its name
// and its exported declarations.
//
// refToImport reports whether at least one declaration refers to the import
// path directly; for example when loading a package with no declarations or
// where all declarations are constant literals refToImport is false.
//
func loadGoPackage(path, dir, goos string, flags buildFlags, including, excluding []string) (name string, decl map[string]string, refToImport bool, err error) {

	allowed := func(n string) bool {
		if len(including) > 0 {
			for _, inc := range including {
				if inc == n {
					return true
				}
			}
			return false
		}
		if len(excluding) > 0 {
			for _, exc := range excluding {
				if exc == n {
					return false
				}
			}
			return true
		}
		return true
	}

	decl = map[string]string{}
	// TODO(marco): remove the global cache of package names.
	pkgBase := uniquePackageName(path)

	conf := &pkgs.Config{
		Mode: 1023,
	}
	if goos != "" {
		// https://github.com/open2b/scriggo/issues/388
		//  conf.Env = append(os.Environ(), "GOOS=", goos)
	}

	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "go list -json -find %s\n", path)
	}
	if dir != "" {
		cwd, err := os.Getwd()
		if err != nil {
			return "", nil, false, fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
		err = os.Chdir(dir)
		if err != nil {
			return "", nil, false, fmt.Errorf("scriggo: can't change current directory: %s", err)
		}
		defer func() {
			err = os.Chdir(cwd)
			if err != nil {
				name = ""
				decl = nil
				err = fmt.Errorf("scriggo: can't change current directory: %s", err)
			}
		}()
	}
	packages, err := pkgs.Load(conf, path)
	if err != nil {
		return "", nil, false, err
	}

	if pkgs.PrintErrors(packages) > 0 {
		return "", nil, false, errors.New("error")
	}

	if len(packages) > 1 {
		return "", nil, false, errors.New("package query returned more than one package")
	}

	if len(packages) != 1 {
		panic("bug")
	}

	name = packages[0].Name

	numUntyped := 0

	for _, v := range packages[0].TypesInfo.Defs {
		// Include only exported names. Do not take into account whether the
		// object is in a local (function) scope or not.
		if v == nil || !v.Exported() {
			continue
		}
		// Include only package-level names.
		if v.Parent() == nil || v.Parent().Parent() != types.Universe {
			continue
		}
		if !allowed(v.Name()) {
			continue
		}
		switch v := v.(type) {
		case *types.Const:
			t := v.Type()
			if basic, ok := t.(*types.Basic); ok && basic.Info()&types.IsUntyped != 0 {
				val := v.Val()
				s := val.ExactString()
				var value string
				switch val.Kind() {
				case constant.String:
					value = "UntypedStringConst(" + s + ")"
				case constant.Bool:
					value = "UntypedBooleanConst(" + s + ")"
				case constant.Int:
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				case constant.Float:
					if strings.Contains(s, "/") {
						if rat, ok := new(big.Rat).SetString(s); ok {
							s2 := rat.FloatString(512)
							if rat2, ok := new(big.Rat).SetString(s2); ok && rat.Cmp(rat2) == 0 {
								if f, ok := new(big.Float).SetPrec(512).SetString(s2); ok {
									s = f.Text('g', -1)
								}
							}
						}
					} else if !strings.Contains(s, ".") {
						s += ".0"
					}
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				case constant.Complex:
					s = strings.ReplaceAll(s[1:len(s)-1], " ", "")
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				default:
					panic(fmt.Sprintf("Unexpected constant kind %d", val.Kind()))
				}
				decl[v.Name()] = value
				numUntyped++
			} else {
				decl[v.Name()] = fmt.Sprintf("%s.%s", pkgBase, v.Name())
			}
		case *types.Func:
			if v.Type().(*types.Signature).Recv() == nil {
				decl[v.Name()] = fmt.Sprintf("%s.%s", pkgBase, v.Name())
			}
		case *types.Var:
			if !v.Embedded() && !v.IsField() {
				decl[v.Name()] = fmt.Sprintf("&%s.%s", pkgBase, v.Name())
			}
		case *types.TypeName:
			decl[v.Name()] = fmt.Sprintf("reflect.TypeOf((*%s.%s)(nil)).Elem()", pkgBase, v.Name())
		}
	}

	refToImport = len(decl) > numUntyped

	return name, decl, refToImport, nil
}

const sourcesHeaader = ` + "`" + `// Code generated by sources_gen/main.go. DO NOT EDIT.

// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func init() {
	sources = map[string][]byte{}
` + "`" + `

const sourcesFooter = ` + "`" + `}
` + "`" + `
`)
	sources["help.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

const helpScriggo = ` + "`" + `
Scriggo is an embeddable Go interpreter. The scriggo command is a tool that
can be used to build and install stand alone interpreters and to generate Go
source files useful to embed Scriggo in an application.

It also provides a web server that serves a template rooted at the current
directory, useful to learn Scriggo templates. See 'scriggo help serve'.

The scriggo tool is not required to embed Scriggo in an application but it is
useful to generate the code for a package loader used by the Scriggo Build
functions to load the packages that can be imported during the execution of a
program.

For more about the use of the scriggo command to embed Scriggo in an
application, see 'scriggo help embed'.

The scriggo command is also able to build and install stand alone interpreters
without having to write any line of Go. 

For more about to build interpreters, see 'scriggo help build' and
'scriggo help install'.

The commands are:

    embed       make a Go file with the source of a package loader useful when
                embedding Scriggo in an application

    build       build an interpreter starting from a Scriggofile     

    install     build and install an interpreter in the GOBIN directory

    serve       runs a web server and serves the template rooted at the current
                directory

    version     print Scriggo and scriggo version

    stdlib      print the packages imported by the instruction
                'IMPORT STANDARD LIBRARY' in the Scriggofile

Use 'scriggo help <command>' for more information about a command.

Additional help topics:

    Scriggofile     syntax of the Scriggofile
    
    limitations     limitations of the Scriggo compiler/runtime.
    
` + "`" + `

const helpBuild = ` + "`" + `
usage: scriggo build [-f Scriggofile] [-w] [-v] [-x] [-work] [-o output] [module]

Build compiles an interpreter for Scriggo programs from a Scriggofile in a module.

Executables are created in the current directory. To install the executables in
the directory GOBIN, see the command: scriggo install.

If an argument is given, it can be a module path or a directory path.

If the argument is a module path, the module is downloaded from its repository
and the build command looks for a Scriggofile named 'Scriggofile' in its root.
A module argument can have a version as in 'foo.boo@v2.1.0'. If no version is
given the latest version of the module is downloaded.

If the argument is a directory path, it must be rooted or must begin with
a . or .. element and the directory must be the root of a module. The build
command looks for a Scriggofile named 'Scriggofile' in that directory.

If no argument is given, the action applies to the current directory.

The name of the executable is the last element of the module's path or
directory path. For example if the module's path is 'boo/foo' the name of the
executable will be 'foo' or 'foo.exe'.

The interpreter is build from the instructions in the Scriggofile. For example:

    scriggo build github.com/example/foo

will build an interpreter named 'foo' or 'foo.exe' from the instructions in
the file at 'github.com/example/foo/Scriggofile'.

In this other example:

	scriggo build ./boo

the command will build an interpreter named 'boo' or 'boo.exe' from the
instructions in the Scriggofile './boo/Scriggofile'.

For more about the Scriggofile specific format, see 'scriggo help Scriggofile'.

The -f flag forces build to read the given Scriggofile instead of the
Scriggofile of the module. For example:

    scriggo build -f boo.Scriggofile github.com/example/foo

will build an interpreter named 'foo' or 'foo.exe' from the instructions in
the file at 'boo.Scriggofile'.

The -w flag omits the DWARF symbol table.

The -v flag prints the imported packages as defined in the Scriggofile.

The -x flag prints the executed commands.

The -work flag prints the name of a temporary directory containing a work
module used to build the interpreter. The directory will not be deleted
after the build.

The -o flag forces build to write the resulting executable to the named output
file, instead in the current directory.

See also: scriggo install and scriggo embed.
` + "`" + `

const helpInstall = ` + "`" + `
usage: scriggo install [-f Scriggofile] [-w] [-v] [-x] [-work] [module]

Install compiles and installs an interpreter for Scriggo programs
from a Scriggofile in a module.

Executables are installed in the directory GOBIN as for the go install
command.

For more about the GOBIN directory, see 'go help install'.

With the exception of the flag -o, install has the same parameters as build.
For more about the parameters, see 'scriggo help build'.

See also: scriggo build and scriggo embed.
` + "`" + `

const helpEmbed = ` + "`" + `
usage: scriggo embed [-f Scriggofile] [-v] [-x] [-o output] [module]

Embed makes a Go source file from a Scriggofile in a module, containing the
exported declarations of the packages imported in the Scriggofile. The
generated file is useful when embedding Scriggo in an application.

Embed prints the generated source to the standard output. Use the flag -o
to redirect the source to a named output file.

If an argument is given, it must be a local rooted path or must begin with
a . or .. element and it must be a module root directory. embed looks for
a Scriggofile named 'Scriggofile' in that directory.

If no argument is given, the action applies to the current directory.

The -f flag forces embed to read the given Scriggofile instead of the
Scriggofile of the module.

The declarations in the generated Go file have type scriggo.PackageLoader and
they are assigned to a variable named 'packages'. The variable can be used as
an argument to the Build functions in the scriggo package.

To give a different name to the variable use the instruction SET VARIABLE in
the Scriggofile:

    SET VARIABLE foo

The package name in the generated Go file is by default 'main', to give
a different name to the package use the instruction SET PACKAGE in the
Scriggofile:

    SET PACKAGE boo

The -v flag prints the imported packages as defined in the Scriggofile.

The -x flag prints the executed commands.

The -o flag writes the generated Go file to the named output file, instead to
the standard output.

For more about the Scriggofile specific format, see 'scriggo help Scriggofile'.

` + "`" + `

const helpServe = ` + "`" + `
usage: scriggo serve [-S n] [--metrics]

Serve runs a web server and serves the template rooted at the current
directory. It is useful to learn Scriggo templates.

It renders HTML and Markdown files based on file extension.

For example:

    http://localhost:8080/article.html

renders the template file named 'article.html' as HTML and

    http://localhost:8080/blog.md

renders the template file named 'blog.md' as Markdown. Markdown is converted to
HTML with the Goldmark parser with the options html.WithUnsafe and
parser.WithAutoHeadingID.

Templates are automatically rebuilt when a file changes.

The -S flag prints the assembly code of the served file and n determines the
maximum length, in runes, of disassembled Text instructions

    n > 0: at most n runes; leading and trailing white space are removed
    n == 0: no text
    n < 0: all text

The --metrics flags prints metrics about execution time.
` + "`" + `

const helpScriggofile = ` + "`" + `
A Scriggofile is a file with a specific format used by the scriggo command.
The scriggo command uses the instructions in a Scriggofile to build an
interpreter or a Go source file used in an application that embeds Scriggo.

A Scriggofile defines which packages an interpreted program can import,
what exported declarations in a package are accessible and so on.

The format of the Scriggofile is:

    # A comment
    INSTRUCTION arguments

A line starting with '#' is a comment, and the instructions are case
insensitive but for convention are written in uppercase (the syntax recalls
that used by Dockerfile). 

A Scriggofile must be encoded as UTF-8 and it should be named 'Scriggofile'
or with the extension '.Scriggofile' as for 'example.Scriggofile'.

The instructions are:

    IMPORT STANDARD LIBRARY 

        Makes the packages in the Go standard library (almost all) importable
        in a program executed by the interpreter.

        To view all packages imported run 'scriggo stdlib'.

    IMPORT <package>

        Make the package with path <package> importable. 

    IMPORT <package> INCLUDING <A> <B> <C>

        As for 'IMPORT <package>' but only the exported names <A>, <B> and <C>
        are imported.

    IMPORT <package> EXCLUDING <A> <B> <C>

        As for 'IMPORT <package>' but the exported names <A>, <B> and <C> are
        not imported.  

    IMPORT <package> AS <as>

        As for 'IMPORT <package>' but the path with which it can be imported
        is named <as>. INCLUDING and EXCLUDING can be used as for the other
        forms of IMPORT at the end of the instruction. Is not possible to use
        a path <as> that would conflict with a Go standard library package path,
        even if this latter is not imported in the Scriggofile.
    
    IMPORT <package> AS main

        Make the package with path <package> imported as the main package.
        It is the same as writing 'import . "<package>"' in a Go program.
        INCLUDING and EXCLUDING can be used as for the other forms of IMPORT at
        the end of the instruction.

    IMPORT <package> AS main NOT CAPITALIZED

        As for 'IMPORT <package> AS main' but the exported names in the package
        will be imported not capitalized. For example a name 'FooFoo' declared
        in the package will be imported in the script as 'fooFoo'.

    SET VARIABLE <name> 

        Set the name of the variable to witch is assigned the value of type
        scriggo.PackageLoader with the packages to import. By default the name
        is 'packages'. This instruction is only read by the 'embed' command. 

    SET PACKAGE <name>

        Set the name of the package of the generated Go source file. By default
        the name of the package is 'main'. This instruction is read only by the
        command 'scriggo embed'.

    GOOS linux windows

        Specifies the operating systems that will be supported by the built
        interpreter. If the GOOS at the time the Scriggofile is parsed is not
        listed in the GOOS instruction, the 'build' and 'install' commands
        fail. If there is no GOOS instruction, all the operating systems are
        supported. 

        To view possible GOOS values run 'go tool dist list'.
` + "`" + `

const helpLimitations = ` + "`" + `

Limitations

    These limitations are features that Scriggo currently lacks but that are
    under development. To check the state of a limitation please refer to the
    Github issue linked in the list below.

    * methods declarations (issue #458)
    * interface types definition (issue #218)
    * assigning to non-variables in 'for range' statements (issue #182)
    * importing the "unsafe" package from Scriggo (issue #288)
    * importing the "runtime" package from Scriggo (issue #524)
    * labeled continue and break statements (issue #83)
    * some kinds of pointer shorthands (issue #383)
    * compilation of non-main packages without importing them (issue #521)

    For a comprehensive list of not-yet-implemented features
    see https://github.com/open2b/scriggo/labels/missing-feature.

Limitations due to maintain the interoperability with Go official compiler 'gc'

    * types defined in Scriggo are not correctly seen by the 'reflect' package.
      This manifests itself, for example, when calling the function
      'fmt.Printf("%T", v)' where 'v' is a value with a Scriggo defined type.
      The user expects to see the name of the type but 'fmt' (which internally
      relies on the package 'reflect') prints the name of the type that wrapped
      the value in 'v' before passing it to gc.

    * not exported fields of struct types defined in Scriggo are still
      accessible from the outside.
      This is caused by the function 'reflect.StructOf' that requires that all
      fields are exported before creating the type.  By the way, such fields
      (that should be not exported) are exported with a particular prefix to
      avoid accidental accessing.

    * cannot define functions without a body (TODO)

    * a select supports a maximum of 65536 cases.

    * Go packages can be imported only if they have been precompiled into the
      Scriggo interpreter/execution environment.
      Also see the commands 'scriggo embed' and 'scriggo build'.

    * the debugger 'delve' is not compatible with Scriggo; currently there are
      no debuggers available for Scriggo.

    * types are not garbage collected.
      See Go issue #28783 (https://github.com/golang/go/issues/28783).

Arbitrary limitations

    These limitations have been arbitrarily added to Scriggo to enhance
    performances:

    * 127 registers of a given type (integer, floating point, string or
      general) per function
    * 256 function literal declarations plus unique functions calls per
      function
    * 256 types available per function
    * 256 unique predefined functions per function
    * 16384 integer values per function
    * 256 string values per function
    * 16384 floating-point values per function
    * 256 general values per function

` + "`" + `
`)
	sources["interpreter_skel.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "strings"

const interpreterSkel = ` + "`" + `// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
		// https://www.open2b.com

		// Use of this source code is governed by a BSD-style
		// license that can be found in the LICENSE file.

		// File generated by scriggo command.

		package main

		import (
			"bytes"
			"context"
			"errors"
			"flag"
			"fmt"
			"io/ioutil"
			"os"
			"path/filepath"
			"strconv"
			"time"

			"github.com/open2b/scriggo"
			"github.com/open2b/scriggo/runtime"
		)

		const usage = "usage: %s [-S] filename\n"

		var packages scriggo.Packages
		var Main *scriggo.Package

		func renderPanics(p *runtime.Panic) string {
			var msg string
			for ; p != nil; p = p.Next() {
				msg = "\n" + msg
				if p.Recovered() {
					msg = " [recovered]" + msg
				}
				msg = p.String() + msg
				if p.Next() != nil {
					msg = "\tpanic: " + msg
				}
			}
			return msg
		}

		func main() {

			var asm = flag.Bool("S", false, "print assembly listing")

			flag.Parse()

			var loadOptions = &scriggo.LoadOptions{}
			var runOptions = &scriggo.RunOptions{}

			var args = flag.Args()

			if len(args) != 1 {
				_, _ = fmt.Fprintf(os.Stderr, usage, os.Args[0])
				flag.PrintDefaults()
				os.Exit(1)
			}

			file := args[0]
			ext := filepath.Ext(file)
			if ext != ".go" {
				fmt.Printf("%s: extension must be \".go\"\n", file)
				os.Exit(1)
			}

			absFile, err := filepath.Abs(file)
			if err != nil {
				fmt.Printf("%s: %s\n", file, err)
				os.Exit(1)
			}

			switch ext {
			case ".go":
				{{ program }}
			}
		}
	` + "`" + `

const programSkel = ` + "`" + `main, err := ioutil.ReadFile(absFile)
		if err != nil {
			panic(err)
		}
		program, err := scriggo.Load(bytes.NewReader(main), packages, loadOptions)
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
		if *asm {
			_, err := program.Disassemble(os.Stdout, "main")
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
			return
		}
		code, err := program.Run(runOptions)
		if err != nil {
			if p, ok := err.(*runtime.Panic); ok {
				panic(renderPanics(p))
			}
			if err == context.DeadlineExceeded {
				err = errors.New("process took too long")
			}
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(1)
		}
		os.Exit(code)` + "`" + `

// https://github.com/open2b/scriggo/commit/4974dd3d69e1f66da40b068507ca50c91a69f7f2#r34270334.

// makeInterpreterSource returns a Go source code that interprets a Scriggo
// program.
func makeInterpreterSource() []byte {

	out := interpreterSkel
	out = strings.Replace(out, "{{ program }}", programSkel, 1)

	return []byte(out)
}
`)
	sources["main.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	_path "path"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"
	"golang.org/x/mod/semver"
)

//go:generate go run ./sources_gen
var sources map[string][]byte

func main() {

	flag.Usage = commandsHelp["scriggo"]

	// No command provided.
	if len(os.Args) == 1 {
		flag.Usage()
		exit(0)
		return
	}

	cmdArg := os.Args[1]

	// Check if the first argument is a sub-command.
	subcmd := true
	last := len(cmdArg)
	for i, c := range cmdArg {
		if (c < 'a' || c > 'z') && (i == 0 || i == last || c != '-') {
			subcmd = false
			break
		}
	}

	if subcmd {
		// Used by flag.Parse.
		os.Args = append(os.Args[:1], os.Args[2:]...)
		cmd, ok := commands[cmdArg]
		if !ok {
			stderr(
				fmt.Sprintf("scriggo %s: unknown command", cmdArg),
				` + "`" + `Run 'scriggo help' for usage.` + "`" + `,
			)
			exit(1)
			return
		}
		cmd()
		return
	}

	run()

	return
}

// TestEnvironment is true when testing the scriggo command, false otherwise.
var TestEnvironment = false

// exit causes the current program to exit with the given status code. If
// running in a test environment, every exit call is a no-op.
func exit(status int) {
	if !TestEnvironment {
		os.Exit(status)
	}
}

// stderr prints lines on stderr.
func stderr(lines ...string) {
	for _, l := range lines {
		_, _ = fmt.Fprint(os.Stderr, l+"\n")
	}
}

// exitError prints an error message on stderr with a bold red color and exits
// with status code 1.
func exitError(format string, a ...interface{}) {
	msg := fmt.Errorf(format, a...)
	stderr(msg.Error())
	exit(1)
	return
}

// commandsHelp maps a command name to a function that prints the help for
// that command.
var commandsHelp = map[string]func(){
	"scriggo": func() {
		txtToHelp(helpScriggo)
		flag.PrintDefaults()
	},
	// Help topics.
	"Scriggofile": func() {
		txtToHelp(helpScriggofile)
	},

	// Commands helps.
	"bug": func() {
		stderr(
			` + "`" + `usage: scriggo bug` + "`" + `,
			` + "`" + `Bug opens the default browser and starts a new bug report.` + "`" + `,
			` + "`" + `The report includes useful system information.` + "`" + `,
		)
	},
	"embed": func() {
		txtToHelp(helpEmbed)
	},
	"build": func() {
		txtToHelp(helpBuild)
	},
	"install": func() {
		txtToHelp(helpInstall)
	},
	"serve": func() {
		txtToHelp(helpServe)
	},
	"limitations": func() {
		txtToHelp(helpLimitations)
	},
	"stdlib": func() {
		stderr(
			` + "`" + `usage: scriggo stdlib` + "`" + `,
			` + "`" + `` + "`" + `,
			` + "`" + `Stdlib prints to the standard output the paths of the packages of the Go` + "`" + `,
			` + "`" + `standard library imported by the instruction 'IMPORT STANDARD LIBRARY' in the` + "`" + `,
			` + "`" + `Scriggofile.` + "`" + `)

	},
	"version": func() {
		stderr(
			` + "`" + `usage: scriggo version` + "`" + `,
		)
	},
}

// commands maps a command name to a function that executes that command.
// Commands are called by command-line using:
//
//		scriggo command
//
var commands = map[string]func(){
	"bug": func() {
		flag.Usage = commandsHelp["bug"]
		panic("BUG: not implemented") // remove.
	},
	"build": func() {
		flag.Usage = commandsHelp["install"]
		work := flag.Bool("work", false, "print the name of the temporary work directory and do not delete it when exiting.")
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		o := flag.String("o", "", "output file.")
		w := flag.Bool("w", false, "omit the DWARF symbol table.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := _build("build", path, buildFlags{f: *f, work: *work, v: *v, x: *x, o: *o, w: *w})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"install": func() {
		flag.Usage = commandsHelp["install"]
		work := flag.Bool("work", false, "print the name of the temporary work directory and do not delete it when exiting.")
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		w := flag.Bool("w", false, "omit the DWARF symbol table.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := _build("install", path, buildFlags{f: *f, work: *work, v: *v, x: *x, w: *w})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"embed": func() {
		flag.Usage = commandsHelp["embed"]
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		o := flag.String("o", "", "write the source to the named file instead of stdout.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := embed(path, buildFlags{f: *f, v: *v, x: *x, o: *o})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"serve": func() {
		flag.Usage = commandsHelp["serve"]
		s := flag.Int("S", 0, "print assembly listing. n determines the length of Text instructions.")
		metrics := flag.Bool("metrics", false, "print metrics about file executions.")
		flag.Parse()
		asm := -2 // -2: no assembler
		flag.Visit(func(f *flag.Flag) {
			if f.Name == "S" {
				asm = *s
				if asm < -1 {
					asm = -1
				}
			}
		})
		err := serve(asm, *metrics)
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"stdlib": func() {
		flag.Usage = commandsHelp["stdlib"]
		flag.Parse()
		if len(flag.Args()) > 0 {
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := stdlib()
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"help": func() {
		if len(os.Args) == 1 {
			flag.Usage()
			exit(0)
			return
		}
		topic := os.Args[1]
		help, ok := commandsHelp[topic]
		if !ok {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo help %s: unknown help topic. Run 'scriggo help'.\n", topic)
			exit(1)
			return
		}
		help()
	},
	"version": func() {
		flag.Usage = commandsHelp["version"]
		fmt.Printf("Scriggo module version:                (TODO) \n") // https://github.com/open2b/scriggo/issues/310
		fmt.Printf("scriggo tool version:                  (TODO) \n") // https://github.com/open2b/scriggo/issues/310
		fmt.Printf("Go version used to build scriggo:      %s\n", runtime.Version())
	},
}

// embed executes the sub commands "embed":
//
//		scriggo embed
//
func embed(path string, flags buildFlags) (err error) {

	_, err = exec.LookPath("go")
	if err != nil {
		return fmt.Errorf("scriggo: \"go\" executable file not found in $PATH\nIf not installed, " +
			"download and install Go: https://golang.org/dl/\n")
	}

	goos := os.Getenv("GOOS")
	if goos == "" {
		goos = runtime.GOOS
	}

	// Run in module-aware mode.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "export GO111MODULE=on")
	}
	if err := os.Setenv("GO111MODULE", "on"); err != nil {
		return fmt.Errorf("scriggo: can't set environment variable \"GO111MODULE\" to \"on\": %s", err)
	}

	var modDir string

	if path == "" {
		// path is current directory.
		modDir, err = os.Getwd()
		if err != nil {
			return fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
	} else if modfile.IsDirectoryPath(path) {
		// path is a local path.
		fi, err := os.Stat(path)
		if err != nil {
			if os.IsNotExist(err) {
				err = fmt.Errorf("scriggo: directory %s does not exist in:\n\t%s", path, modDir)
			}
			return err
		}
		modDir, err = filepath.Abs(path)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", path, err)
		}
		if !fi.IsDir() {
			return fmt.Errorf("scriggo: %s is not a directory:\n\t%s", path, modDir)
		}
	} else {
		return fmt.Errorf("scriggo: path, if not empty, must be rooted or must start with '.%c' or '..%c'",
			os.PathSeparator, os.PathSeparator)
	}

	// Get the absolute Scriggofile's path.
	var sfPath string
	if flags.f == "" {
		sfPath = filepath.Join(modDir, "Scriggofile")
	} else {
		sfPath, err = filepath.Abs(flags.f)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.f, err)
		}
	}

	// Read the Scriggofile.
	scriggofile, err := os.Open(sfPath)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("scriggo: no Scriggofile in:\n\t%s", sfPath)
		}
		return err
	}
	defer scriggofile.Close()

	// Parse the Scriggofile.
	sf, err := parseScriggofile(scriggofile, goos)
	if err != nil {
		return err
	}
	err = scriggofile.Close()
	if err != nil {
		return err
	}

	// Create the package declarations file.
	out, err := getOutputFlag(flags.o)
	if err != nil {
		return err
	}
	if out != nil {
		defer func() {
			err2 := out.Close()
			if err == nil {
				err = err2
			}
		}()
	}
	err = renderPackages(out, modDir, sf, goos, flags)

	return err
}

type buildFlags struct {
	work, v, x, w bool
	f, o          string
}

// build executes the commands "build" and "install".
func _build(cmd string, path string, flags buildFlags) error {

	_, err := exec.LookPath("go")
	if err != nil {
		return fmt.Errorf("scriggo: \"go\" executable file not found in $PATH\nIf not installed, " +
			"download and install Go: https://golang.org/dl/\n")
	}

	goos := os.Getenv("GOOS")
	if goos == "" {
		goos = runtime.GOOS
	}

	// Create a temporary work directory with the sources of the interpreter.
	// If the options "work" is given, the work directory name will be printed
	// and it will not be deleted after the installation.
	workDir, err := ioutil.TempDir("", "scriggo-build")
	if err != nil {
		return err
	}
	if flags.work || flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "WORK=%s\n", workDir)
	}
	if !flags.work {
		defer func() {
			err = os.RemoveAll(workDir)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: can't delete the temporary work directory:\n\t%s", err)
			}
		}()
	}

	// Run in module-aware mode.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "export GO111MODULE=on")
	}
	if err := os.Setenv("GO111MODULE", "on"); err != nil {
		return fmt.Errorf("scriggo: can't set environment variable \"GO111MODULE\" to \"on\": %s", err)
	}

	var modPath string // modPath is the module's path, it is empty it is local.
	var modVer string  // modVer is the module's version.
	var modDir string  // modDir is the directory of the module's sources.

	if path == "" {
		// path is current directory.
		modDir, err = os.Getwd()
		if err != nil {
			return fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
	} else if modfile.IsDirectoryPath(path) {
		// path is a local path.
		fi, err := os.Stat(path)
		if err != nil {
			if os.IsNotExist(err) {
				err = fmt.Errorf("scriggo: directory %s does not exist in:\n\t%s", path, modDir)
			}
			return err
		}
		modDir, err = filepath.Abs(path)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", path, err)
		}
		if !fi.IsDir() {
			return fmt.Errorf("scriggo: %s is not a directory:\n\t%s", path, modDir)
		}
	} else {
		// path is a module path.
		parts := strings.SplitN(path, "@", 2)
		if err := module.CheckPath(parts[0]); err != nil {
			return fmt.Errorf("scriggo: %s", err)
		}
		modPath = parts[0]
		version := "latest"
		if len(parts) == 2 {
			if !semver.IsValid(parts[1]) {
				return fmt.Errorf("scriggo: invalid module version %s", parts[1])
			}
			version = parts[1]
		}
		// Download the module.
		modDir, modVer, err = downloadModule(modPath, version, workDir, flags)
		if err != nil {
			return err
		}
	}

	// Get the absolute Scriggofile's path.
	var sfPath string
	if flags.f == "" {
		sfPath = filepath.Join(modDir, "Scriggofile")
	} else {
		sfPath, err = filepath.Abs(flags.f)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.f, err)
		}
	}

	// Parse the Scriggofile.
	fi, err := os.Open(sfPath)
	if err != nil {
		if os.IsNotExist(err) {
			err = fmt.Errorf("scriggo: can't find Scriggofile at:\n\t%s", sfPath)
		}
		return err
	}
	defer fi.Close()
	sf, err := parseScriggofile(fi, goos)
	if err != nil {
		return err
	}
	_ = fi.Close()

	// Parse the go.mod file.
	file := filepath.Join(modDir, "go.mod")
	data, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	goMod, err := modfile.Parse(file, data, nil)
	if err != nil {
		return err
	}
	// Make the replace paths as absolute paths.
	for _, replace := range goMod.Replace {
		if newPath := replace.New.Path; modfile.IsDirectoryPath(newPath) && !filepath.IsAbs(newPath) {
			old := replace.Old
			err = goMod.DropReplace(old.Path, old.Version)
			if err != nil {
				return fmt.Errorf("scriggo: can't remove rewrite from go.mod: %s", err)
			}
			var p string
			if modPath == "" {
				p = filepath.Join(modDir, newPath)
			} else {
				p = _path.Join(modPath, newPath)
			}
			err = goMod.AddReplace(old.Path, old.Version, p, modVer)
			if err != nil {
				return fmt.Errorf("scriggo: can't add rewrite to go.mod: %s", err)
			}
		}
	}
	if modPath == "" {
		// Add a replace for the main module.
		mod := goMod.Module.Mod
		err = goMod.AddReplace(mod.Path, mod.Version, modDir, "")
		if err != nil {
			return fmt.Errorf("scriggo: can't add rewrite to go.mod: %s", err)
		}
	}
	goMod.Cleanup()

	var base string
	if modPath == "" {
		base = filepath.Base(modDir)
	} else {
		base = filepath.Base(modPath)
	}

	dir := filepath.Join(workDir, base)

	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "mkdir $WORK%c%s\n", os.PathSeparator, base)
		_, _ = fmt.Fprintf(os.Stderr, "chdir $WORK%c%s\n", os.PathSeparator, base)
	}
	err = os.Mkdir(dir, 0777)
	if err != nil {
		return fmt.Errorf("scriggo: can't make directory %s: %s", dir, err)
	}

	// Create the go.mod file.
	goMod.AddModuleStmt("open2b.scriggo/" + base)
	{
		// TODO(marco): remove this block when Scriggo has the definitive path.
		goPaths := strings.Split(os.Getenv("GOPATH"), string(os.PathListSeparator))
		if len(goPaths) == 0 {
			panic("scriggo: empty gopath not supported")
		}
		scriggoPath := filepath.Join(goPaths[0], "src/scriggo")
		err = goMod.AddReplace("github.com/open2b/scriggo", "", scriggoPath, "")
		if err != nil {
			panic("scriggo: can't create go.mod: %s")
		}
	}
	data, err = goMod.Format()
	if err != nil {
		return fmt.Errorf("scriggo: can't create go.mod: %s", err)
	}
	err = ioutil.WriteFile(filepath.Join(dir, "go.mod"), data, 0666)
	if err != nil {
		return fmt.Errorf("scriggo: %s", err)
	}

	// Execute 'go mod tidy'.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "go mod tidy")
	}
	_, err = execGoCommand(dir, "mod", "tidy")
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	// Create the package declarations file.
	packagesPath := filepath.Join(dir, "run-packages.go")
	fi, err = os.OpenFile(packagesPath, os.O_CREATE|os.O_WRONLY|os.O_EXCL, 0666)
	if err != nil {
		return err
	}
	defer fi.Close()
	err = renderPackages(fi, dir, sf, goos, flags)
	if err != nil {
		return fmt.Errorf("scriggo: can't render packages: %s", err)
	}
	err = fi.Close()
	if err != nil {
		return fmt.Errorf("scriggo: can't render packages: %s", err)
	}

	// Create the other files.
	var b bytes.Buffer
	b.WriteString(sourcesHeaader)
	names := make([]string, 0, len(sources))
	for name := range sources {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		src := sources[name]
		srcPath := filepath.Join(dir, name)
		err = ioutil.WriteFile(srcPath, src, 0666)
		if err != nil {
			return fmt.Errorf("scriggo: can't write file %s: %s", srcPath, err)
		}
		b.WriteString("\tsources[")
		b.WriteString(strconv.Quote(name))
		b.WriteString("] = []byte(` + "`" + `")
		src = bytes.ReplaceAll(src, []byte("` + "`" + `"), []byte("` + "`" + ` + \"` + "`" + `\" + ` + "`" + `"))
		b.Write(src)
		b.WriteString("` + "`" + `)\n")
	}
	b.WriteString(sourcesFooter)
	sourcesPath := filepath.Join(dir, "sources.go")
	dest, err := os.OpenFile(sourcesPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		return fmt.Errorf("scriggo: can't open file %s: %s", sourcesPath, err)
	}
	defer dest.Close()
	_, err = b.WriteTo(dest)
	if err != nil {
		return fmt.Errorf("scriggo: can't write file %s: %s", sourcesPath, err)
	}
	err = dest.Close()
	if err != nil {
		return fmt.Errorf("scriggo: can't write file %s: %s", sourcesPath, err)
	}

	// Execute 'go mod tidy'.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "go mod tidy")
	}
	_, err = execGoCommand(dir, "mod", "tidy")
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	// Build or install the package.
	var args []string
	if cmd == "build" {
		args = []string{"build", "-o", ""}
		if flags.o == "" {
			args[2], err = filepath.Abs(base)
			if err != nil {
				return fmt.Errorf("scriggo: can't get absolute path of %s: %s", base, err)
			}
			if runtime.GOOS == "windows" {
				args[2] += ".exe"
			}
		} else {
			args[2], err = filepath.Abs(flags.o)
			if err != nil {
				return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.o, err)
			}
		}
	} else {
		args = []string{"install"}
	}
	if flags.w {
		args = append(args, "-ldflags", "-w")
	}
	if flags.x {
		_, _ = fmt.Fprint(os.Stderr, "go")
		for _, arg := range args {
			_, _ = fmt.Fprint(os.Stderr, " ", arg)
		}
		_, _ = fmt.Fprintln(os.Stderr)
	}
	_, err = execGoCommand(dir, args...)
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	return nil
}

func stdlib() (err error) {
	for _, path := range stdLibPaths() {
		_, err = fmt.Println(path)
		if err != nil {
			break
		}
	}
	return err
}

// downloadModule downloads a module, if not cached, given path and version
// and returns the local directory of its source and the version. workDir is
// the working directory and flags are the command flags.
func downloadModule(path, version, workDir string, flags buildFlags) (string, string, error) {

	// Create the go.mod file for 'go download'.
	dir := filepath.Join(workDir, "download")
	sep := string(os.PathSeparator)
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "mkdir -p $WORK%sdownload\n", sep)
	}
	err := os.Mkdir(dir, 0777)
	if err != nil {
		return "", "", fmt.Errorf("scriggo: can't make diretory %s: %s", dir, err)
	}
	goModPath := filepath.Join(dir, "go.mod")
	goModData := "module scriggo.download\nrequire " + path + " " + version
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "cat >$WORK%sdownload%sgo.mod << 'EOF'\n%s\nEOF\n", sep, sep, goModData)
	}
	err = ioutil.WriteFile(goModPath, []byte(goModData), 0666)
	if err != nil {
		return "", "", err
	}

	// Download the module.
	type jsonModule struct {
		Version string
		Dir     string
	}
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "chdir $WORK%sdownload\n", sep)
		_, _ = fmt.Fprintln(os.Stderr, "go mod download -json")
	}
	out, err := execGoCommand(dir, "mod", "download", "-json")
	if err != nil {
		if e, ok := err.(stdError); ok {
			s := e.Error()
			if strings.Contains(s, "go: errors parsing go.mod:\n") {
				if strings.Contains(s, "invalid module version \"latest\":") {
					return "", "", fmt.Errorf("scriggo: can't find module %s", path)
				} else if strings.Contains(s, "invalid module version \""+version+"\":") {
					return "", "", fmt.Errorf("scriggo: can't find version %s of module %s", version, path)
				}
			}
		}
		return "", "", err
	}

	// Read the module's directory.
	dec := json.NewDecoder(out)
	mod := &jsonModule{}
	err = dec.Decode(mod)
	if err != nil {
		return "", "", fmt.Errorf("scriggo: can't read response from 'go mod download': %v", err)
	}

	return mod.Dir, mod.Version, nil
}

type stdError string

func (e stdError) Error() string {
	return string(e)
}

// execGoCommand executes the command 'go' with dir as current directory and
// args as arguments. Returns the standard output if no error occurs.
func execGoCommand(dir string, args ...string) (out io.Reader, err error) {
	if os.Getenv("GO111MODULE") != "on" {
		panic("GO111MODULE must be 'on'")
	}
	cmd := exec.Command("go", args...)
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	cmd.Stdout = stdout
	cmd.Stderr = stderr
	cmd.Dir = dir
	err = cmd.Run()
	if err != nil {
		if _, ok := err.(*exec.ExitError); ok {
			return nil, stdError(stderr.String())
		}
		return nil, err
	}
	return stdout, nil
}

// stdLibPaths returns a copy of stdlibPaths with the packages for the runtime
// Go version.
func stdLibPaths() []string {
	version := goBaseVersion(runtime.Version())
	paths := make([]string, 0, len(stdlibPaths))
	for _, path := range stdlibPaths {
		switch path {
		case "embed", "io/fs", "runtime/metrics":
			if version != "go1.16" {
				continue
			}
		case "time/tzdata":
			if version != "go1.15" && version != "go1.16" {
				continue
			}
		}
		paths = append(paths, path)
	}
	return paths
}

// stdlibPaths contains the paths of the packages of the Go standard library
// except the packages "database", "plugin", "testing", "runtime/cgo",
// "runtime/race",  "syscall", "unsafe" and their sub packages.
var stdlibPaths = []string{
	"archive/tar",
	"archive/zip",
	"bufio",
	"bytes",
	"compress/bzip2",
	"compress/flate",
	"compress/gzip",
	"compress/lzw",
	"compress/zlib",
	"container/heap",
	"container/list",
	"container/ring",
	"context",
	"crypto",
	"crypto/aes",
	"crypto/cipher",
	"crypto/des",
	"crypto/dsa",
	"crypto/ecdsa",
	"crypto/elliptic",
	"crypto/hmac",
	"crypto/md5",
	"crypto/rand",
	"crypto/rc4",
	"crypto/rsa",
	"crypto/sha1",
	"crypto/sha256",
	"crypto/sha512",
	"crypto/subtle",
	"crypto/tls",
	"crypto/x509",
	"crypto/x509/pkix",
	"debug/dwarf",
	"debug/elf",
	"debug/gosym",
	"debug/macho",
	"debug/pe",
	"debug/plan9obj",
	"embed", // Go version 1.16
	"encoding",
	"encoding/ascii85",
	"encoding/asn1",
	"encoding/base32",
	"encoding/base64",
	"encoding/binary",
	"encoding/csv",
	"encoding/gob",
	"encoding/hex",
	"encoding/json",
	"encoding/pem",
	"encoding/xml",
	"errors",
	"expvar",
	"flag",
	"fmt",
	"go/ast",
	"go/build",
	"go/constant",
	"go/doc",
	"go/format",
	"go/importer",
	"go/parser",
	"go/printer",
	"go/scanner",
	"go/token",
	"go/types",
	"hash",
	"hash/adler32",
	"hash/crc32",
	"hash/crc64",
	"hash/fnv",
	"hash/maphash",
	"html",
	"html/template",
	"image",
	"image/color",
	"image/color/palette",
	"image/draw",
	"image/gif",
	"image/jpeg",
	"image/png",
	"index/suffixarray",
	"io",
	"io/fs", // Go version 1.16
	"io/ioutil",
	"log",
	"log/syslog",
	"math",
	"math/big",
	"math/bits",
	"math/cmplx",
	"math/rand",
	"mime",
	"mime/multipart",
	"mime/quotedprintable",
	"net",
	"net/http",
	"net/http/cgi",
	"net/http/cookiejar",
	"net/http/fcgi",
	"net/http/httptest",
	"net/http/httptrace",
	"net/http/httputil",
	"net/http/pprof",
	"net/mail",
	"net/rpc",
	"net/rpc/jsonrpc",
	"net/smtp",
	"net/textproto",
	"net/url",
	"os",
	"os/exec",
	"os/signal",
	"os/user",
	"path",
	"path/filepath",
	"reflect",
	"regexp",
	"regexp/syntax",
	"runtime",
	"runtime/debug",
	"runtime/metrics", // Go version 1.16
	"runtime/pprof",
	"runtime/trace",
	"sort",
	"strconv",
	"strings",
	"sync",
	"sync/atomic",
	"text/scanner",
	"text/tabwriter",
	"text/template",
	"text/template/parse",
	"time",
	"time/tzdata", // Go version 1.15
	"unicode",
	"unicode/utf16",
	"unicode/utf8",
}
`)
	sources["parser.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"fmt"
	"io"
	"strings"
	"unicode/utf8"
)

type Command int

const (
	commandEmbed Command = iota
	commandGenerate
	commandInstall
)

// scriggofile represents the content of a Scriggofile.
type scriggofile struct {
	pkgName  string           // name of the package to be generated.
	variable string           // variable name for embedded packages.
	goos     []string         // target GOOSs.
	imports  []*importCommand // list of imports defined in file.
}

// importCommand represents an IMPORT command in a Scriggofile.
type importCommand struct {
	stdlib         bool
	path           string
	asPath         string // import asPath asPath in Scriggo.
	notCapitalized bool   // exported names must not be capitalized.
	including      []string
	excluding      []string
}

// parseScriggofile parses a Scriggofile and returns its commands.
func parseScriggofile(src io.Reader, goos string) (*scriggofile, error) {

	sf := scriggofile{
		pkgName:  "main",
		variable: "packages",
	}

	scanner := bufio.NewScanner(src)
	ln := 0

	for scanner.Scan() {

		line := scanner.Text()
		if ln == 0 {
			// Remove UTF-8 BOM.
			line = strings.TrimPrefix(line, "0xEF0xBB0xBF")
		}
		ln++
		if !utf8.ValidString(line) {
			return nil, fmt.Errorf("invalid UTF-8 character at line %d", ln)
		}

		line = strings.TrimSpace(line)
		if len(line) == 0 || line[0] == '#' {
			continue
		}
		tokens := strings.Fields(line)
		if len(tokens) == 0 {
			continue
		}

		switch strings.ToUpper(tokens[0]) {
		case "SET":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("expecting VARIABLE or PACKAGE after %s at line %d", tokens[0], ln)
			}
			switch strings.ToUpper(tokens[1]) {
			case "VARIABLE":
				if len(tokens) == 2 {
					return nil, fmt.Errorf("missing variable name at line %d", ln)
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("too many variable names at line %d", ln)
				}
				variable := string(tokens[2])
				err := checkIdentifierName(variable)
				if err != nil {
					return nil, err
				}
				sf.variable = variable
			case "PACKAGE":
				if len(tokens) == 2 {
					return nil, fmt.Errorf("missing package name at line %d", ln)
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("too many packages names at line %d", ln)
				}
				pkgName := string(tokens[2])
				err := checkIdentifierName(pkgName)
				if err != nil {
					return nil, err
				}
				sf.pkgName = pkgName
			default:
				return nil, fmt.Errorf("unexpected %s %s, expecteding %s VARIABLE or %s PACKAGE at line %d",
					tokens[0], tokens[1], tokens[0], tokens[0], ln)
			}
		case "GOOS":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("missing os after %s at line %d", tokens[0], ln)
			}
			if sf.goos == nil {
				sf.goos = make([]string, 0, len(tokens)-1)
			}
			for _, tok := range tokens[1:] {
				os := string(tok)
				err := checkGOOS(os)
				if err != nil {
					return nil, err
				}
				sf.goos = append(sf.goos, os)
			}
		case "IMPORT":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("missing package path at line %d", ln)
			}
			path := string(tokens[1])
			if len(tokens) > 2 && strings.EqualFold(path, "STANDARD") && strings.EqualFold(tokens[2], "LIBRARY") {
				for _, imp := range sf.imports {
					if imp.stdlib {
						return nil, fmt.Errorf("command %s %s %s is repeated at line %d", tokens[0], tokens[1], tokens[2], ln)
					}
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("unexpected %q after %s %s %s at line %d", tokens[3], tokens[0], tokens[1], tokens[2], ln)
				}
				sf.imports = append(sf.imports, &importCommand{stdlib: true})
				continue
			} else {
				err := checkPackagePath(path)
				if err != nil {
					return nil, err
				}
			}
			imp := importCommand{path: path}
			parsedAs := false
			tokens = tokens[2:]
			for len(tokens) > 0 {
				switch tok := strings.ToUpper(tokens[0]); tok {
				case "AS":
					if parsedAs {
						return nil, fmt.Errorf("repeated option %s at line %d", tok, ln)
					}
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing package path after AS at line %d", ln)
					}
					path := string(tokens[1])
					err := checkPackagePath(path)
					if err != nil {
						return nil, err
					}
					if hasStdlibPrefix(path) {
						return nil, fmt.Errorf("invalid path %q (prefix conflicts with Go standard library)", path)
					}
					imp.asPath = path
					parsedAs = true
					tokens = tokens[2:]
				case "INCLUDING":
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing names after INCLUDING at line %d", ln)
					}
					imp.including = make([]string, len(tokens)-1)
					for i, tok := range tokens[1:] {
						name := string(tok)
						err := checkExportedName(name)
						if err != nil {
							return nil, err
						}
						imp.including[i] = name
					}
					tokens = nil
				case "EXCLUDING":
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing names after EXCLUDING at line %d", ln)
					}
					imp.excluding = make([]string, len(tokens)-1)
					for i, tok := range tokens[1:] {
						name := string(tok)
						err := checkExportedName(name)
						if err != nil {
							return nil, err
						}
						imp.excluding[i] = name
					}
					tokens = nil
				case "NOT":
					if len(tokens) == 1 {
						if imp.asPath == "main" {
							return nil, fmt.Errorf("unexpected %s, expecting %s CAPITALIZED at line %d", tok, tok, ln)
						}
						return nil, fmt.Errorf("unexpected %s at line %d", tok, ln)
					}
					if strings.ToUpper(tokens[1]) != "CAPITALIZED" {
						if imp.asPath == "main" {
							return nil, fmt.Errorf("unexpected %s %s, expecting %s CAPITALIZED at line %d", tok, tokens[1], tok, ln)
						}
						return nil, fmt.Errorf("unexpected %s", tok)
					}
					if imp.asPath != "main" {
						return nil, fmt.Errorf("%s %s can appear only after 'AS main' at line %d", tok, tokens[1], ln)
					}
					imp.notCapitalized = true
					tokens = tokens[2:]
				default:
					return nil, fmt.Errorf("unexpected option %s for IMPORT at line %d", tok, ln)
				}
			}
			sf.imports = append(sf.imports, &imp)
		default:
			return nil, fmt.Errorf("unknown command %s at line %d", tokens[0], ln)
		}

	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	if len(sf.goos) > 0 {
		found := false
		for _, os := range sf.goos {
			if os == goos {
				found = true
				break
			}
		}
		if !found {
			return nil, fmt.Errorf("GOOS %s not supported in Scriggofile", goos)
		}
	}

	return &sf, nil
}
`)
	sources["run.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/open2b/scriggo"
	"github.com/open2b/scriggo/runtime"
)

const usage = "usage: %s [-S] filename\n"

var packages scriggo.Packages

func run() {

	var asm = flag.Bool("S", false, "print assembly listing")

	flag.Parse()

	var args = flag.Args()

	if len(args) != 1 {
		_, _ = fmt.Fprintf(os.Stderr, usage, os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}

	file := args[0]
	ext := filepath.Ext(file)
	if ext != ".go" {
		fmt.Printf("%s: extension must be \".go\"\n", file)
		os.Exit(1)
	}

	absFile, err := filepath.Abs(file)
	if err != nil {
		fmt.Printf("%s: %s\n", file, err)
		os.Exit(1)
	}

	main, err := ioutil.ReadFile(absFile)
	if err != nil {
		panic(err)
	}

	program, err := scriggo.Build(bytes.NewReader(main), &scriggo.BuildOptions{Packages: packages})
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
		os.Exit(2)
	}
	if *asm {
		asm, _ := program.Disassemble("main")
		_, err := os.Stdout.Write(asm)
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
	} else {
		code, err := program.Run(nil)
		if err != nil {
			if p, ok := err.(*runtime.Panic); ok {
				panic(p)
			}
			if err == context.DeadlineExceeded {
				err = errors.New("process took too long")
			}
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
		os.Exit(code)
	}
	os.Exit(0)
}
`)
	sources["serve.go"] = []byte(`// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/open2b/scriggo"
	"github.com/open2b/scriggo/fs"
	"github.com/open2b/scriggo/templates"
	"github.com/open2b/scriggo/templates/builtin"

	"github.com/fsnotify/fsnotify"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
)

// serve runs a web server and serves the template rooted at the current
// directory. metrics reports whether print the metrics. If asm is -1 or
// greater, serve prints the assembly code of the served file and the value of
// asm determines the maximum length, in runes, of disassembled Text
// instructions
//
//   asm > 0: at most asm runes; leading and trailing white space are removed
//   asm == 0: no text
//   asm == -1: all text
//
func serve(asm int, metrics bool) error {

	fsys, err := newTemplateFS(".")
	if err != nil {
		return err
	}
	defer fsys.Close()

	md := goldmark.New(
		goldmark.WithRendererOptions(html.WithUnsafe()),
		goldmark.WithParserOptions(parser.WithAutoHeadingID()))

	srv := &server{
		fsys:   fsys,
		static: http.FileServer(http.Dir(".")),
		buildOptions: &templates.BuildOptions{
			Globals: globals,
			MarkdownConverter: func(src []byte, out io.Writer) error {
				return md.Convert(src, out)
			},
		},
		templates: map[string]*templates.Template{},
		asm:       asm,
	}
	if metrics {
		srv.metrics.active = true
		srv.metrics.header = true
	}
	go func() {
		for {
			select {
			case name := <-fsys.Changed:
				delete(srv.templates, name)
			case err := <-fsys.Errors:
				srv.logf("%v", err)
			}
		}
	}()

	s := &http.Server{
		Addr:           ":8080",
		Handler:        srv,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	fmt.Fprintln(os.Stderr, "Web server is available at http://localhost:8080/")
	fmt.Fprintf(os.Stderr, "Press Ctrl+C to stop\n\n")

	return s.ListenAndServe()
}

type server struct {
	fsys         *templateFS
	static       http.Handler
	buildOptions *templates.BuildOptions
	runOptions   *templates.RunOptions
	asm          int

	sync.Mutex
	templates map[string]*templates.Template
	metrics   struct {
		active bool
		header bool
	}
}

func (srv *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {

	name := r.URL.Path[1:]
	if name == "" || strings.HasSuffix(name, "/") {
		name += "index.html"
	}

	if ext := path.Ext(name); ext != ".html" && ext != ".md" {
		srv.static.ServeHTTP(w, r)
		return
	}

	var err error
	var buildTime time.Duration
	srv.Lock()
	template, ok := srv.templates[name]
	srv.Unlock()
	start := time.Now()
	if !ok {
		template, err = templates.Build(srv.fsys, name, srv.buildOptions)
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				http.NotFound(w, r)
				return
			}
			if err, ok := err.(scriggo.CompilerError); ok {
				w.Header().Set("Content-Type", "text/plain; charset=utf-8")
				w.WriteHeader(500)
				fmt.Fprintf(w, "%s", err)
				return
			}
			http.Error(w, "Internal Server Error", 500)
			srv.logf("%s", err)
			return
		}
		buildTime = time.Since(start)
		srv.Lock()
		srv.templates[name] = template
		srv.Unlock()
		start = time.Now()
	}
	b := bytes.Buffer{}
	vars := map[string]interface{}{"form": builtin.NewFormData(r, 10)}
	err = template.Run(&b, vars, srv.runOptions)
	if err != nil {
		switch err {
		case builtin.ErrBadRequest:
			http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		case builtin.ErrRequestEntityTooLarge:
			http.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)
		default:
			http.Error(w, err.Error(), 500)
		}
		return
	}
	runTime := time.Since(start)

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	_, err = b.WriteTo(w)
	if err != nil {
		srv.logf("%s", err)
	}

	if srv.metrics.active {
		var header bool
		srv.Lock()
		header = srv.metrics.header
		srv.Unlock()
		if header {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "Build", "Run", "Total", "File")
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "-----", "---", "-----", "----")
			srv.Lock()
			srv.metrics.header = false
			srv.Unlock()
		}
		if buildTime == 0 {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "-", runTime, buildTime+runTime, name)
		} else {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", buildTime, runTime, buildTime+runTime, name)
		}
	}

	if srv.asm >= -1 {
		asm := template.Disassemble(srv.asm)
		srv.logf("\n--- Assembler %s ---\n", name)
		_, _ = os.Stderr.Write(asm)
		srv.log("-----------------\n")
	}

	return
}

func (srv *server) log(a ...interface{}) {
	println()
	fmt.Fprint(os.Stderr, a...)
	println()
	srv.metrics.header = true
}

func (srv *server) logf(format string, a ...interface{}) {
	println()
	fmt.Fprintf(os.Stderr, format, a...)
	println()
	srv.metrics.header = true
}

// templateFS implements a file system that reads the files in a directory.
type templateFS struct {
	fsys    fs.FS
	watcher *fsnotify.Watcher
	watched map[string]bool
	Errors  chan error

	sync.Mutex
	Changed chan string
}

func newTemplateFS(root string) (*templateFS, error) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, err
	}
	dir := &templateFS{
		fsys:    fs.DirFS(root),
		watcher: watcher,
		watched: map[string]bool{},
		Changed: make(chan string),
	}
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}
				if event.Op&fsnotify.Write == fsnotify.Write {
					dir.Changed <- event.Name
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				dir.Errors <- err
			}
		}
	}()
	return dir, nil
}

func (t *templateFS) Open(name string) (fs.File, error) {
	err := t.watch(name)
	if err != nil {
		return nil, err
	}
	return t.fsys.Open(name)
}

func (t *templateFS) ReadFile(name string) ([]byte, error) {
	err := t.watch(name)
	if err != nil {
		return nil, err
	}
	return fs.ReadFile(t.fsys, name)
}

func (t *templateFS) Close() error {
	return t.watcher.Close()
}

func (t *templateFS) watch(name string) error {
	t.Lock()
	if !t.watched[name] {
		err := t.watcher.Add(name)
		if err != nil {
			t.Unlock()
			return err
		}
		t.watched[name] = true
	}
	t.Unlock()
	return nil
}

var globals = templates.Declarations{
	// crypto
	"hmacSHA1":   builtin.HmacSHA1,
	"hmacSHA256": builtin.HmacSHA256,
	"sha1":       builtin.Sha1,
	"sha256":     builtin.Sha256,

	// encoding
	"base64":            builtin.Base64,
	"hex":               builtin.Hex,
	"marshalJSON":       builtin.MarshalJSON,
	"marshalJSONIndent": builtin.MarshalJSONIndent,
	"md5":               builtin.Md5,
	"unmarshalJSON":     builtin.UnmarshalJSON,

	// html
	"htmlEscape": builtin.HtmlEscape,

	// math
	"abs": builtin.Abs,
	"max": builtin.Max,
	"min": builtin.Min,

	// net
	"File":        reflect.TypeOf((*builtin.File)(nil)).Elem(),
	"FormData":    reflect.TypeOf(builtin.FormData{}),
	"form":        (*builtin.FormData)(nil),
	"queryEscape": builtin.QueryEscape,

	// regexp
	"Regexp": reflect.TypeOf(builtin.Regexp{}),
	"regexp": builtin.RegExp,

	// sort
	"reverse": builtin.Reverse,
	"sort":    builtin.Sort,

	// strconv
	"formatFloat": builtin.FormatFloat,
	"formatInt":   builtin.FormatInt,
	"parseFloat":  builtin.ParseFloat,
	"parseInt":    builtin.ParseInt,

	// strings
	"abbreviate":    builtin.Abbreviate,
	"capitalize":    builtin.Capitalize,
	"capitalizeAll": builtin.CapitalizeAll,
	"hasPrefix":     builtin.HasPrefix,
	"hasSuffix":     builtin.HasSuffix,
	"index":         builtin.Index,
	"indexAny":      builtin.IndexAny,
	"join":          builtin.Join,
	"lastIndex":     builtin.LastIndex,
	"replace":       builtin.Replace,
	"replaceAll":    builtin.ReplaceAll,
	"runeCount":     builtin.RuneCount,
	"split":         builtin.Split,
	"splitAfter":    builtin.SplitAfter,
	"splitAfterN":   builtin.SplitAfterN,
	"splitN":        builtin.SplitN,
	"sprint":        builtin.Sprint,
	"sprintf":       builtin.Sprintf,
	"toKebab":       builtin.ToKebab,
	"toLower":       builtin.ToLower,
	"toUpper":       builtin.ToUpper,
	"trim":          builtin.Trim,
	"trimLeft":      builtin.TrimLeft,
	"trimPrefix":    builtin.TrimPrefix,
	"trimRight":     builtin.TrimRight,
	"trimSuffix":    builtin.TrimSuffix,

	// time
	"Duration":      reflect.TypeOf(builtin.Duration(0)),
	"Hour":          time.Hour,
	"Microsecond":   time.Microsecond,
	"Millisecond":   time.Millisecond,
	"Minute":        time.Minute,
	"Nanosecond":    time.Nanosecond,
	"Second":        time.Second,
	"Time":          reflect.TypeOf(builtin.Time{}),
	"date":          builtin.Date,
	"now":           builtin.Now,
	"parseDuration": builtin.ParseDuration,
	"parseTime":     builtin.ParseTime,
	"unixTime":      builtin.UnixTime,
}
`)
	sources["util.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type nopCloser struct {
	io.Writer
}

func (nopCloser) Close() error {
	return nil
}

func getOutputFlag(output string) (io.WriteCloser, error) {
	if output == "" {
		return nopCloser{os.Stdout}, nil
	}
	if output == os.DevNull {
		return nil, nil
	}
	dir, file := filepath.Split(output)
	if file == "" {
		exitError("%q cannot be a directory", output)
	}
	if dir != "" {
		err := os.MkdirAll(dir, 0777)
		if err != nil {
			return nil, err
		}
	}
	return os.OpenFile(output, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
}

// uncapitalize "uncapitalizes" n.
//
// 	Name        ->  name
//	DoubleWord  ->  doubleWord
//  AbC         ->  abC
//
func uncapitalize(n string) string {
	isUp := unicode.IsUpper
	toLow := unicode.ToLower
	if n == "" {
		return n
	}
	runes := []rune(n)
	if len(runes) == 1 {
		return string(toLow(runes[0]))
	}
	if !isUp(runes[0]) {
		return n
	}
	b := bytes.Buffer{}
	b.Grow(len(n))
	var i int
	b.WriteRune(toLow(runes[0]))
	for i = 1; i < len(runes)-1; i++ {
		if isUp(runes[i]) && isUp(runes[i+1]) {
			b.WriteRune(toLow(runes[i]))
		} else {
			break
		}
	}
	for ; i < len(runes)-1; i++ {
		b.WriteRune(runes[i])
	}
	if isUp(runes[i]) && isUp(runes[i-1]) {
		b.WriteRune(toLow(runes[i]))
	} else {
		b.WriteRune(runes[i])
	}
	return b.String()
}

var predeclaredIdentifier = []string{
	"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
	"int", "int8", "int16", "int32", "int64", "rune", "string", "uint", "uint8",
	"uint16", "uint32", "uint64", "uintptr", "true", "false", "iota",
	"nil", "append", "cap", "close", "complex", "copy", "delete", "imag",
	"len", "make", "new", "panic", "print", "println", "real", "recover",
}

// isPredeclaredIdentifier reports whether name is a Go predeclared
// identifier.
func isPredeclaredIdentifier(name string) bool {
	for _, pred := range predeclaredIdentifier {
		if name == pred {
			return true
		}
	}
	return false
}

func txtToHelp(s string) {
	s = strings.TrimSpace(s)
	stderr(strings.Split(s, "\n")...)
}

var uniquePackageNameCache = map[string]string{}

var goKeywords = []string{
	"break", "case", "chan", "const", "continue", "default", "defer", "else",
	"fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map",
	"package", "range", "return", "struct", "select", "switch", "type", "var",
}

// isGoKeyword reports whether a string is a Go keyword.
func isGoKeyword(s string) bool {
	for _, k := range goKeywords {
		if s == k {
			return true
		}
	}
	return false
}

// uniquePackageName generates an unique package name for every package path.
func uniquePackageName(pkgPath string) string {

	pkgName := filepath.Base(pkgPath)
	done := false
	for !done {
		done = true
		cachePath, ok := uniquePackageNameCache[pkgName]
		if ok && cachePath != pkgPath {
			done = false
			pkgName += "_"
		}
	}
	if isGoKeyword(pkgName) {
		pkgName = "_" + pkgName + "_"
	}
	uniquePackageNameCache[pkgName] = pkgPath

	return pkgName
}

// goBaseVersion returns the go base version for v.
//
//		1.15.5 -> 1.15
//
func goBaseVersion(v string) string {
	// When updating, also update test/compare/run.go.
	if strings.HasPrefix(v, "devel ") {
		v = v[len("devel "):]
		if i := strings.Index(v, "-"); i >= 0 {
			v = v[:i]
		}
	}
	if i := strings.Index(v, "beta"); i >= 0 {
		v = v[:i]
	}
	if i := strings.Index(v, "rc"); i >= 0 {
		v = v[:i]
	}
	v = v[4:]
	f, err := strconv.ParseFloat(v, 32)
	if err != nil {
		panic(err)
	}
	f = math.Floor(f)
	next := int(f)
	return fmt.Sprintf("go1.%d", next)
}

// hasStdlibPrefix reports whether the prefix of path conflicts with the path of
// a package of the Go standard library.
func hasStdlibPrefix(path string) bool {
	stdlibPrefixes := []string{
		"archive", "bufio", "bytes", "compress", "container",
		"context", "crypto", "database", "debug", "embed", "encoding",
		"errors", "expvar", "flag", "fmt", "go", "hash", "html", "image",
		"index", "io", "log", "math", "mime", "net", "os",
		"path", "plugin", "reflect", "regexp", "runtime", "sort",
		"strconv", "strings", "sync", "syscall", "testing", "text",
		"time", "unicode", "unsafe",
	}
	first := strings.Split(path, "/")[0]
	for _, pref := range stdlibPrefixes {
		if pref == first {
			return true
		}
	}
	return false
}

// nextGoVersion returns the successive go version of v.
//
//		1.15.5 -> 1.16
//
func nextGoVersion(v string) string {
	v = goBaseVersion(v)[4:]
	f, err := strconv.ParseFloat(v, 32)
	if err != nil {
		panic(err)
	}
	f = math.Floor(f)
	next := int(f) + 1
	return fmt.Sprintf("go1.%d", next)
}

// checkIdentifierName checks that name is a valid not blank identifier name.
func checkIdentifierName(name string) error {
	if name == "_" {
		return fmt.Errorf("cannot use the blank identifier")
	}
	if isGoKeyword(name) {
		return fmt.Errorf("invalid variable name")
	}
	first := true
	for _, r := range name {
		if !unicode.IsLetter(r) && (first || !unicode.IsDigit(r)) {
			return fmt.Errorf("invalid identifier name")
		}
		first = false
	}
	return nil
}

// checkGOOS checks that os is a valid GOOS value.
func checkGOOS(os string) error {
	switch os {
	case "darwin", "dragonfly", "js", "linux", "android", "solaris",
		"freebsd", "nacl", "netbsd", "openbsd", "plan9", "windows", "aix":
		return nil
	}
	return fmt.Errorf("unkown os %q", os)
}

// checkPackagePath checks that a given package path is valid.
//
// This function must be in sync with the function validPackagePath in the
// file "scriggo/compiler/path".
func checkPackagePath(path string) error {
	if path == "main" {
		return nil
	}
	for _, r := range path {
		if !unicode.In(r, unicode.L, unicode.M, unicode.N, unicode.P, unicode.S) {
			return fmt.Errorf("invalid path path %q", path)
		}
		switch r {
		case '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', ':', ';', '<',
			'=', '>', '?', '[', '\\', ']', '^', '` + "`" + `', '{', '|', '}', '\uFFFD':
			return fmt.Errorf("invalid path path %q", path)
		}
	}
	if ss := strings.Split(path, "/"); len(ss) > 0 && ss[0] == "internal" {
		return fmt.Errorf("use of internal package %q not allowed", path)
	}
	if cleaned := cleanPath(path); path != cleaned {
		return fmt.Errorf("invalid path path %q", path)
	}
	return nil
}

// checkExportedName checks that name is a valid exported identifier name.
func checkExportedName(name string) error {
	err := checkIdentifierName(name)
	if err != nil {
		return err
	}
	if fc, _ := utf8.DecodeRuneInString(name); !unicode.Is(unicode.Lu, fc) {
		return fmt.Errorf("cannot refer to unexported name %s", name)
	}
	return nil
}

// cleanPath cleans a path and returns the path in its canonical form.
// path must be already a valid path.
//
// This function must be in sync with the function cleanPath in the file
// "scriggo/compiler/path".
func cleanPath(path string) string {
	if !strings.Contains(path, "..") {
		return path
	}
	var b = []byte(path)
	for i := 0; i < len(b); i++ {
		if b[i] == '/' {
			if b[i+1] == '.' && b[i+2] == '.' {
				s := bytes.LastIndexByte(b[:i], '/')
				b = append(b[:s+1], b[i+4:]...)
				i = s - 1
			}
		}
	}
	return string(b)
}
`)
}
