// Code generated by sources_gen/main.go. DO NOT EDIT.

// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func init() {
	sources = map[string][]byte{}
	sources["generate.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"errors"
	"fmt"
	"go/constant"
	"go/types"
	"io"
	"math/big"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"text/template"

	pkgs "golang.org/x/tools/go/packages"
)

// renderPackages renders a Scriggofile. It also returns a boolean indicating
// if the content contains packages. Ignores all main packages contained in
// the Scriggofile.
func renderPackages(w io.Writer, dir string, sf *scriggofile, goos string, flags buildFlags) error {

	type packageType struct {
		name string
		decl map[string]string
	}

	// Import the packages of the Go standard library.
	for i, imp := range sf.imports {
		if imp.stdlib {
			paths := stdLibPaths()
			imports := make([]*importCommand, len(sf.imports)+len(paths)-1)
			copy(imports[:i], sf.imports[:i])
			for j, path := range paths {
				imports[i+j] = &importCommand{path: path}
			}
			copy(imports[i+len(paths):], sf.imports[i+1:])
			sf.imports = imports
		}
	}

	importReflect := false

	explicitImports := []struct{ Name, Path string }{}
	for _, imp := range sf.imports {
		uniqueName := uniquePackageName(imp.path)
		if uniqueName != imp.path { // TODO: uniqueName should be compared to the package name and not to the package path.
			explicitImports = append(explicitImports, struct{ Name, Path string }{uniqueName, imp.path})
		} else {
			explicitImports = append(explicitImports, struct{ Name, Path string }{"", imp.path})
		}
		if imp.path == "reflect" {
			importReflect = true
		}
	}

	packages := map[string]*packageType{}
	for i, imp := range sf.imports {
		if flags.v {
			_, _ = fmt.Fprintf(os.Stderr, "%s\n", imp.path)
		}
		pkgName, decls, refToImport, err := loadGoPackage(imp.path, dir, goos, flags, imp.including, imp.excluding)
		if err != nil {
			return err
		}
		if !refToImport {
			explicitImports[i].Name = "_"
		}
		// No declarations at path: move on to next import path.
		if len(decls) == 0 {
			continue
		}
		if imp.notCapitalized {
			tmp := map[string]string{}
			for name, decl := range decls {
				newName := uncapitalize(name)
				if newName == "main" || newName == "init" {
					return fmt.Errorf("%q is not a valid identifier: remove 'uncapitalized' or change declaration name in package %q", newName, imp.path)
				}
				if isGoKeyword(newName) {
					return fmt.Errorf("%q is not a valid identifier as it conflicts with Go keyword %q: remove 'uncapitalized' or change declaration name in package %q", newName, newName, imp.path)
				}
				if isPredeclaredIdentifier(newName) {
					if newName == "print" || newName == "println" {
						// https://github.com/open2b/scriggo/issues/361.
					} else {
						return fmt.Errorf("%q is not a valid identifier as it conflicts with Go predeclared identifier %q: remove 'uncapitalized' or change declaration name in package %q", newName, newName, imp.path)
					}
				}
				tmp[newName] = decl
			}
			decls = tmp
		}

		// Determine which import path use: the default (the one specified in
		// source, used by Go) or a new one indicated in Scriggo comments.
		path := imp.path
		if imp.asPath != "" {
			path = imp.asPath
		}

		switch imp.asPath {
		case "main": // Add read declarations to package main as builtins.
			if packages["main"] == nil {
				packages["main"] = &packageType{"main", map[string]string{}}
			}
			for name, decl := range decls {
				if _, ok := packages["main"].decl[name]; ok {
					return fmt.Errorf("declaration name collision in package main: %q", name)
				}
				packages["main"].decl[name] = decl
			}
		default: // Add read declarations to the specified package.
			if packages[path] == nil {
				packages[path] = &packageType{
					decl: map[string]string{},
				}
			}
			for name, decl := range decls {
				if _, ok := packages[path].decl[name]; ok {
					return fmt.Errorf("declaration name collision: %q in package %q", name, imp.path)
				}
				packages[path].decl[name] = decl
				packages[path].name = pkgName
				name = filepath.Base(path)
			}
		}

	}

	if w == nil {
		return nil
	}

	// If no packages have been declared, just return.
	if len(packages) == 0 {
		return nil
	}

	// Render package content.
	paths := make([]string, 0, len(packages))
	hasMain := false
	for path := range packages {
		if path == "main" {
			hasMain = true
			continue
		}
		paths = append(paths, path)
	}
	sort.Strings(paths)
	if hasMain {
		paths = append([]string{"main"}, paths...)
	}
	type declaration struct {
		Name  string
		Value string
	}
	allPkgsContent := make([]*struct {
		Variable     string
		Path, Name   string
		Declarations []declaration
	}, len(paths))
	for i, path := range paths {
		pkg := packages[path]
		names := make([]string, 0, len(pkg.decl))
		for name := range pkg.decl {
			names = append(names, name)
		}
		sort.Strings(names)
		declarations := make([]declaration, len(pkg.decl))
		for j, name := range names {
			declarations[j] = declaration{
				Name:  name,
				Value: pkg.decl[name],
			}
		}
		allPkgsContent[i] = &struct {
			Variable     string
			Path, Name   string
			Declarations []declaration
		}{
			Variable:     sf.variable,
			Path:         strconv.Quote(path),
			Name:         strconv.Quote(pkg.name),
			Declarations: declarations,
		}
	}

	// Skeleton for a package group.
	const pkgsSkeleton = ` + "`" + `// Code generated by scriggo command. DO NOT EDIT.
//+build {{.GOOS}},{{.BaseVersion}},!{{.NextGoVersion}}

package {{.PkgName}}

import (
{{- range .ExplicitImports}}
	{{if ne .Name ""}}{{.Name}} {{end}}"{{.Path}}"
{{- end}}
)

import . "github.com/open2b/scriggo"
{{ if not .ImportReflect}}import "reflect"{{end}}

func init() {
	{{.Variable}} = make(Packages, {{len .PkgContent}})
	var decs map[string]interface{}

	{{- range .PkgContent}}
	// {{.Path}}
	decs = make(map[string]interface{}, {{len .Declarations}})
	{{- range .Declarations}}
	decs["{{.Name}}"] = {{.Value}}
	{{- end}}
	{{.Variable}}[{{.Path}}] = &MapPackage{
		PkgName: {{.Name}},
		Declarations: decs,
	}

	{{- end}}
}
` + "`" + `

	pkgOutput := map[string]interface{}{
		"GOOS":            goos,
		"BaseVersion":     goBaseVersion(runtime.Version()),
		"NextGoVersion":   nextGoVersion(runtime.Version()),
		"PkgName":         sf.pkgName,
		"ExplicitImports": explicitImports,
		"ImportReflect":   importReflect,
		"Variable":        sf.variable,
		"PkgContent":      allPkgsContent,
	}

	t := template.Must(template.New("packages").Parse(pkgsSkeleton))
	err := t.Execute(w, pkgOutput)

	return err
}

// loadGoPackage loads the Go package with the given path and returns its name
// and its exported declarations.
//
// refToImport reports whether at least one declaration refers to the import
// path directly; for example when loading a package with no declarations or
// where all declarations are constant literals refToImport is false.
//
func loadGoPackage(path, dir, goos string, flags buildFlags, including, excluding []string) (name string, decl map[string]string, refToImport bool, err error) {

	allowed := func(n string) bool {
		if len(including) > 0 {
			for _, inc := range including {
				if inc == n {
					return true
				}
			}
			return false
		}
		if len(excluding) > 0 {
			for _, exc := range excluding {
				if exc == n {
					return false
				}
			}
			return true
		}
		return true
	}

	decl = map[string]string{}
	// TODO(marco): remove the global cache of package names.
	pkgBase := uniquePackageName(path)

	conf := &pkgs.Config{
		Mode: 1023,
	}
	if goos != "" {
		// https://github.com/open2b/scriggo/issues/388
		//  conf.Env = append(os.Environ(), "GOOS=", goos)
	}

	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "go list -json -find %s\n", path)
	}
	if dir != "" {
		cwd, err := os.Getwd()
		if err != nil {
			return "", nil, false, fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
		err = os.Chdir(dir)
		if err != nil {
			return "", nil, false, fmt.Errorf("scriggo: can't change current directory: %s", err)
		}
		defer func() {
			err = os.Chdir(cwd)
			if err != nil {
				name = ""
				decl = nil
				err = fmt.Errorf("scriggo: can't change current directory: %s", err)
			}
		}()
	}
	packages, err := pkgs.Load(conf, path)
	if err != nil {
		return "", nil, false, err
	}

	if pkgs.PrintErrors(packages) > 0 {
		return "", nil, false, errors.New("error")
	}

	if len(packages) > 1 {
		return "", nil, false, errors.New("package query returned more than one package")
	}

	if len(packages) != 1 {
		panic("bug")
	}

	name = packages[0].Name

	numUntyped := 0

	for _, v := range packages[0].TypesInfo.Defs {
		// Include only exported names. Do not take into account whether the
		// object is in a local (function) scope or not.
		if v == nil || !v.Exported() {
			continue
		}
		// Include only package-level names.
		if v.Parent() == nil || v.Parent().Parent() != types.Universe {
			continue
		}
		if !allowed(v.Name()) {
			continue
		}
		switch v := v.(type) {
		case *types.Const:
			t := v.Type()
			if basic, ok := t.(*types.Basic); ok && basic.Info()&types.IsUntyped != 0 {
				val := v.Val()
				s := val.ExactString()
				var value string
				switch val.Kind() {
				case constant.String:
					value = "UntypedStringConst(" + s + ")"
				case constant.Bool:
					value = "UntypedBooleanConst(" + s + ")"
				case constant.Int:
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				case constant.Float:
					if strings.Contains(s, "/") {
						if rat, ok := new(big.Rat).SetString(s); ok {
							s2 := rat.FloatString(512)
							if rat2, ok := new(big.Rat).SetString(s2); ok && rat.Cmp(rat2) == 0 {
								if f, ok := new(big.Float).SetPrec(512).SetString(s2); ok {
									s = f.Text('g', -1)
								}
							}
						}
					} else if !strings.Contains(s, ".") {
						s += ".0"
					}
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				case constant.Complex:
					s = strings.ReplaceAll(s[1:len(s)-1], " ", "")
					value = "UntypedNumericConst(" + strconv.Quote(s) + ")"
				default:
					panic(fmt.Sprintf("Unexpected constant kind %d", val.Kind()))
				}
				decl[v.Name()] = value
				numUntyped++
			} else {
				decl[v.Name()] = fmt.Sprintf("%s.%s", pkgBase, v.Name())
			}
		case *types.Func:
			if v.Type().(*types.Signature).Recv() == nil {
				decl[v.Name()] = fmt.Sprintf("%s.%s", pkgBase, v.Name())
			}
		case *types.Var:
			if !v.Embedded() && !v.IsField() {
				decl[v.Name()] = fmt.Sprintf("&%s.%s", pkgBase, v.Name())
			}
		case *types.TypeName:
			decl[v.Name()] = fmt.Sprintf("reflect.TypeOf((*%s.%s)(nil)).Elem()", pkgBase, v.Name())
		}
	}

	refToImport = len(decl) > numUntyped

	return name, decl, refToImport, nil
}

const sourcesHeaader = ` + "`" + `// Code generated by sources_gen/main.go. DO NOT EDIT.

// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func init() {
	sources = map[string][]byte{}
` + "`" + `

const sourcesFooter = ` + "`" + `}
` + "`" + `
`)
	sources["help.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

const helpScriggo = ` + "`" + `
Scriggo is an embeddable Go interpreter. The scriggo command is a tool that
can be used to build and install stand alone interpreters and to generate Go
source files useful to embed Scriggo in an application.

It also provides a web server that serves a template rooted at the current
directory, useful to learn Scriggo templates. See 'scriggo help serve'.

The scriggo tool is not required to embed Scriggo in an application but it is
useful to generate the code for a package loader used by the Scriggo Build
functions to load the packages that can be imported during the execution of
programs and scripts.

For more about the use of the scriggo command to embed Scriggo in an
application, see 'scriggo help embed'.

The scriggo command is also able to build and install stand alone interpreters
without having to write any line of Go. 

For more about to build interpreters, see 'scriggo help build' and
'scriggo help install'.

The commands are:

    embed       make a Go file with the source of a package loader useful when
                embedding Scriggo in an application

    build       build an interpreter starting from a Scriggofile     

    install     build and install an interpreter in the GOBIN directory

    serve       runs a web server and serves the template rooted at the current
                directory

    version     print Scriggo and scriggo version

    stdlib      print the packages imported by the instruction
                'IMPORT STANDARD LIBRARY' in the Scriggofile

Use 'scriggo help <command>' for more information about a command.

Additional help topics:

    Scriggofile     syntax of the Scriggofile
    
    limitations     limitations of the Scriggo compiler/runtime.
    
` + "`" + `

const helpBuild = ` + "`" + `
usage: scriggo build [-f Scriggofile] [-w] [-v] [-x] [-work] [-o output] [module]

Build compiles an interpreter for Go programs and Scriggo scripts from a
Scriggofile in a module.

Executables are created in the current directory. To install the executables in
the directory GOBIN, see the command: scriggo install.

If an argument is given, it can be a module path or a directory path.

If the argument is a module path, the module is downloaded from its repository
and the build command looks for a Scriggofile named 'Scriggofile' in its root.
A module argument can have a version as in 'foo.boo@v2.1.0'. If no version is
given the latest version of the module is downloaded.

If the argument is a directory path, it must be rooted or must begin with
a . or .. element and the directory must be the root of a module. The build
command looks for a Scriggofile named 'Scriggofile' in that directory.

If no argument is given, the action applies to the current directory.

The name of the executable is the last element of the module's path or
directory path. For example if the module's path is 'boo/foo' the name of the
executable will be 'foo' or 'foo.exe'.

The interpreter is build from the instructions in the Scriggofile. For example:

    scriggo build github.com/example/foo

will build an interpreter named 'foo' or 'foo.exe' from the instructions in
the file at 'github.com/example/foo/Scriggofile'.

In this other example:

	scriggo build ./boo

the command will build an interpreter named 'boo' or 'boo.exe' from the
instructions in the Scriggofile './boo/Scriggofile'.

For more about the Scriggofile specific format, see 'scriggo help Scriggofile'.

The -f flag forces build to read the given Scriggofile instead of the
Scriggofile of the module. For example:

    scriggo build -f boo.Scriggofile github.com/example/foo

will build an interpreter named 'foo' or 'foo.exe' from the instructions in
the file at 'boo.Scriggofile'.

The -w flag omits the DWARF symbol table.

The -v flag prints the imported packages as defined in the Scriggofile.

The -x flag prints the executed commands.

The -work flag prints the name of a temporary directory containing a work
module used to build the interpreter. The directory will not be deleted
after the build.

The -o flag forces build to write the resulting executable to the named output
file, instead in the current directory.

See also: scriggo install and scriggo embed.
` + "`" + `

const helpInstall = ` + "`" + `
usage: scriggo install [-f Scriggofile] [-w] [-v] [-x] [-work] [module]

Install compiles and installs an interpreter for Go programs and Scriggo
scripts from a Scriggofile in a module.

Executables are installed in the directory GOBIN as for the go install
command.

For more about the GOBIN directory, see 'go help install'.

With the exception of the flag -o, install has the same parameters as build.
For more about the parameters, see 'scriggo help build'.

See also: scriggo build and scriggo embed.
` + "`" + `

const helpEmbed = ` + "`" + `
usage: scriggo embed [-f Scriggofile] [-v] [-x] [-o output] [module]

Embed makes a Go source file from a Scriggofile in a module, containing the
exported declarations of the packages imported in the Scriggofile. The
generated file is useful when embedding Scriggo in an application.

Embed prints the generated source to the standard output. Use the flag -o
to redirect the source to a named output file.

If an argument is given, it must be a local rooted path or must begin with
a . or .. element and it must be a module root directory. embed looks for
a Scriggofile named 'Scriggofile' in that directory.

If no argument is given, the action applies to the current directory.

The -f flag forces embed to read the given Scriggofile instead of the
Scriggofile of the module.

The declarations in the generated Go file have type scriggo.PackageLoader and
they are assigned to a variable named 'packages'. The variable can be used as
an argument to the Build functions in the scriggo package.

To give a different name to the variable use the instruction SET VARIABLE in
the Scriggofile:

    SET VARIABLE foo

The package name in the generated Go file is by default 'main', to give
a different name to the package use the instruction SET PACKAGE in the
Scriggofile:

    SET PACKAGE boo

The -v flag prints the imported packages as defined in the Scriggofile.

The -x flag prints the executed commands.

The -o flag writes the generated Go file to the named output file, instead to
the standard output.

For more about the Scriggofile specific format, see 'scriggo help Scriggofile'.

` + "`" + `

const helpServe = ` + "`" + `
usage: scriggo serve [-S n] [--metrics]

Serve runs a web server and serves the template rooted at the current
directory. It is useful to learn Scriggo templates.

It renders HTML and Markdown files based on file extension.

For example:

    http://localhost:8080/article.html

renders the template file named 'article.html' as HTML and

    http://localhost:8080/blog.md

renders the template file named 'blog.md' as Markdown. Markdown is converted to
HTML with the Goldmark parser with the options html.WithUnsafe and
parser.WithAutoHeadingID.

Templates are automatically rebuilt when a file changes.

The -S flag prints the assembly code of the served file and n determines the
maximum length, in runes, of disassembled Text instructions

    n > 0: at most n runes; leading and trailing white space are removed
    n == 0: no text
    n < 0: all text

The --metrics flags prints metrics about execution time.
` + "`" + `

const helpScriggofile = ` + "`" + `
A Scriggofile is a file with a specific format used by the scriggo command.
The scriggo command uses the instructions in a Scriggofile to build an
interpreter or a Go source file used in an application that embeds Scriggo.

A Scriggofile defines which packages an interpreted program and script can
import, what exported declarations in a package are accessible and so on.

The format of the Scriggofile is:

    # A comment
    INSTRUCTION arguments

A line starting with '#' is a comment, and the instructions are case
insensitive but for convention are written in uppercase (the syntax recalls
that used by Dockerfile). 

A Scriggofile must be encoded as UTF-8 and it should be named 'Scriggofile'
or with the extension '.Scriggofile' as for 'example.Scriggofile'.

The instructions are:

    IMPORT STANDARD LIBRARY 

        Makes the packages in the Go standard library (almost all) importable
        in a program or script executed by the interpreter.

        To view all packages imported run 'scriggo stdlib'.

    IMPORT <package>

        Make the package with path <package> importable. 

    IMPORT <package> INCLUDING <A> <B> <C>

        As for 'IMPORT <package>' but only the exported names <A>, <B> and <C>
        are imported.

    IMPORT <package> EXCLUDING <A> <B> <C>

        As for 'IMPORT <package>' but the exported names <A>, <B> and <C> are
        not imported.  

    IMPORT <package> AS <as>

        As for 'IMPORT <package>' but the path with which it can be imported
        is named <as>. INCLUDING and EXCLUDING can be used as for the other
        forms of IMPORT at the end of the instruction. Is not possible to use
        a path <as> that would conflict with a Go standard library package path,
        even if this latter is not imported in the Scriggofile.
    
    IMPORT <package> AS main

        Make the package with path <package> imported as the main package.
        It is the same as writing 'import . "<package>"' in a Go program.
        INCLUDING and EXCLUDING can be used as for the other forms of IMPORT at
        the end of the instruction.

    IMPORT <package> AS main NOT CAPITALIZED

        As for 'IMPORT <package> AS main' but the exported names in the package
        will be imported not capitalized. For example a name 'FooFoo' declared
        in the package will be imported in the script as 'fooFoo'.

    SET VARIABLE <name> 

        Set the name of the variable to witch is assigned the value of type
        scriggo.PackageLoader with the packages to import. By default the name
        is 'packages'. This instruction is only read by the 'embed' command. 

    SET PACKAGE <name>

        Set the name of the package of the generated Go source file. By default
        the name of the package is 'main'. This instruction is read only by the
        command 'scriggo embed'.

    GOOS linux windows

        Specifies the operating systems that will be supported by the built
        interpreter. If the GOOS at the time the Scriggofile is parsed is not
        listed in the GOOS instruction, the 'build' and 'install' commands
        fail. If there is no GOOS instruction, all the operating systems are
        supported. 

        To view possible GOOS values run 'go tool dist list'.
` + "`" + `

const helpLimitations = ` + "`" + `

Limitations

    These limitations are features that Scriggo currently lacks but that are
    under development. To check the state of a limitation please refer to the
    Github issue linked in the list below.

    * methods declarations (issue #458)
    * interface types definition (issue #218)
    * assigning to non-variables in 'for range' statements (issue #182)
    * importing the "unsafe" package from Scriggo (issue #288)
    * importing the "runtime" package from Scriggo (issue #524)
    * labeled continue and break statements (issue #83)
    * some kinds of pointer shorthands (issue #383)
    * compilation of non-main packages without importing them (issue #521)

    For a comprehensive list of not-yet-implemented features
    see https://github.com/open2b/scriggo/labels/missing-feature.

Limitations due to maintain the interoperability with Go official compiler 'gc'

    * types defined in Scriggo are not correctly seen by the 'reflect' package.
      This manifests itself, for example, when calling the function
      'fmt.Printf("%T", v)' where 'v' is a value with a Scriggo defined type.
      The user expects to see the name of the type but 'fmt' (which internally
      relies on the package 'reflect') prints the name of the type that wrapped
      the value in 'v' before passing it to gc.

    * not exported fields of struct types defined in Scriggo are still
      accessible from the outside.
      This is caused by the function 'reflect.StructOf' that requires that all
      fields are exported before creating the type.  By the way, such fields
      (that should be not exported) are exported with a particular prefix to
      avoid accidental accessing.

    * cannot define functions without a body (TODO)

    * a select supports a maximum of 65536 cases.

    * Go packages can be imported only if they have been precompiled into the
      Scriggo interpreter/execution environment.
      Also see the commands 'scriggo embed' and 'scriggo build'.

    * types are not garbage collected.
      See Go issue #28783 (https://github.com/golang/go/issues/28783).

Arbitrary limitations

    These limitations have been arbitrarily added to Scriggo to enhance
    performances:

    * 127 registers of a given type (integer, floating point, string or
      general) per function
    * 256 function literal declarations plus unique functions calls per
      function
    * 256 types available per function
    * 256 unique predefined functions per function
    * 16384 integer values per function
    * 256 string values per function
    * 16384 floating-point values per function
    * 256 general values per function

` + "`" + `
`)
	sources["interpreter_skel.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "strings"

const interpreterSkel = ` + "`" + `// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
		// https://www.open2b.com

		// Use of this source code is governed by a BSD-style
		// license that can be found in the LICENSE file.

		// File generated by scriggo command.

		package main

		import (
			"bytes"
			"context"
			"errors"
			"flag"
			"fmt"
			"io/ioutil"
			"os"
			"path/filepath"
			"strconv"
			"time"

			"github.com/open2b/scriggo"
			"github.com/open2b/scriggo/runtime"
		)

		const usage = "usage: %s [-S] filename\n"

		var packages scriggo.Packages
		var Main *scriggo.Package

		func renderPanics(p *runtime.Panic) string {
			var msg string
			for ; p != nil; p = p.Next() {
				msg = "\n" + msg
				if p.Recovered() {
					msg = " [recovered]" + msg
				}
				msg = p.String() + msg
				if p.Next() != nil {
					msg = "\tpanic: " + msg
				}
			}
			return msg
		}

		func main() {

			var asm = flag.Bool("S", false, "print assembly listing")

			flag.Parse()

			var loadOptions = &scriggo.LoadOptions{}
			var runOptions = &scriggo.RunOptions{}

			var args = flag.Args()

			if len(args) != 1 {
				_, _ = fmt.Fprintf(os.Stderr, usage, os.Args[0])
				flag.PrintDefaults()
				os.Exit(1)
			}

			file := args[0]
			ext := filepath.Ext(file)
			if ext != ".go" {
				fmt.Printf("%s: extension must be \".go\"\n", file)
				os.Exit(1)
			}

			absFile, err := filepath.Abs(file)
			if err != nil {
				fmt.Printf("%s: %s\n", file, err)
				os.Exit(1)
			}

			switch ext {
			case ".go":
				{{ program }}
			}
		}
	` + "`" + `

const programSkel = ` + "`" + `main, err := ioutil.ReadFile(absFile)
		if err != nil {
			panic(err)
		}
		program, err := scriggo.Load(bytes.NewReader(main), packages, loadOptions)
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
		if *asm {
			_, err := program.Disassemble(os.Stdout, "main")
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
			return
		}
		code, err := program.Run(runOptions)
		if err != nil {
			if p, ok := err.(*runtime.Panic); ok {
				panic(renderPanics(p))
			}
			if err == context.DeadlineExceeded {
				err = errors.New("process took too long")
			}
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(1)
		}
		os.Exit(code)` + "`" + `

// https://github.com/open2b/scriggo/commit/4974dd3d69e1f66da40b068507ca50c91a69f7f2#r34270334.

// makeInterpreterSource returns a Go source code that interprets a Scriggo
// program.
func makeInterpreterSource() []byte {

	out := interpreterSkel
	out = strings.Replace(out, "{{ program }}", programSkel, 1)

	return []byte(out)
}
`)
	sources["main.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	_path "path"
	"path/filepath"
	"runtime"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"
	"golang.org/x/mod/semver"
)

//go:generate go run ./sources_gen
var sources map[string][]byte

func main() {

	flag.Usage = commandsHelp["scriggo"]

	// No command provided.
	if len(os.Args) == 1 {
		flag.Usage()
		exit(0)
		return
	}

	cmdArg := os.Args[1]

	// Check if the first argument is a sub-command.
	subcmd := true
	last := len(cmdArg)
	for i, c := range cmdArg {
		if (c < 'a' || c > 'z') && (i == 0 || i == last || c != '-') {
			subcmd = false
			break
		}
	}

	if subcmd {
		// Used by flag.Parse.
		os.Args = append(os.Args[:1], os.Args[2:]...)
		cmd, ok := commands[cmdArg]
		if !ok {
			stderr(
				fmt.Sprintf("scriggo %s: unknown command", cmdArg),
				` + "`" + `Run 'scriggo help' for usage.` + "`" + `,
			)
			exit(1)
			return
		}
		cmd()
		return
	}

	run()

	return
}

// TestEnvironment is true when testing the scriggo command, false otherwise.
var TestEnvironment = false

// exit causes the current program to exit with the given status code. If
// running in a test environment, every exit call is a no-op.
func exit(status int) {
	if !TestEnvironment {
		os.Exit(status)
	}
}

// stderr prints lines on stderr.
func stderr(lines ...string) {
	for _, l := range lines {
		_, _ = fmt.Fprint(os.Stderr, l+"\n")
	}
}

// exitError prints an error message on stderr with a bold red color and exits
// with status code 1.
func exitError(format string, a ...interface{}) {
	msg := fmt.Errorf(format, a...)
	stderr(msg.Error())
	exit(1)
	return
}

// commandsHelp maps a command name to a function that prints the help for
// that command.
var commandsHelp = map[string]func(){
	"scriggo": func() {
		txtToHelp(helpScriggo)
		flag.PrintDefaults()
	},
	// Help topics.
	"Scriggofile": func() {
		txtToHelp(helpScriggofile)
	},

	// Commands helps.
	"bug": func() {
		stderr(
			` + "`" + `usage: scriggo bug` + "`" + `,
			` + "`" + `Bug opens the default browser and starts a new bug report.` + "`" + `,
			` + "`" + `The report includes useful system information.` + "`" + `,
		)
	},
	"embed": func() {
		txtToHelp(helpEmbed)
	},
	"build": func() {
		txtToHelp(helpBuild)
	},
	"install": func() {
		txtToHelp(helpInstall)
	},
	"serve": func() {
		txtToHelp(helpServe)
	},
	"limitations": func() {
		txtToHelp(helpLimitations)
	},
	"stdlib": func() {
		stderr(
			` + "`" + `usage: scriggo stdlib` + "`" + `,
			` + "`" + `` + "`" + `,
			` + "`" + `Stdlib prints to the standard output the paths of the packages of the Go` + "`" + `,
			` + "`" + `standard library imported by the instruction 'IMPORT STANDARD LIBRARY' in the` + "`" + `,
			` + "`" + `Scriggofile.` + "`" + `)

	},
	"version": func() {
		stderr(
			` + "`" + `usage: scriggo version` + "`" + `,
		)
	},
}

// commands maps a command name to a function that executes that command.
// Commands are called by command-line using:
//
//		scriggo command
//
var commands = map[string]func(){
	"bug": func() {
		flag.Usage = commandsHelp["bug"]
		panic("BUG: not implemented") // remove.
	},
	"build": func() {
		flag.Usage = commandsHelp["install"]
		work := flag.Bool("work", false, "print the name of the temporary work directory and do not delete it when exiting.")
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		o := flag.String("o", "", "output file.")
		w := flag.Bool("w", false, "omit the DWARF symbol table.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := _build("build", path, buildFlags{f: *f, work: *work, v: *v, x: *x, o: *o, w: *w})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"install": func() {
		flag.Usage = commandsHelp["install"]
		work := flag.Bool("work", false, "print the name of the temporary work directory and do not delete it when exiting.")
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		w := flag.Bool("w", false, "omit the DWARF symbol table.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := _build("install", path, buildFlags{f: *f, work: *work, v: *v, x: *x, w: *w})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"embed": func() {
		flag.Usage = commandsHelp["embed"]
		f := flag.String("f", "", "path of the Scriggofile.")
		v := flag.Bool("v", false, "print the names of packages as the are imported.")
		x := flag.Bool("x", false, "print the commands.")
		o := flag.String("o", "", "write the source to the named file instead of stdout.")
		flag.Parse()
		var path string
		switch n := len(flag.Args()); n {
		case 0:
		case 1:
			path = flag.Arg(0)
		default:
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := embed(path, buildFlags{f: *f, v: *v, x: *x, o: *o})
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"serve": func() {
		flag.Usage = commandsHelp["serve"]
		s := flag.Int("S", 0, "print assembly listing. n determines the length of Text instructions.")
		metrics := flag.Bool("metrics", false, "print metrics about file executions.")
		flag.Parse()
		asm := -2 // -2: no assembler
		flag.Visit(func(f *flag.Flag) {
			if f.Name == "S" {
				asm = *s
				if asm < -1 {
					asm = -1
				}
			}
		})
		err := serve(asm, *metrics)
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"stdlib": func() {
		flag.Usage = commandsHelp["stdlib"]
		flag.Parse()
		if len(flag.Args()) > 0 {
			flag.Usage()
			exitError(` + "`" + `bad number of arguments` + "`" + `)
		}
		err := stdlib()
		if err != nil {
			exitError("%s", err)
		}
		exit(0)
	},
	"help": func() {
		if len(os.Args) == 1 {
			flag.Usage()
			exit(0)
			return
		}
		topic := os.Args[1]
		help, ok := commandsHelp[topic]
		if !ok {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo help %s: unknown help topic. Run 'scriggo help'.\n", topic)
			exit(1)
			return
		}
		help()
	},
	"version": func() {
		flag.Usage = commandsHelp["version"]
		fmt.Printf("Scriggo module version:                (TODO) \n") // https://github.com/open2b/scriggo/issues/310
		fmt.Printf("scriggo tool version:                  (TODO) \n") // https://github.com/open2b/scriggo/issues/310
		fmt.Printf("Go version used to build scriggo:      %s\n", runtime.Version())
	},
}

// embed executes the sub commands "embed":
//
//		scriggo embed
//
func embed(path string, flags buildFlags) (err error) {

	_, err = exec.LookPath("go")
	if err != nil {
		return fmt.Errorf("scriggo: \"go\" executable file not found in $PATH\nIf not installed, " +
			"download and install Go: https://golang.org/dl/\n")
	}

	goos := os.Getenv("GOOS")
	if goos == "" {
		goos = runtime.GOOS
	}

	// Run in module-aware mode.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "export GO111MODULE=on")
	}
	if err := os.Setenv("GO111MODULE", "on"); err != nil {
		return fmt.Errorf("scriggo: can't set environment variable \"GO111MODULE\" to \"on\": %s", err)
	}

	var modDir string

	if path == "" {
		// path is current directory.
		modDir, err = os.Getwd()
		if err != nil {
			return fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
	} else if modfile.IsDirectoryPath(path) {
		// path is a local path.
		fi, err := os.Stat(path)
		if err != nil {
			if os.IsNotExist(err) {
				err = fmt.Errorf("scriggo: directory %s does not exist in:\n\t%s", path, modDir)
			}
			return err
		}
		modDir, err = filepath.Abs(path)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", path, err)
		}
		if !fi.IsDir() {
			return fmt.Errorf("scriggo: %s is not a directory:\n\t%s", path, modDir)
		}
	} else {
		return fmt.Errorf("scriggo: path, if not empty, must be rooted or must start with '.%c' or '..%c'",
			os.PathSeparator, os.PathSeparator)
	}

	// Get the absolute Scriggofile's path.
	var sfPath string
	if flags.f == "" {
		sfPath = filepath.Join(modDir, "Scriggofile")
	} else {
		sfPath, err = filepath.Abs(flags.f)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.f, err)
		}
	}

	// Read the Scriggofile.
	scriggofile, err := os.Open(sfPath)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("scriggo: no Scriggofile in:\n\t%s", sfPath)
		}
		return err
	}
	defer scriggofile.Close()

	// Parse the Scriggofile.
	sf, err := parseScriggofile(scriggofile, goos)
	if err != nil {
		return err
	}
	err = scriggofile.Close()
	if err != nil {
		return err
	}

	// Create the package declarations file.
	out, err := getOutputFlag(flags.o)
	if err != nil {
		return err
	}
	if out != nil {
		defer func() {
			err2 := out.Close()
			if err == nil {
				err = err2
			}
		}()
	}
	err = renderPackages(out, modDir, sf, goos, flags)

	return err
}

type buildFlags struct {
	work, v, x, w bool
	f, o          string
}

// build executes the commands "build" and "install".
func _build(cmd string, path string, flags buildFlags) error {

	_, err := exec.LookPath("go")
	if err != nil {
		return fmt.Errorf("scriggo: \"go\" executable file not found in $PATH\nIf not installed, " +
			"download and install Go: https://golang.org/dl/\n")
	}

	goos := os.Getenv("GOOS")
	if goos == "" {
		goos = runtime.GOOS
	}

	// Create a temporary work directory with the sources of the interpreter.
	// If the options "work" is given, the work directory name will be printed
	// and it will not be deleted after the installation.
	workDir, err := ioutil.TempDir("", "scriggo-build")
	if err != nil {
		return err
	}
	if flags.work || flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "WORK=%s\n", workDir)
	}
	if !flags.work {
		defer func() {
			err = os.RemoveAll(workDir)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: can't delete the temporary work directory:\n\t%s", err)
			}
		}()
	}

	// Run in module-aware mode.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "export GO111MODULE=on")
	}
	if err := os.Setenv("GO111MODULE", "on"); err != nil {
		return fmt.Errorf("scriggo: can't set environment variable \"GO111MODULE\" to \"on\": %s", err)
	}

	var modPath string // modPath is the module's path, it is empty it is local.
	var modVer string  // modVer is the module's version.
	var modDir string  // modDir is the directory of the module's sources.

	if path == "" {
		// path is current directory.
		modDir, err = os.Getwd()
		if err != nil {
			return fmt.Errorf("scriggo: can't get current directory: %s", err)
		}
	} else if modfile.IsDirectoryPath(path) {
		// path is a local path.
		fi, err := os.Stat(path)
		if err != nil {
			if os.IsNotExist(err) {
				err = fmt.Errorf("scriggo: directory %s does not exist in:\n\t%s", path, modDir)
			}
			return err
		}
		modDir, err = filepath.Abs(path)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", path, err)
		}
		if !fi.IsDir() {
			return fmt.Errorf("scriggo: %s is not a directory:\n\t%s", path, modDir)
		}
	} else {
		// path is a module path.
		parts := strings.SplitN(path, "@", 2)
		if err := module.CheckPath(parts[0]); err != nil {
			return fmt.Errorf("scriggo: %s", err)
		}
		modPath = parts[0]
		version := "latest"
		if len(parts) == 2 {
			if !semver.IsValid(parts[1]) {
				return fmt.Errorf("scriggo: invalid module version %s", parts[1])
			}
			version = parts[1]
		}
		// Download the module.
		modDir, modVer, err = downloadModule(modPath, version, workDir, flags)
		if err != nil {
			return err
		}
	}

	// Get the absolute Scriggofile's path.
	var sfPath string
	if flags.f == "" {
		sfPath = filepath.Join(modDir, "Scriggofile")
	} else {
		sfPath, err = filepath.Abs(flags.f)
		if err != nil {
			return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.f, err)
		}
	}

	// Parse the Scriggofile.
	fi, err := os.Open(sfPath)
	if err != nil {
		if os.IsNotExist(err) {
			err = fmt.Errorf("scriggo: can't find Scriggofile at:\n\t%s", sfPath)
		}
		return err
	}
	defer fi.Close()
	sf, err := parseScriggofile(fi, goos)
	if err != nil {
		return err
	}
	_ = fi.Close()

	// Parse the go.mod file.
	file := filepath.Join(modDir, "go.mod")
	data, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	goMod, err := modfile.Parse(file, data, nil)
	if err != nil {
		return err
	}
	// Make the replace paths as absolute paths.
	for _, replace := range goMod.Replace {
		if newPath := replace.New.Path; modfile.IsDirectoryPath(newPath) && !filepath.IsAbs(newPath) {
			old := replace.Old
			err = goMod.DropReplace(old.Path, old.Version)
			if err != nil {
				return fmt.Errorf("scriggo: can't remove rewrite from go.mod: %s", err)
			}
			var p string
			if modPath == "" {
				p = filepath.Join(modDir, newPath)
			} else {
				p = _path.Join(modPath, newPath)
			}
			err = goMod.AddReplace(old.Path, old.Version, p, modVer)
			if err != nil {
				return fmt.Errorf("scriggo: can't add rewrite to go.mod: %s", err)
			}
		}
	}
	if modPath == "" {
		// Add a replace for the main module.
		mod := goMod.Module.Mod
		err = goMod.AddReplace(mod.Path, mod.Version, modDir, "")
		if err != nil {
			return fmt.Errorf("scriggo: can't add rewrite to go.mod: %s", err)
		}
	}
	goMod.Cleanup()

	var base string
	if modPath == "" {
		base = filepath.Base(modDir)
	} else {
		base = filepath.Base(modPath)
	}

	dir := filepath.Join(workDir, base)

	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "mkdir $WORK%c%s\n", os.PathSeparator, base)
		_, _ = fmt.Fprintf(os.Stderr, "chdir $WORK%c%s\n", os.PathSeparator, base)
	}
	err = os.Mkdir(dir, 0777)
	if err != nil {
		return fmt.Errorf("scriggo: can't make directory %s: %s", dir, err)
	}

	// Create the go.mod file.
	goMod.AddModuleStmt("open2b.scriggo/" + base)
	{
		// TODO(marco): remove this block when Scriggo has the definitive path.
		goPaths := strings.Split(os.Getenv("GOPATH"), string(os.PathListSeparator))
		if len(goPaths) == 0 {
			panic("scriggo: empty gopath not supported")
		}
		scriggoPath := filepath.Join(goPaths[0], "src/scriggo")
		err = goMod.AddReplace("github.com/open2b/scriggo", "", scriggoPath, "")
		if err != nil {
			panic("scriggo: can't create go.mod: %s")
		}
	}
	data, err = goMod.Format()
	if err != nil {
		return fmt.Errorf("scriggo: can't create go.mod: %s", err)
	}
	err = ioutil.WriteFile(filepath.Join(dir, "go.mod"), data, 0666)
	if err != nil {
		return fmt.Errorf("scriggo: %s", err)
	}

	// Execute 'go mod tidy'.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "go mod tidy")
	}
	_, err = execGoCommand(dir, "mod", "tidy")
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	// Create the package declarations file.
	packagesPath := filepath.Join(dir, "run-packages.go")
	fi, err = os.OpenFile(packagesPath, os.O_CREATE|os.O_WRONLY|os.O_EXCL, 0666)
	if err != nil {
		return err
	}
	defer fi.Close()
	err = renderPackages(fi, dir, sf, goos, flags)
	if err != nil {
		return fmt.Errorf("scriggo: can't render packages: %s", err)
	}
	err = fi.Close()
	if err != nil {
		return fmt.Errorf("scriggo: can't render packages: %s", err)
	}

	// Create the other files.
	var b bytes.Buffer
	b.WriteString(sourcesHeaader)
	names := make([]string, 0, len(sources))
	for name := range sources {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		src := sources[name]
		srcPath := filepath.Join(dir, name)
		err = ioutil.WriteFile(srcPath, src, 0666)
		if err != nil {
			return fmt.Errorf("scriggo: can't write file %s: %s", srcPath, err)
		}
		b.WriteString("\tsources[")
		b.WriteString(strconv.Quote(name))
		b.WriteString("] = []byte(` + "`" + `")
		src = bytes.ReplaceAll(src, []byte("` + "`" + `"), []byte("` + "`" + ` + \"` + "`" + `\" + ` + "`" + `"))
		b.Write(src)
		b.WriteString("` + "`" + `)\n")
	}
	b.WriteString(sourcesFooter)
	sourcesPath := filepath.Join(dir, "sources.go")
	dest, err := os.OpenFile(sourcesPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		return fmt.Errorf("scriggo: can't open file %s: %s", sourcesPath, err)
	}
	defer dest.Close()
	_, err = b.WriteTo(dest)
	if err != nil {
		return fmt.Errorf("scriggo: can't write file %s: %s", sourcesPath, err)
	}
	err = dest.Close()
	if err != nil {
		return fmt.Errorf("scriggo: can't write file %s: %s", sourcesPath, err)
	}

	// Execute 'go mod tidy'.
	if flags.x {
		_, _ = fmt.Fprintln(os.Stderr, "go mod tidy")
	}
	_, err = execGoCommand(dir, "mod", "tidy")
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	// Build or install the package.
	var args []string
	if cmd == "build" {
		args = []string{"build", "-o", ""}
		if flags.o == "" {
			args[2], err = filepath.Abs(base)
			if err != nil {
				return fmt.Errorf("scriggo: can't get absolute path of %s: %s", base, err)
			}
			if runtime.GOOS == "windows" {
				args[2] += ".exe"
			}
		} else {
			args[2], err = filepath.Abs(flags.o)
			if err != nil {
				return fmt.Errorf("scriggo: can't get absolute path of %s: %s", flags.o, err)
			}
		}
	} else {
		args = []string{"install"}
	}
	if flags.w {
		args = append(args, "-ldflags", "-w")
	}
	if flags.x {
		_, _ = fmt.Fprint(os.Stderr, "go")
		for _, arg := range args {
			_, _ = fmt.Fprint(os.Stderr, " ", arg)
		}
		_, _ = fmt.Fprintln(os.Stderr)
	}
	_, err = execGoCommand(dir, args...)
	if err != nil {
		return fmt.Errorf("go %s: %s", cmd, err)
	}

	return nil
}

func stdlib() (err error) {
	for _, path := range stdLibPaths() {
		_, err = fmt.Println(path)
		if err != nil {
			break
		}
	}
	return err
}

// downloadModule downloads a module, if not cached, given path and version
// and returns the local directory of its source and the version. workDir is
// the working directory and flags are the command flags.
func downloadModule(path, version, workDir string, flags buildFlags) (string, string, error) {

	// Create the go.mod file for 'go download'.
	dir := filepath.Join(workDir, "download")
	sep := string(os.PathSeparator)
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "mkdir -p $WORK%sdownload\n", sep)
	}
	err := os.Mkdir(dir, 0777)
	if err != nil {
		return "", "", fmt.Errorf("scriggo: can't make diretory %s: %s", dir, err)
	}
	goModPath := filepath.Join(dir, "go.mod")
	goModData := "module scriggo.download\nrequire " + path + " " + version
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "cat >$WORK%sdownload%sgo.mod << 'EOF'\n%s\nEOF\n", sep, sep, goModData)
	}
	err = ioutil.WriteFile(goModPath, []byte(goModData), 0666)
	if err != nil {
		return "", "", err
	}

	// Download the module.
	type jsonModule struct {
		Version string
		Dir     string
	}
	if flags.x {
		_, _ = fmt.Fprintf(os.Stderr, "chdir $WORK%sdownload\n", sep)
		_, _ = fmt.Fprintln(os.Stderr, "go mod download -json")
	}
	out, err := execGoCommand(dir, "mod", "download", "-json")
	if err != nil {
		if e, ok := err.(stdError); ok {
			s := e.Error()
			if strings.Contains(s, "go: errors parsing go.mod:\n") {
				if strings.Contains(s, "invalid module version \"latest\":") {
					return "", "", fmt.Errorf("scriggo: can't find module %s", path)
				} else if strings.Contains(s, "invalid module version \""+version+"\":") {
					return "", "", fmt.Errorf("scriggo: can't find version %s of module %s", version, path)
				}
			}
		}
		return "", "", err
	}

	// Read the module's directory.
	dec := json.NewDecoder(out)
	mod := &jsonModule{}
	err = dec.Decode(mod)
	if err != nil {
		return "", "", fmt.Errorf("scriggo: can't read response from 'go mod download': %v", err)
	}

	return mod.Dir, mod.Version, nil
}

type stdError string

func (e stdError) Error() string {
	return string(e)
}

// execGoCommand executes the command 'go' with dir as current directory and
// args as arguments. Returns the standard output if no error occurs.
func execGoCommand(dir string, args ...string) (out io.Reader, err error) {
	if os.Getenv("GO111MODULE") != "on" {
		panic("GO111MODULE must be 'on'")
	}
	cmd := exec.Command("go", args...)
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	cmd.Stdout = stdout
	cmd.Stderr = stderr
	cmd.Dir = dir
	err = cmd.Run()
	if err != nil {
		if _, ok := err.(*exec.ExitError); ok {
			return nil, stdError(stderr.String())
		}
		return nil, err
	}
	return stdout, nil
}

// stdLibPaths returns a copy of stdlibPaths with the packages for the runtime
// Go version.
func stdLibPaths() []string {
	paths := make([]string, len(stdlibPaths))
	copy(paths, stdlibPaths)
	return paths
}

// stdlibPaths contains the paths of the packages of the Go standard library
// except the packages "database", "plugin", "testing", "runtime/cgo",
// "runtime/race",  "syscall", "unsafe" and their sub packages.
var stdlibPaths = []string{
	"archive/tar",
	"archive/zip",
	"bufio",
	"bytes",
	"compress/bzip2",
	"compress/flate",
	"compress/gzip",
	"compress/lzw",
	"compress/zlib",
	"container/heap",
	"container/list",
	"container/ring",
	"context",
	"crypto",
	"crypto/aes",
	"crypto/cipher",
	"crypto/des",
	"crypto/dsa",
	"crypto/ecdsa",
	"crypto/elliptic",
	"crypto/hmac",
	"crypto/md5",
	"crypto/rand",
	"crypto/rc4",
	"crypto/rsa",
	"crypto/sha1",
	"crypto/sha256",
	"crypto/sha512",
	"crypto/subtle",
	"crypto/tls",
	"crypto/x509",
	"crypto/x509/pkix",
	"debug/dwarf",
	"debug/elf",
	"debug/gosym",
	"debug/macho",
	"debug/pe",
	"debug/plan9obj",
	"embed",
	"encoding",
	"encoding/ascii85",
	"encoding/asn1",
	"encoding/base32",
	"encoding/base64",
	"encoding/binary",
	"encoding/csv",
	"encoding/gob",
	"encoding/hex",
	"encoding/json",
	"encoding/pem",
	"encoding/xml",
	"errors",
	"expvar",
	"flag",
	"fmt",
	"go/ast",
	"go/build",
	"go/constant",
	"go/doc",
	"go/format",
	"go/importer",
	"go/parser",
	"go/printer",
	"go/scanner",
	"go/token",
	"go/types",
	"hash",
	"hash/adler32",
	"hash/crc32",
	"hash/crc64",
	"hash/fnv",
	"hash/maphash",
	"html",
	"html/template",
	"image",
	"image/color",
	"image/color/palette",
	"image/draw",
	"image/gif",
	"image/jpeg",
	"image/png",
	"index/suffixarray",
	"io",
	"io/fs",
	"io/ioutil",
	"log",
	"log/syslog",
	"math",
	"math/big",
	"math/bits",
	"math/cmplx",
	"math/rand",
	"mime",
	"mime/multipart",
	"mime/quotedprintable",
	"net",
	"net/http",
	"net/http/cgi",
	"net/http/cookiejar",
	"net/http/fcgi",
	"net/http/httptest",
	"net/http/httptrace",
	"net/http/httputil",
	"net/http/pprof",
	"net/mail",
	"net/rpc",
	"net/rpc/jsonrpc",
	"net/smtp",
	"net/textproto",
	"net/url",
	"os",
	"os/exec",
	"os/signal",
	"os/user",
	"path",
	"path/filepath",
	"reflect",
	"regexp",
	"regexp/syntax",
	"runtime",
	"runtime/debug",
	"runtime/metrics",
	"runtime/pprof",
	"runtime/trace",
	"sort",
	"strconv",
	"strings",
	"sync",
	"sync/atomic",
	"text/scanner",
	"text/tabwriter",
	"text/template",
	"text/template/parse",
	"time",
	"time/tzdata",
	"unicode",
	"unicode/utf16",
	"unicode/utf8",
}
`)
	sources["packages.go"] = []byte(`// Code generated by scriggo command. DO NOT EDIT.
//+build darwin,go1.16,!go1.17

package main

import (
	tar "archive/tar"
	zip "archive/zip"
	"bufio"
	"bytes"
	bzip2 "compress/bzip2"
	flate "compress/flate"
	gzip "compress/gzip"
	lzw "compress/lzw"
	zlib "compress/zlib"
	heap "container/heap"
	list "container/list"
	ring "container/ring"
	"context"
	"crypto"
	aes "crypto/aes"
	cipher "crypto/cipher"
	des "crypto/des"
	dsa "crypto/dsa"
	ecdsa "crypto/ecdsa"
	elliptic "crypto/elliptic"
	hmac "crypto/hmac"
	md5 "crypto/md5"
	rand "crypto/rand"
	rc4 "crypto/rc4"
	rsa "crypto/rsa"
	sha1 "crypto/sha1"
	sha256 "crypto/sha256"
	sha512 "crypto/sha512"
	subtle "crypto/subtle"
	tls "crypto/tls"
	x509 "crypto/x509"
	pkix "crypto/x509/pkix"
	dwarf "debug/dwarf"
	elf "debug/elf"
	gosym "debug/gosym"
	macho "debug/macho"
	pe "debug/pe"
	plan9obj "debug/plan9obj"
	"encoding"
	ascii85 "encoding/ascii85"
	asn1 "encoding/asn1"
	base32 "encoding/base32"
	base64 "encoding/base64"
	binary "encoding/binary"
	csv "encoding/csv"
	gob "encoding/gob"
	hex "encoding/hex"
	json "encoding/json"
	pem "encoding/pem"
	xml "encoding/xml"
	"errors"
	"expvar"
	"flag"
	"fmt"
	ast "go/ast"
	build "go/build"
	constant "go/constant"
	doc "go/doc"
	format "go/format"
	importer "go/importer"
	parser "go/parser"
	printer "go/printer"
	scanner "go/scanner"
	token "go/token"
	types "go/types"
	"hash"
	adler32 "hash/adler32"
	crc32 "hash/crc32"
	crc64 "hash/crc64"
	fnv "hash/fnv"
	maphash "hash/maphash"
	"html"
	template "html/template"
	"image"
	color "image/color"
	palette "image/color/palette"
	draw "image/draw"
	gif "image/gif"
	jpeg "image/jpeg"
	png "image/png"
	suffixarray "index/suffixarray"
	"io"
	fs "io/fs"
	ioutil "io/ioutil"
	"log"
	syslog "log/syslog"
	"math"
	big "math/big"
	bits "math/bits"
	cmplx "math/cmplx"
	rand_ "math/rand"
	"mime"
	multipart "mime/multipart"
	quotedprintable "mime/quotedprintable"
	"net"
	http "net/http"
	cgi "net/http/cgi"
	cookiejar "net/http/cookiejar"
	fcgi "net/http/fcgi"
	httptest "net/http/httptest"
	httptrace "net/http/httptrace"
	httputil "net/http/httputil"
	pprof "net/http/pprof"
	mail "net/mail"
	rpc "net/rpc"
	jsonrpc "net/rpc/jsonrpc"
	smtp "net/smtp"
	textproto "net/textproto"
	url "net/url"
	"os"
	exec "os/exec"
	signal "os/signal"
	user "os/user"
	"path"
	filepath "path/filepath"
	"reflect"
	"regexp"
	syntax "regexp/syntax"
	"runtime"
	debug "runtime/debug"
	metrics "runtime/metrics"
	pprof_ "runtime/pprof"
	trace "runtime/trace"
	"sort"
	"strconv"
	"strings"
	"sync"
	atomic "sync/atomic"
	scanner_ "text/scanner"
	tabwriter "text/tabwriter"
	template_ "text/template"
	parse "text/template/parse"
	"time"
	_ "time/tzdata"
	"unicode"
	utf16 "unicode/utf16"
	utf8 "unicode/utf8"
)

import . "github.com/open2b/scriggo"


func init() {
	packages = make(Packages, 137)
	var decs map[string]interface{}
	// "archive/tar"
	decs = make(map[string]interface{}, 29)
	decs["ErrFieldTooLong"] = &tar.ErrFieldTooLong
	decs["ErrHeader"] = &tar.ErrHeader
	decs["ErrWriteAfterClose"] = &tar.ErrWriteAfterClose
	decs["ErrWriteTooLong"] = &tar.ErrWriteTooLong
	decs["FileInfoHeader"] = tar.FileInfoHeader
	decs["Format"] = reflect.TypeOf((*tar.Format)(nil)).Elem()
	decs["FormatGNU"] = tar.FormatGNU
	decs["FormatPAX"] = tar.FormatPAX
	decs["FormatUSTAR"] = tar.FormatUSTAR
	decs["FormatUnknown"] = tar.FormatUnknown
	decs["Header"] = reflect.TypeOf((*tar.Header)(nil)).Elem()
	decs["NewReader"] = tar.NewReader
	decs["NewWriter"] = tar.NewWriter
	decs["Reader"] = reflect.TypeOf((*tar.Reader)(nil)).Elem()
	decs["TypeBlock"] = UntypedNumericConst("52")
	decs["TypeChar"] = UntypedNumericConst("51")
	decs["TypeCont"] = UntypedNumericConst("55")
	decs["TypeDir"] = UntypedNumericConst("53")
	decs["TypeFifo"] = UntypedNumericConst("54")
	decs["TypeGNULongLink"] = UntypedNumericConst("75")
	decs["TypeGNULongName"] = UntypedNumericConst("76")
	decs["TypeGNUSparse"] = UntypedNumericConst("83")
	decs["TypeLink"] = UntypedNumericConst("49")
	decs["TypeReg"] = UntypedNumericConst("48")
	decs["TypeRegA"] = UntypedNumericConst("0")
	decs["TypeSymlink"] = UntypedNumericConst("50")
	decs["TypeXGlobalHeader"] = UntypedNumericConst("103")
	decs["TypeXHeader"] = UntypedNumericConst("120")
	decs["Writer"] = reflect.TypeOf((*tar.Writer)(nil)).Elem()
	packages["archive/tar"] = &MapPackage{
		PkgName: "tar",
		Declarations: decs,
	}
	// "archive/zip"
	decs = make(map[string]interface{}, 18)
	decs["Compressor"] = reflect.TypeOf((*zip.Compressor)(nil)).Elem()
	decs["Decompressor"] = reflect.TypeOf((*zip.Decompressor)(nil)).Elem()
	decs["Deflate"] = zip.Deflate
	decs["ErrAlgorithm"] = &zip.ErrAlgorithm
	decs["ErrChecksum"] = &zip.ErrChecksum
	decs["ErrFormat"] = &zip.ErrFormat
	decs["File"] = reflect.TypeOf((*zip.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*zip.FileHeader)(nil)).Elem()
	decs["FileInfoHeader"] = zip.FileInfoHeader
	decs["NewReader"] = zip.NewReader
	decs["NewWriter"] = zip.NewWriter
	decs["OpenReader"] = zip.OpenReader
	decs["ReadCloser"] = reflect.TypeOf((*zip.ReadCloser)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*zip.Reader)(nil)).Elem()
	decs["RegisterCompressor"] = zip.RegisterCompressor
	decs["RegisterDecompressor"] = zip.RegisterDecompressor
	decs["Store"] = zip.Store
	decs["Writer"] = reflect.TypeOf((*zip.Writer)(nil)).Elem()
	packages["archive/zip"] = &MapPackage{
		PkgName: "zip",
		Declarations: decs,
	}
	// "bufio"
	decs = make(map[string]interface{}, 25)
	decs["ErrAdvanceTooFar"] = &bufio.ErrAdvanceTooFar
	decs["ErrBadReadCount"] = &bufio.ErrBadReadCount
	decs["ErrBufferFull"] = &bufio.ErrBufferFull
	decs["ErrFinalToken"] = &bufio.ErrFinalToken
	decs["ErrInvalidUnreadByte"] = &bufio.ErrInvalidUnreadByte
	decs["ErrInvalidUnreadRune"] = &bufio.ErrInvalidUnreadRune
	decs["ErrNegativeAdvance"] = &bufio.ErrNegativeAdvance
	decs["ErrNegativeCount"] = &bufio.ErrNegativeCount
	decs["ErrTooLong"] = &bufio.ErrTooLong
	decs["MaxScanTokenSize"] = UntypedNumericConst("65536")
	decs["NewReadWriter"] = bufio.NewReadWriter
	decs["NewReader"] = bufio.NewReader
	decs["NewReaderSize"] = bufio.NewReaderSize
	decs["NewScanner"] = bufio.NewScanner
	decs["NewWriter"] = bufio.NewWriter
	decs["NewWriterSize"] = bufio.NewWriterSize
	decs["ReadWriter"] = reflect.TypeOf((*bufio.ReadWriter)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*bufio.Reader)(nil)).Elem()
	decs["ScanBytes"] = bufio.ScanBytes
	decs["ScanLines"] = bufio.ScanLines
	decs["ScanRunes"] = bufio.ScanRunes
	decs["ScanWords"] = bufio.ScanWords
	decs["Scanner"] = reflect.TypeOf((*bufio.Scanner)(nil)).Elem()
	decs["SplitFunc"] = reflect.TypeOf((*bufio.SplitFunc)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*bufio.Writer)(nil)).Elem()
	packages["bufio"] = &MapPackage{
		PkgName: "bufio",
		Declarations: decs,
	}
	// "bytes"
	decs = make(map[string]interface{}, 54)
	decs["Buffer"] = reflect.TypeOf((*bytes.Buffer)(nil)).Elem()
	decs["Compare"] = bytes.Compare
	decs["Contains"] = bytes.Contains
	decs["ContainsAny"] = bytes.ContainsAny
	decs["ContainsRune"] = bytes.ContainsRune
	decs["Count"] = bytes.Count
	decs["Equal"] = bytes.Equal
	decs["EqualFold"] = bytes.EqualFold
	decs["ErrTooLarge"] = &bytes.ErrTooLarge
	decs["Fields"] = bytes.Fields
	decs["FieldsFunc"] = bytes.FieldsFunc
	decs["HasPrefix"] = bytes.HasPrefix
	decs["HasSuffix"] = bytes.HasSuffix
	decs["Index"] = bytes.Index
	decs["IndexAny"] = bytes.IndexAny
	decs["IndexByte"] = bytes.IndexByte
	decs["IndexFunc"] = bytes.IndexFunc
	decs["IndexRune"] = bytes.IndexRune
	decs["Join"] = bytes.Join
	decs["LastIndex"] = bytes.LastIndex
	decs["LastIndexAny"] = bytes.LastIndexAny
	decs["LastIndexByte"] = bytes.LastIndexByte
	decs["LastIndexFunc"] = bytes.LastIndexFunc
	decs["Map"] = bytes.Map
	decs["MinRead"] = UntypedNumericConst("512")
	decs["NewBuffer"] = bytes.NewBuffer
	decs["NewBufferString"] = bytes.NewBufferString
	decs["NewReader"] = bytes.NewReader
	decs["Reader"] = reflect.TypeOf((*bytes.Reader)(nil)).Elem()
	decs["Repeat"] = bytes.Repeat
	decs["Replace"] = bytes.Replace
	decs["ReplaceAll"] = bytes.ReplaceAll
	decs["Runes"] = bytes.Runes
	decs["Split"] = bytes.Split
	decs["SplitAfter"] = bytes.SplitAfter
	decs["SplitAfterN"] = bytes.SplitAfterN
	decs["SplitN"] = bytes.SplitN
	decs["Title"] = bytes.Title
	decs["ToLower"] = bytes.ToLower
	decs["ToLowerSpecial"] = bytes.ToLowerSpecial
	decs["ToTitle"] = bytes.ToTitle
	decs["ToTitleSpecial"] = bytes.ToTitleSpecial
	decs["ToUpper"] = bytes.ToUpper
	decs["ToUpperSpecial"] = bytes.ToUpperSpecial
	decs["ToValidUTF8"] = bytes.ToValidUTF8
	decs["Trim"] = bytes.Trim
	decs["TrimFunc"] = bytes.TrimFunc
	decs["TrimLeft"] = bytes.TrimLeft
	decs["TrimLeftFunc"] = bytes.TrimLeftFunc
	decs["TrimPrefix"] = bytes.TrimPrefix
	decs["TrimRight"] = bytes.TrimRight
	decs["TrimRightFunc"] = bytes.TrimRightFunc
	decs["TrimSpace"] = bytes.TrimSpace
	decs["TrimSuffix"] = bytes.TrimSuffix
	packages["bytes"] = &MapPackage{
		PkgName: "bytes",
		Declarations: decs,
	}
	// "compress/bzip2"
	decs = make(map[string]interface{}, 2)
	decs["NewReader"] = bzip2.NewReader
	decs["StructuralError"] = reflect.TypeOf((*bzip2.StructuralError)(nil)).Elem()
	packages["compress/bzip2"] = &MapPackage{
		PkgName: "bzip2",
		Declarations: decs,
	}
	// "compress/flate"
	decs = make(map[string]interface{}, 16)
	decs["BestCompression"] = UntypedNumericConst("9")
	decs["BestSpeed"] = UntypedNumericConst("1")
	decs["CorruptInputError"] = reflect.TypeOf((*flate.CorruptInputError)(nil)).Elem()
	decs["DefaultCompression"] = UntypedNumericConst("-1")
	decs["HuffmanOnly"] = UntypedNumericConst("-2")
	decs["InternalError"] = reflect.TypeOf((*flate.InternalError)(nil)).Elem()
	decs["NewReader"] = flate.NewReader
	decs["NewReaderDict"] = flate.NewReaderDict
	decs["NewWriter"] = flate.NewWriter
	decs["NewWriterDict"] = flate.NewWriterDict
	decs["NoCompression"] = UntypedNumericConst("0")
	decs["ReadError"] = reflect.TypeOf((*flate.ReadError)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*flate.Reader)(nil)).Elem()
	decs["Resetter"] = reflect.TypeOf((*flate.Resetter)(nil)).Elem()
	decs["WriteError"] = reflect.TypeOf((*flate.WriteError)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*flate.Writer)(nil)).Elem()
	packages["compress/flate"] = &MapPackage{
		PkgName: "flate",
		Declarations: decs,
	}
	// "compress/gzip"
	decs = make(map[string]interface{}, 13)
	decs["BestCompression"] = UntypedNumericConst("9")
	decs["BestSpeed"] = UntypedNumericConst("1")
	decs["DefaultCompression"] = UntypedNumericConst("-1")
	decs["ErrChecksum"] = &gzip.ErrChecksum
	decs["ErrHeader"] = &gzip.ErrHeader
	decs["Header"] = reflect.TypeOf((*gzip.Header)(nil)).Elem()
	decs["HuffmanOnly"] = UntypedNumericConst("-2")
	decs["NewReader"] = gzip.NewReader
	decs["NewWriter"] = gzip.NewWriter
	decs["NewWriterLevel"] = gzip.NewWriterLevel
	decs["NoCompression"] = UntypedNumericConst("0")
	decs["Reader"] = reflect.TypeOf((*gzip.Reader)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*gzip.Writer)(nil)).Elem()
	packages["compress/gzip"] = &MapPackage{
		PkgName: "gzip",
		Declarations: decs,
	}
	// "compress/lzw"
	decs = make(map[string]interface{}, 5)
	decs["LSB"] = lzw.LSB
	decs["MSB"] = lzw.MSB
	decs["NewReader"] = lzw.NewReader
	decs["NewWriter"] = lzw.NewWriter
	decs["Order"] = reflect.TypeOf((*lzw.Order)(nil)).Elem()
	packages["compress/lzw"] = &MapPackage{
		PkgName: "lzw",
		Declarations: decs,
	}
	// "compress/zlib"
	decs = make(map[string]interface{}, 15)
	decs["BestCompression"] = UntypedNumericConst("9")
	decs["BestSpeed"] = UntypedNumericConst("1")
	decs["DefaultCompression"] = UntypedNumericConst("-1")
	decs["ErrChecksum"] = &zlib.ErrChecksum
	decs["ErrDictionary"] = &zlib.ErrDictionary
	decs["ErrHeader"] = &zlib.ErrHeader
	decs["HuffmanOnly"] = UntypedNumericConst("-2")
	decs["NewReader"] = zlib.NewReader
	decs["NewReaderDict"] = zlib.NewReaderDict
	decs["NewWriter"] = zlib.NewWriter
	decs["NewWriterLevel"] = zlib.NewWriterLevel
	decs["NewWriterLevelDict"] = zlib.NewWriterLevelDict
	decs["NoCompression"] = UntypedNumericConst("0")
	decs["Resetter"] = reflect.TypeOf((*zlib.Resetter)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*zlib.Writer)(nil)).Elem()
	packages["compress/zlib"] = &MapPackage{
		PkgName: "zlib",
		Declarations: decs,
	}
	// "container/heap"
	decs = make(map[string]interface{}, 6)
	decs["Fix"] = heap.Fix
	decs["Init"] = heap.Init
	decs["Interface"] = reflect.TypeOf((*heap.Interface)(nil)).Elem()
	decs["Pop"] = heap.Pop
	decs["Push"] = heap.Push
	decs["Remove"] = heap.Remove
	packages["container/heap"] = &MapPackage{
		PkgName: "heap",
		Declarations: decs,
	}
	// "container/list"
	decs = make(map[string]interface{}, 3)
	decs["Element"] = reflect.TypeOf((*list.Element)(nil)).Elem()
	decs["List"] = reflect.TypeOf((*list.List)(nil)).Elem()
	decs["New"] = list.New
	packages["container/list"] = &MapPackage{
		PkgName: "list",
		Declarations: decs,
	}
	// "container/ring"
	decs = make(map[string]interface{}, 2)
	decs["New"] = ring.New
	decs["Ring"] = reflect.TypeOf((*ring.Ring)(nil)).Elem()
	packages["container/ring"] = &MapPackage{
		PkgName: "ring",
		Declarations: decs,
	}
	// "context"
	decs = make(map[string]interface{}, 10)
	decs["Background"] = context.Background
	decs["CancelFunc"] = reflect.TypeOf((*context.CancelFunc)(nil)).Elem()
	decs["Canceled"] = &context.Canceled
	decs["Context"] = reflect.TypeOf((*context.Context)(nil)).Elem()
	decs["DeadlineExceeded"] = &context.DeadlineExceeded
	decs["TODO"] = context.TODO
	decs["WithCancel"] = context.WithCancel
	decs["WithDeadline"] = context.WithDeadline
	decs["WithTimeout"] = context.WithTimeout
	decs["WithValue"] = context.WithValue
	packages["context"] = &MapPackage{
		PkgName: "context",
		Declarations: decs,
	}
	// "crypto"
	decs = make(map[string]interface{}, 27)
	decs["BLAKE2b_256"] = crypto.BLAKE2b_256
	decs["BLAKE2b_384"] = crypto.BLAKE2b_384
	decs["BLAKE2b_512"] = crypto.BLAKE2b_512
	decs["BLAKE2s_256"] = crypto.BLAKE2s_256
	decs["Decrypter"] = reflect.TypeOf((*crypto.Decrypter)(nil)).Elem()
	decs["DecrypterOpts"] = reflect.TypeOf((*crypto.DecrypterOpts)(nil)).Elem()
	decs["Hash"] = reflect.TypeOf((*crypto.Hash)(nil)).Elem()
	decs["MD4"] = crypto.MD4
	decs["MD5"] = crypto.MD5
	decs["MD5SHA1"] = crypto.MD5SHA1
	decs["PrivateKey"] = reflect.TypeOf((*crypto.PrivateKey)(nil)).Elem()
	decs["PublicKey"] = reflect.TypeOf((*crypto.PublicKey)(nil)).Elem()
	decs["RIPEMD160"] = crypto.RIPEMD160
	decs["RegisterHash"] = crypto.RegisterHash
	decs["SHA1"] = crypto.SHA1
	decs["SHA224"] = crypto.SHA224
	decs["SHA256"] = crypto.SHA256
	decs["SHA384"] = crypto.SHA384
	decs["SHA3_224"] = crypto.SHA3_224
	decs["SHA3_256"] = crypto.SHA3_256
	decs["SHA3_384"] = crypto.SHA3_384
	decs["SHA3_512"] = crypto.SHA3_512
	decs["SHA512"] = crypto.SHA512
	decs["SHA512_224"] = crypto.SHA512_224
	decs["SHA512_256"] = crypto.SHA512_256
	decs["Signer"] = reflect.TypeOf((*crypto.Signer)(nil)).Elem()
	decs["SignerOpts"] = reflect.TypeOf((*crypto.SignerOpts)(nil)).Elem()
	packages["crypto"] = &MapPackage{
		PkgName: "crypto",
		Declarations: decs,
	}
	// "crypto/aes"
	decs = make(map[string]interface{}, 3)
	decs["BlockSize"] = UntypedNumericConst("16")
	decs["KeySizeError"] = reflect.TypeOf((*aes.KeySizeError)(nil)).Elem()
	decs["NewCipher"] = aes.NewCipher
	packages["crypto/aes"] = &MapPackage{
		PkgName: "aes",
		Declarations: decs,
	}
	// "crypto/cipher"
	decs = make(map[string]interface{}, 15)
	decs["AEAD"] = reflect.TypeOf((*cipher.AEAD)(nil)).Elem()
	decs["Block"] = reflect.TypeOf((*cipher.Block)(nil)).Elem()
	decs["BlockMode"] = reflect.TypeOf((*cipher.BlockMode)(nil)).Elem()
	decs["NewCBCDecrypter"] = cipher.NewCBCDecrypter
	decs["NewCBCEncrypter"] = cipher.NewCBCEncrypter
	decs["NewCFBDecrypter"] = cipher.NewCFBDecrypter
	decs["NewCFBEncrypter"] = cipher.NewCFBEncrypter
	decs["NewCTR"] = cipher.NewCTR
	decs["NewGCM"] = cipher.NewGCM
	decs["NewGCMWithNonceSize"] = cipher.NewGCMWithNonceSize
	decs["NewGCMWithTagSize"] = cipher.NewGCMWithTagSize
	decs["NewOFB"] = cipher.NewOFB
	decs["Stream"] = reflect.TypeOf((*cipher.Stream)(nil)).Elem()
	decs["StreamReader"] = reflect.TypeOf((*cipher.StreamReader)(nil)).Elem()
	decs["StreamWriter"] = reflect.TypeOf((*cipher.StreamWriter)(nil)).Elem()
	packages["crypto/cipher"] = &MapPackage{
		PkgName: "cipher",
		Declarations: decs,
	}
	// "crypto/des"
	decs = make(map[string]interface{}, 4)
	decs["BlockSize"] = UntypedNumericConst("8")
	decs["KeySizeError"] = reflect.TypeOf((*des.KeySizeError)(nil)).Elem()
	decs["NewCipher"] = des.NewCipher
	decs["NewTripleDESCipher"] = des.NewTripleDESCipher
	packages["crypto/des"] = &MapPackage{
		PkgName: "des",
		Declarations: decs,
	}
	// "crypto/dsa"
	decs = make(map[string]interface{}, 13)
	decs["ErrInvalidPublicKey"] = &dsa.ErrInvalidPublicKey
	decs["GenerateKey"] = dsa.GenerateKey
	decs["GenerateParameters"] = dsa.GenerateParameters
	decs["L1024N160"] = dsa.L1024N160
	decs["L2048N224"] = dsa.L2048N224
	decs["L2048N256"] = dsa.L2048N256
	decs["L3072N256"] = dsa.L3072N256
	decs["ParameterSizes"] = reflect.TypeOf((*dsa.ParameterSizes)(nil)).Elem()
	decs["Parameters"] = reflect.TypeOf((*dsa.Parameters)(nil)).Elem()
	decs["PrivateKey"] = reflect.TypeOf((*dsa.PrivateKey)(nil)).Elem()
	decs["PublicKey"] = reflect.TypeOf((*dsa.PublicKey)(nil)).Elem()
	decs["Sign"] = dsa.Sign
	decs["Verify"] = dsa.Verify
	packages["crypto/dsa"] = &MapPackage{
		PkgName: "dsa",
		Declarations: decs,
	}
	// "crypto/ecdsa"
	decs = make(map[string]interface{}, 7)
	decs["GenerateKey"] = ecdsa.GenerateKey
	decs["PrivateKey"] = reflect.TypeOf((*ecdsa.PrivateKey)(nil)).Elem()
	decs["PublicKey"] = reflect.TypeOf((*ecdsa.PublicKey)(nil)).Elem()
	decs["Sign"] = ecdsa.Sign
	decs["SignASN1"] = ecdsa.SignASN1
	decs["Verify"] = ecdsa.Verify
	decs["VerifyASN1"] = ecdsa.VerifyASN1
	packages["crypto/ecdsa"] = &MapPackage{
		PkgName: "ecdsa",
		Declarations: decs,
	}
	// "crypto/elliptic"
	decs = make(map[string]interface{}, 11)
	decs["Curve"] = reflect.TypeOf((*elliptic.Curve)(nil)).Elem()
	decs["CurveParams"] = reflect.TypeOf((*elliptic.CurveParams)(nil)).Elem()
	decs["GenerateKey"] = elliptic.GenerateKey
	decs["Marshal"] = elliptic.Marshal
	decs["MarshalCompressed"] = elliptic.MarshalCompressed
	decs["P224"] = elliptic.P224
	decs["P256"] = elliptic.P256
	decs["P384"] = elliptic.P384
	decs["P521"] = elliptic.P521
	decs["Unmarshal"] = elliptic.Unmarshal
	decs["UnmarshalCompressed"] = elliptic.UnmarshalCompressed
	packages["crypto/elliptic"] = &MapPackage{
		PkgName: "elliptic",
		Declarations: decs,
	}
	// "crypto/hmac"
	decs = make(map[string]interface{}, 2)
	decs["Equal"] = hmac.Equal
	decs["New"] = hmac.New
	packages["crypto/hmac"] = &MapPackage{
		PkgName: "hmac",
		Declarations: decs,
	}
	// "crypto/md5"
	decs = make(map[string]interface{}, 4)
	decs["BlockSize"] = UntypedNumericConst("64")
	decs["New"] = md5.New
	decs["Size"] = UntypedNumericConst("16")
	decs["Sum"] = md5.Sum
	packages["crypto/md5"] = &MapPackage{
		PkgName: "md5",
		Declarations: decs,
	}
	// "crypto/rand"
	decs = make(map[string]interface{}, 4)
	decs["Int"] = rand.Int
	decs["Prime"] = rand.Prime
	decs["Read"] = rand.Read
	decs["Reader"] = &rand.Reader
	packages["crypto/rand"] = &MapPackage{
		PkgName: "rand",
		Declarations: decs,
	}
	// "crypto/rc4"
	decs = make(map[string]interface{}, 3)
	decs["Cipher"] = reflect.TypeOf((*rc4.Cipher)(nil)).Elem()
	decs["KeySizeError"] = reflect.TypeOf((*rc4.KeySizeError)(nil)).Elem()
	decs["NewCipher"] = rc4.NewCipher
	packages["crypto/rc4"] = &MapPackage{
		PkgName: "rc4",
		Declarations: decs,
	}
	// "crypto/rsa"
	decs = make(map[string]interface{}, 23)
	decs["CRTValue"] = reflect.TypeOf((*rsa.CRTValue)(nil)).Elem()
	decs["DecryptOAEP"] = rsa.DecryptOAEP
	decs["DecryptPKCS1v15"] = rsa.DecryptPKCS1v15
	decs["DecryptPKCS1v15SessionKey"] = rsa.DecryptPKCS1v15SessionKey
	decs["EncryptOAEP"] = rsa.EncryptOAEP
	decs["EncryptPKCS1v15"] = rsa.EncryptPKCS1v15
	decs["ErrDecryption"] = &rsa.ErrDecryption
	decs["ErrMessageTooLong"] = &rsa.ErrMessageTooLong
	decs["ErrVerification"] = &rsa.ErrVerification
	decs["GenerateKey"] = rsa.GenerateKey
	decs["GenerateMultiPrimeKey"] = rsa.GenerateMultiPrimeKey
	decs["OAEPOptions"] = reflect.TypeOf((*rsa.OAEPOptions)(nil)).Elem()
	decs["PKCS1v15DecryptOptions"] = reflect.TypeOf((*rsa.PKCS1v15DecryptOptions)(nil)).Elem()
	decs["PSSOptions"] = reflect.TypeOf((*rsa.PSSOptions)(nil)).Elem()
	decs["PSSSaltLengthAuto"] = UntypedNumericConst("0")
	decs["PSSSaltLengthEqualsHash"] = UntypedNumericConst("-1")
	decs["PrecomputedValues"] = reflect.TypeOf((*rsa.PrecomputedValues)(nil)).Elem()
	decs["PrivateKey"] = reflect.TypeOf((*rsa.PrivateKey)(nil)).Elem()
	decs["PublicKey"] = reflect.TypeOf((*rsa.PublicKey)(nil)).Elem()
	decs["SignPKCS1v15"] = rsa.SignPKCS1v15
	decs["SignPSS"] = rsa.SignPSS
	decs["VerifyPKCS1v15"] = rsa.VerifyPKCS1v15
	decs["VerifyPSS"] = rsa.VerifyPSS
	packages["crypto/rsa"] = &MapPackage{
		PkgName: "rsa",
		Declarations: decs,
	}
	// "crypto/sha1"
	decs = make(map[string]interface{}, 4)
	decs["BlockSize"] = UntypedNumericConst("64")
	decs["New"] = sha1.New
	decs["Size"] = UntypedNumericConst("20")
	decs["Sum"] = sha1.Sum
	packages["crypto/sha1"] = &MapPackage{
		PkgName: "sha1",
		Declarations: decs,
	}
	// "crypto/sha256"
	decs = make(map[string]interface{}, 7)
	decs["BlockSize"] = UntypedNumericConst("64")
	decs["New"] = sha256.New
	decs["New224"] = sha256.New224
	decs["Size"] = UntypedNumericConst("32")
	decs["Size224"] = UntypedNumericConst("28")
	decs["Sum224"] = sha256.Sum224
	decs["Sum256"] = sha256.Sum256
	packages["crypto/sha256"] = &MapPackage{
		PkgName: "sha256",
		Declarations: decs,
	}
	// "crypto/sha512"
	decs = make(map[string]interface{}, 13)
	decs["BlockSize"] = UntypedNumericConst("128")
	decs["New"] = sha512.New
	decs["New384"] = sha512.New384
	decs["New512_224"] = sha512.New512_224
	decs["New512_256"] = sha512.New512_256
	decs["Size"] = UntypedNumericConst("64")
	decs["Size224"] = UntypedNumericConst("28")
	decs["Size256"] = UntypedNumericConst("32")
	decs["Size384"] = UntypedNumericConst("48")
	decs["Sum384"] = sha512.Sum384
	decs["Sum512"] = sha512.Sum512
	decs["Sum512_224"] = sha512.Sum512_224
	decs["Sum512_256"] = sha512.Sum512_256
	packages["crypto/sha512"] = &MapPackage{
		PkgName: "sha512",
		Declarations: decs,
	}
	// "crypto/subtle"
	decs = make(map[string]interface{}, 6)
	decs["ConstantTimeByteEq"] = subtle.ConstantTimeByteEq
	decs["ConstantTimeCompare"] = subtle.ConstantTimeCompare
	decs["ConstantTimeCopy"] = subtle.ConstantTimeCopy
	decs["ConstantTimeEq"] = subtle.ConstantTimeEq
	decs["ConstantTimeLessOrEq"] = subtle.ConstantTimeLessOrEq
	decs["ConstantTimeSelect"] = subtle.ConstantTimeSelect
	packages["crypto/subtle"] = &MapPackage{
		PkgName: "subtle",
		Declarations: decs,
	}
	// "crypto/tls"
	decs = make(map[string]interface{}, 84)
	decs["Certificate"] = reflect.TypeOf((*tls.Certificate)(nil)).Elem()
	decs["CertificateRequestInfo"] = reflect.TypeOf((*tls.CertificateRequestInfo)(nil)).Elem()
	decs["CipherSuite"] = reflect.TypeOf((*tls.CipherSuite)(nil)).Elem()
	decs["CipherSuiteName"] = tls.CipherSuiteName
	decs["CipherSuites"] = tls.CipherSuites
	decs["Client"] = tls.Client
	decs["ClientAuthType"] = reflect.TypeOf((*tls.ClientAuthType)(nil)).Elem()
	decs["ClientHelloInfo"] = reflect.TypeOf((*tls.ClientHelloInfo)(nil)).Elem()
	decs["ClientSessionCache"] = reflect.TypeOf((*tls.ClientSessionCache)(nil)).Elem()
	decs["ClientSessionState"] = reflect.TypeOf((*tls.ClientSessionState)(nil)).Elem()
	decs["Config"] = reflect.TypeOf((*tls.Config)(nil)).Elem()
	decs["Conn"] = reflect.TypeOf((*tls.Conn)(nil)).Elem()
	decs["ConnectionState"] = reflect.TypeOf((*tls.ConnectionState)(nil)).Elem()
	decs["CurveID"] = reflect.TypeOf((*tls.CurveID)(nil)).Elem()
	decs["CurveP256"] = tls.CurveP256
	decs["CurveP384"] = tls.CurveP384
	decs["CurveP521"] = tls.CurveP521
	decs["Dial"] = tls.Dial
	decs["DialWithDialer"] = tls.DialWithDialer
	decs["Dialer"] = reflect.TypeOf((*tls.Dialer)(nil)).Elem()
	decs["ECDSAWithP256AndSHA256"] = tls.ECDSAWithP256AndSHA256
	decs["ECDSAWithP384AndSHA384"] = tls.ECDSAWithP384AndSHA384
	decs["ECDSAWithP521AndSHA512"] = tls.ECDSAWithP521AndSHA512
	decs["ECDSAWithSHA1"] = tls.ECDSAWithSHA1
	decs["Ed25519"] = tls.Ed25519
	decs["InsecureCipherSuites"] = tls.InsecureCipherSuites
	decs["Listen"] = tls.Listen
	decs["LoadX509KeyPair"] = tls.LoadX509KeyPair
	decs["NewLRUClientSessionCache"] = tls.NewLRUClientSessionCache
	decs["NewListener"] = tls.NewListener
	decs["NoClientCert"] = tls.NoClientCert
	decs["PKCS1WithSHA1"] = tls.PKCS1WithSHA1
	decs["PKCS1WithSHA256"] = tls.PKCS1WithSHA256
	decs["PKCS1WithSHA384"] = tls.PKCS1WithSHA384
	decs["PKCS1WithSHA512"] = tls.PKCS1WithSHA512
	decs["PSSWithSHA256"] = tls.PSSWithSHA256
	decs["PSSWithSHA384"] = tls.PSSWithSHA384
	decs["PSSWithSHA512"] = tls.PSSWithSHA512
	decs["RecordHeaderError"] = reflect.TypeOf((*tls.RecordHeaderError)(nil)).Elem()
	decs["RenegotiateFreelyAsClient"] = tls.RenegotiateFreelyAsClient
	decs["RenegotiateNever"] = tls.RenegotiateNever
	decs["RenegotiateOnceAsClient"] = tls.RenegotiateOnceAsClient
	decs["RenegotiationSupport"] = reflect.TypeOf((*tls.RenegotiationSupport)(nil)).Elem()
	decs["RequestClientCert"] = tls.RequestClientCert
	decs["RequireAndVerifyClientCert"] = tls.RequireAndVerifyClientCert
	decs["RequireAnyClientCert"] = tls.RequireAnyClientCert
	decs["Server"] = tls.Server
	decs["SignatureScheme"] = reflect.TypeOf((*tls.SignatureScheme)(nil)).Elem()
	decs["TLS_AES_128_GCM_SHA256"] = tls.TLS_AES_128_GCM_SHA256
	decs["TLS_AES_256_GCM_SHA384"] = tls.TLS_AES_256_GCM_SHA384
	decs["TLS_CHACHA20_POLY1305_SHA256"] = tls.TLS_CHACHA20_POLY1305_SHA256
	decs["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"] = tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	decs["TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"] = tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
	decs["TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"] = tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	decs["TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"] = tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
	decs["TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"] = tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	decs["TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305"] = tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305
	decs["TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"] = tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
	decs["TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"] = tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
	decs["TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"] = tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
	decs["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"] = tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	decs["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"] = tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
	decs["TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"] = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	decs["TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"] = tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
	decs["TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"] = tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	decs["TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305"] = tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305
	decs["TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"] = tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
	decs["TLS_ECDHE_RSA_WITH_RC4_128_SHA"] = tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA
	decs["TLS_FALLBACK_SCSV"] = tls.TLS_FALLBACK_SCSV
	decs["TLS_RSA_WITH_3DES_EDE_CBC_SHA"] = tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA
	decs["TLS_RSA_WITH_AES_128_CBC_SHA"] = tls.TLS_RSA_WITH_AES_128_CBC_SHA
	decs["TLS_RSA_WITH_AES_128_CBC_SHA256"] = tls.TLS_RSA_WITH_AES_128_CBC_SHA256
	decs["TLS_RSA_WITH_AES_128_GCM_SHA256"] = tls.TLS_RSA_WITH_AES_128_GCM_SHA256
	decs["TLS_RSA_WITH_AES_256_CBC_SHA"] = tls.TLS_RSA_WITH_AES_256_CBC_SHA
	decs["TLS_RSA_WITH_AES_256_GCM_SHA384"] = tls.TLS_RSA_WITH_AES_256_GCM_SHA384
	decs["TLS_RSA_WITH_RC4_128_SHA"] = tls.TLS_RSA_WITH_RC4_128_SHA
	decs["VerifyClientCertIfGiven"] = tls.VerifyClientCertIfGiven
	decs["VersionSSL30"] = UntypedNumericConst("768")
	decs["VersionTLS10"] = UntypedNumericConst("769")
	decs["VersionTLS11"] = UntypedNumericConst("770")
	decs["VersionTLS12"] = UntypedNumericConst("771")
	decs["VersionTLS13"] = UntypedNumericConst("772")
	decs["X25519"] = tls.X25519
	decs["X509KeyPair"] = tls.X509KeyPair
	packages["crypto/tls"] = &MapPackage{
		PkgName: "tls",
		Declarations: decs,
	}
	// "crypto/x509"
	decs = make(map[string]interface{}, 103)
	decs["CANotAuthorizedForExtKeyUsage"] = x509.CANotAuthorizedForExtKeyUsage
	decs["CANotAuthorizedForThisName"] = x509.CANotAuthorizedForThisName
	decs["CertPool"] = reflect.TypeOf((*x509.CertPool)(nil)).Elem()
	decs["Certificate"] = reflect.TypeOf((*x509.Certificate)(nil)).Elem()
	decs["CertificateInvalidError"] = reflect.TypeOf((*x509.CertificateInvalidError)(nil)).Elem()
	decs["CertificateRequest"] = reflect.TypeOf((*x509.CertificateRequest)(nil)).Elem()
	decs["ConstraintViolationError"] = reflect.TypeOf((*x509.ConstraintViolationError)(nil)).Elem()
	decs["CreateCertificate"] = x509.CreateCertificate
	decs["CreateCertificateRequest"] = x509.CreateCertificateRequest
	decs["CreateRevocationList"] = x509.CreateRevocationList
	decs["DSA"] = x509.DSA
	decs["DSAWithSHA1"] = x509.DSAWithSHA1
	decs["DSAWithSHA256"] = x509.DSAWithSHA256
	decs["DecryptPEMBlock"] = x509.DecryptPEMBlock
	decs["ECDSA"] = x509.ECDSA
	decs["ECDSAWithSHA1"] = x509.ECDSAWithSHA1
	decs["ECDSAWithSHA256"] = x509.ECDSAWithSHA256
	decs["ECDSAWithSHA384"] = x509.ECDSAWithSHA384
	decs["ECDSAWithSHA512"] = x509.ECDSAWithSHA512
	decs["Ed25519"] = x509.Ed25519
	decs["EncryptPEMBlock"] = x509.EncryptPEMBlock
	decs["ErrUnsupportedAlgorithm"] = &x509.ErrUnsupportedAlgorithm
	decs["Expired"] = x509.Expired
	decs["ExtKeyUsage"] = reflect.TypeOf((*x509.ExtKeyUsage)(nil)).Elem()
	decs["ExtKeyUsageAny"] = x509.ExtKeyUsageAny
	decs["ExtKeyUsageClientAuth"] = x509.ExtKeyUsageClientAuth
	decs["ExtKeyUsageCodeSigning"] = x509.ExtKeyUsageCodeSigning
	decs["ExtKeyUsageEmailProtection"] = x509.ExtKeyUsageEmailProtection
	decs["ExtKeyUsageIPSECEndSystem"] = x509.ExtKeyUsageIPSECEndSystem
	decs["ExtKeyUsageIPSECTunnel"] = x509.ExtKeyUsageIPSECTunnel
	decs["ExtKeyUsageIPSECUser"] = x509.ExtKeyUsageIPSECUser
	decs["ExtKeyUsageMicrosoftCommercialCodeSigning"] = x509.ExtKeyUsageMicrosoftCommercialCodeSigning
	decs["ExtKeyUsageMicrosoftKernelCodeSigning"] = x509.ExtKeyUsageMicrosoftKernelCodeSigning
	decs["ExtKeyUsageMicrosoftServerGatedCrypto"] = x509.ExtKeyUsageMicrosoftServerGatedCrypto
	decs["ExtKeyUsageNetscapeServerGatedCrypto"] = x509.ExtKeyUsageNetscapeServerGatedCrypto
	decs["ExtKeyUsageOCSPSigning"] = x509.ExtKeyUsageOCSPSigning
	decs["ExtKeyUsageServerAuth"] = x509.ExtKeyUsageServerAuth
	decs["ExtKeyUsageTimeStamping"] = x509.ExtKeyUsageTimeStamping
	decs["HostnameError"] = reflect.TypeOf((*x509.HostnameError)(nil)).Elem()
	decs["IncompatibleUsage"] = x509.IncompatibleUsage
	decs["IncorrectPasswordError"] = &x509.IncorrectPasswordError
	decs["InsecureAlgorithmError"] = reflect.TypeOf((*x509.InsecureAlgorithmError)(nil)).Elem()
	decs["InvalidReason"] = reflect.TypeOf((*x509.InvalidReason)(nil)).Elem()
	decs["IsEncryptedPEMBlock"] = x509.IsEncryptedPEMBlock
	decs["KeyUsage"] = reflect.TypeOf((*x509.KeyUsage)(nil)).Elem()
	decs["KeyUsageCRLSign"] = x509.KeyUsageCRLSign
	decs["KeyUsageCertSign"] = x509.KeyUsageCertSign
	decs["KeyUsageContentCommitment"] = x509.KeyUsageContentCommitment
	decs["KeyUsageDataEncipherment"] = x509.KeyUsageDataEncipherment
	decs["KeyUsageDecipherOnly"] = x509.KeyUsageDecipherOnly
	decs["KeyUsageDigitalSignature"] = x509.KeyUsageDigitalSignature
	decs["KeyUsageEncipherOnly"] = x509.KeyUsageEncipherOnly
	decs["KeyUsageKeyAgreement"] = x509.KeyUsageKeyAgreement
	decs["KeyUsageKeyEncipherment"] = x509.KeyUsageKeyEncipherment
	decs["MD2WithRSA"] = x509.MD2WithRSA
	decs["MD5WithRSA"] = x509.MD5WithRSA
	decs["MarshalECPrivateKey"] = x509.MarshalECPrivateKey
	decs["MarshalPKCS1PrivateKey"] = x509.MarshalPKCS1PrivateKey
	decs["MarshalPKCS1PublicKey"] = x509.MarshalPKCS1PublicKey
	decs["MarshalPKCS8PrivateKey"] = x509.MarshalPKCS8PrivateKey
	decs["MarshalPKIXPublicKey"] = x509.MarshalPKIXPublicKey
	decs["NameConstraintsWithoutSANs"] = x509.NameConstraintsWithoutSANs
	decs["NameMismatch"] = x509.NameMismatch
	decs["NewCertPool"] = x509.NewCertPool
	decs["NotAuthorizedToSign"] = x509.NotAuthorizedToSign
	decs["PEMCipher"] = reflect.TypeOf((*x509.PEMCipher)(nil)).Elem()
	decs["PEMCipher3DES"] = x509.PEMCipher3DES
	decs["PEMCipherAES128"] = x509.PEMCipherAES128
	decs["PEMCipherAES192"] = x509.PEMCipherAES192
	decs["PEMCipherAES256"] = x509.PEMCipherAES256
	decs["PEMCipherDES"] = x509.PEMCipherDES
	decs["ParseCRL"] = x509.ParseCRL
	decs["ParseCertificate"] = x509.ParseCertificate
	decs["ParseCertificateRequest"] = x509.ParseCertificateRequest
	decs["ParseCertificates"] = x509.ParseCertificates
	decs["ParseDERCRL"] = x509.ParseDERCRL
	decs["ParseECPrivateKey"] = x509.ParseECPrivateKey
	decs["ParsePKCS1PrivateKey"] = x509.ParsePKCS1PrivateKey
	decs["ParsePKCS1PublicKey"] = x509.ParsePKCS1PublicKey
	decs["ParsePKCS8PrivateKey"] = x509.ParsePKCS8PrivateKey
	decs["ParsePKIXPublicKey"] = x509.ParsePKIXPublicKey
	decs["PublicKeyAlgorithm"] = reflect.TypeOf((*x509.PublicKeyAlgorithm)(nil)).Elem()
	decs["PureEd25519"] = x509.PureEd25519
	decs["RSA"] = x509.RSA
	decs["RevocationList"] = reflect.TypeOf((*x509.RevocationList)(nil)).Elem()
	decs["SHA1WithRSA"] = x509.SHA1WithRSA
	decs["SHA256WithRSA"] = x509.SHA256WithRSA
	decs["SHA256WithRSAPSS"] = x509.SHA256WithRSAPSS
	decs["SHA384WithRSA"] = x509.SHA384WithRSA
	decs["SHA384WithRSAPSS"] = x509.SHA384WithRSAPSS
	decs["SHA512WithRSA"] = x509.SHA512WithRSA
	decs["SHA512WithRSAPSS"] = x509.SHA512WithRSAPSS
	decs["SignatureAlgorithm"] = reflect.TypeOf((*x509.SignatureAlgorithm)(nil)).Elem()
	decs["SystemCertPool"] = x509.SystemCertPool
	decs["SystemRootsError"] = reflect.TypeOf((*x509.SystemRootsError)(nil)).Elem()
	decs["TooManyConstraints"] = x509.TooManyConstraints
	decs["TooManyIntermediates"] = x509.TooManyIntermediates
	decs["UnconstrainedName"] = x509.UnconstrainedName
	decs["UnhandledCriticalExtension"] = reflect.TypeOf((*x509.UnhandledCriticalExtension)(nil)).Elem()
	decs["UnknownAuthorityError"] = reflect.TypeOf((*x509.UnknownAuthorityError)(nil)).Elem()
	decs["UnknownPublicKeyAlgorithm"] = x509.UnknownPublicKeyAlgorithm
	decs["UnknownSignatureAlgorithm"] = x509.UnknownSignatureAlgorithm
	decs["VerifyOptions"] = reflect.TypeOf((*x509.VerifyOptions)(nil)).Elem()
	packages["crypto/x509"] = &MapPackage{
		PkgName: "x509",
		Declarations: decs,
	}
	// "crypto/x509/pkix"
	decs = make(map[string]interface{}, 10)
	decs["AlgorithmIdentifier"] = reflect.TypeOf((*pkix.AlgorithmIdentifier)(nil)).Elem()
	decs["AttributeTypeAndValue"] = reflect.TypeOf((*pkix.AttributeTypeAndValue)(nil)).Elem()
	decs["AttributeTypeAndValueSET"] = reflect.TypeOf((*pkix.AttributeTypeAndValueSET)(nil)).Elem()
	decs["CertificateList"] = reflect.TypeOf((*pkix.CertificateList)(nil)).Elem()
	decs["Extension"] = reflect.TypeOf((*pkix.Extension)(nil)).Elem()
	decs["Name"] = reflect.TypeOf((*pkix.Name)(nil)).Elem()
	decs["RDNSequence"] = reflect.TypeOf((*pkix.RDNSequence)(nil)).Elem()
	decs["RelativeDistinguishedNameSET"] = reflect.TypeOf((*pkix.RelativeDistinguishedNameSET)(nil)).Elem()
	decs["RevokedCertificate"] = reflect.TypeOf((*pkix.RevokedCertificate)(nil)).Elem()
	decs["TBSCertificateList"] = reflect.TypeOf((*pkix.TBSCertificateList)(nil)).Elem()
	packages["crypto/x509/pkix"] = &MapPackage{
		PkgName: "pkix",
		Declarations: decs,
	}
	// "debug/dwarf"
	decs = make(map[string]interface{}, 249)
	decs["AddrType"] = reflect.TypeOf((*dwarf.AddrType)(nil)).Elem()
	decs["ArrayType"] = reflect.TypeOf((*dwarf.ArrayType)(nil)).Elem()
	decs["Attr"] = reflect.TypeOf((*dwarf.Attr)(nil)).Elem()
	decs["AttrAbstractOrigin"] = dwarf.AttrAbstractOrigin
	decs["AttrAccessibility"] = dwarf.AttrAccessibility
	decs["AttrAddrBase"] = dwarf.AttrAddrBase
	decs["AttrAddrClass"] = dwarf.AttrAddrClass
	decs["AttrAlignment"] = dwarf.AttrAlignment
	decs["AttrAllocated"] = dwarf.AttrAllocated
	decs["AttrArtificial"] = dwarf.AttrArtificial
	decs["AttrAssociated"] = dwarf.AttrAssociated
	decs["AttrBaseTypes"] = dwarf.AttrBaseTypes
	decs["AttrBinaryScale"] = dwarf.AttrBinaryScale
	decs["AttrBitOffset"] = dwarf.AttrBitOffset
	decs["AttrBitSize"] = dwarf.AttrBitSize
	decs["AttrByteSize"] = dwarf.AttrByteSize
	decs["AttrCallAllCalls"] = dwarf.AttrCallAllCalls
	decs["AttrCallAllSourceCalls"] = dwarf.AttrCallAllSourceCalls
	decs["AttrCallAllTailCalls"] = dwarf.AttrCallAllTailCalls
	decs["AttrCallColumn"] = dwarf.AttrCallColumn
	decs["AttrCallDataLocation"] = dwarf.AttrCallDataLocation
	decs["AttrCallDataValue"] = dwarf.AttrCallDataValue
	decs["AttrCallFile"] = dwarf.AttrCallFile
	decs["AttrCallLine"] = dwarf.AttrCallLine
	decs["AttrCallOrigin"] = dwarf.AttrCallOrigin
	decs["AttrCallPC"] = dwarf.AttrCallPC
	decs["AttrCallParameter"] = dwarf.AttrCallParameter
	decs["AttrCallReturnPC"] = dwarf.AttrCallReturnPC
	decs["AttrCallTailCall"] = dwarf.AttrCallTailCall
	decs["AttrCallTarget"] = dwarf.AttrCallTarget
	decs["AttrCallTargetClobbered"] = dwarf.AttrCallTargetClobbered
	decs["AttrCallValue"] = dwarf.AttrCallValue
	decs["AttrCalling"] = dwarf.AttrCalling
	decs["AttrCommonRef"] = dwarf.AttrCommonRef
	decs["AttrCompDir"] = dwarf.AttrCompDir
	decs["AttrConstExpr"] = dwarf.AttrConstExpr
	decs["AttrConstValue"] = dwarf.AttrConstValue
	decs["AttrContainingType"] = dwarf.AttrContainingType
	decs["AttrCount"] = dwarf.AttrCount
	decs["AttrDataBitOffset"] = dwarf.AttrDataBitOffset
	decs["AttrDataLocation"] = dwarf.AttrDataLocation
	decs["AttrDataMemberLoc"] = dwarf.AttrDataMemberLoc
	decs["AttrDecimalScale"] = dwarf.AttrDecimalScale
	decs["AttrDecimalSign"] = dwarf.AttrDecimalSign
	decs["AttrDeclColumn"] = dwarf.AttrDeclColumn
	decs["AttrDeclFile"] = dwarf.AttrDeclFile
	decs["AttrDeclLine"] = dwarf.AttrDeclLine
	decs["AttrDeclaration"] = dwarf.AttrDeclaration
	decs["AttrDefaultValue"] = dwarf.AttrDefaultValue
	decs["AttrDefaulted"] = dwarf.AttrDefaulted
	decs["AttrDeleted"] = dwarf.AttrDeleted
	decs["AttrDescription"] = dwarf.AttrDescription
	decs["AttrDigitCount"] = dwarf.AttrDigitCount
	decs["AttrDiscr"] = dwarf.AttrDiscr
	decs["AttrDiscrList"] = dwarf.AttrDiscrList
	decs["AttrDiscrValue"] = dwarf.AttrDiscrValue
	decs["AttrDwoName"] = dwarf.AttrDwoName
	decs["AttrElemental"] = dwarf.AttrElemental
	decs["AttrEncoding"] = dwarf.AttrEncoding
	decs["AttrEndianity"] = dwarf.AttrEndianity
	decs["AttrEntrypc"] = dwarf.AttrEntrypc
	decs["AttrEnumClass"] = dwarf.AttrEnumClass
	decs["AttrExplicit"] = dwarf.AttrExplicit
	decs["AttrExportSymbols"] = dwarf.AttrExportSymbols
	decs["AttrExtension"] = dwarf.AttrExtension
	decs["AttrExternal"] = dwarf.AttrExternal
	decs["AttrFrameBase"] = dwarf.AttrFrameBase
	decs["AttrFriend"] = dwarf.AttrFriend
	decs["AttrHighpc"] = dwarf.AttrHighpc
	decs["AttrIdentifierCase"] = dwarf.AttrIdentifierCase
	decs["AttrImport"] = dwarf.AttrImport
	decs["AttrInline"] = dwarf.AttrInline
	decs["AttrIsOptional"] = dwarf.AttrIsOptional
	decs["AttrLanguage"] = dwarf.AttrLanguage
	decs["AttrLinkageName"] = dwarf.AttrLinkageName
	decs["AttrLocation"] = dwarf.AttrLocation
	decs["AttrLoclistsBase"] = dwarf.AttrLoclistsBase
	decs["AttrLowerBound"] = dwarf.AttrLowerBound
	decs["AttrLowpc"] = dwarf.AttrLowpc
	decs["AttrMacroInfo"] = dwarf.AttrMacroInfo
	decs["AttrMacros"] = dwarf.AttrMacros
	decs["AttrMainSubprogram"] = dwarf.AttrMainSubprogram
	decs["AttrMutable"] = dwarf.AttrMutable
	decs["AttrName"] = dwarf.AttrName
	decs["AttrNamelistItem"] = dwarf.AttrNamelistItem
	decs["AttrNoreturn"] = dwarf.AttrNoreturn
	decs["AttrObjectPointer"] = dwarf.AttrObjectPointer
	decs["AttrOrdering"] = dwarf.AttrOrdering
	decs["AttrPictureString"] = dwarf.AttrPictureString
	decs["AttrPriority"] = dwarf.AttrPriority
	decs["AttrProducer"] = dwarf.AttrProducer
	decs["AttrPrototyped"] = dwarf.AttrPrototyped
	decs["AttrPure"] = dwarf.AttrPure
	decs["AttrRanges"] = dwarf.AttrRanges
	decs["AttrRank"] = dwarf.AttrRank
	decs["AttrRecursive"] = dwarf.AttrRecursive
	decs["AttrReference"] = dwarf.AttrReference
	decs["AttrReturnAddr"] = dwarf.AttrReturnAddr
	decs["AttrRnglistsBase"] = dwarf.AttrRnglistsBase
	decs["AttrRvalueReference"] = dwarf.AttrRvalueReference
	decs["AttrSegment"] = dwarf.AttrSegment
	decs["AttrSibling"] = dwarf.AttrSibling
	decs["AttrSignature"] = dwarf.AttrSignature
	decs["AttrSmall"] = dwarf.AttrSmall
	decs["AttrSpecification"] = dwarf.AttrSpecification
	decs["AttrStartScope"] = dwarf.AttrStartScope
	decs["AttrStaticLink"] = dwarf.AttrStaticLink
	decs["AttrStmtList"] = dwarf.AttrStmtList
	decs["AttrStrOffsetsBase"] = dwarf.AttrStrOffsetsBase
	decs["AttrStride"] = dwarf.AttrStride
	decs["AttrStrideSize"] = dwarf.AttrStrideSize
	decs["AttrStringLength"] = dwarf.AttrStringLength
	decs["AttrStringLengthBitSize"] = dwarf.AttrStringLengthBitSize
	decs["AttrStringLengthByteSize"] = dwarf.AttrStringLengthByteSize
	decs["AttrThreadsScaled"] = dwarf.AttrThreadsScaled
	decs["AttrTrampoline"] = dwarf.AttrTrampoline
	decs["AttrType"] = dwarf.AttrType
	decs["AttrUpperBound"] = dwarf.AttrUpperBound
	decs["AttrUseLocation"] = dwarf.AttrUseLocation
	decs["AttrUseUTF8"] = dwarf.AttrUseUTF8
	decs["AttrVarParam"] = dwarf.AttrVarParam
	decs["AttrVirtuality"] = dwarf.AttrVirtuality
	decs["AttrVisibility"] = dwarf.AttrVisibility
	decs["AttrVtableElemLoc"] = dwarf.AttrVtableElemLoc
	decs["BasicType"] = reflect.TypeOf((*dwarf.BasicType)(nil)).Elem()
	decs["BoolType"] = reflect.TypeOf((*dwarf.BoolType)(nil)).Elem()
	decs["CharType"] = reflect.TypeOf((*dwarf.CharType)(nil)).Elem()
	decs["Class"] = reflect.TypeOf((*dwarf.Class)(nil)).Elem()
	decs["ClassAddrPtr"] = dwarf.ClassAddrPtr
	decs["ClassAddress"] = dwarf.ClassAddress
	decs["ClassBlock"] = dwarf.ClassBlock
	decs["ClassConstant"] = dwarf.ClassConstant
	decs["ClassExprLoc"] = dwarf.ClassExprLoc
	decs["ClassFlag"] = dwarf.ClassFlag
	decs["ClassLinePtr"] = dwarf.ClassLinePtr
	decs["ClassLocList"] = dwarf.ClassLocList
	decs["ClassLocListPtr"] = dwarf.ClassLocListPtr
	decs["ClassMacPtr"] = dwarf.ClassMacPtr
	decs["ClassRangeListPtr"] = dwarf.ClassRangeListPtr
	decs["ClassReference"] = dwarf.ClassReference
	decs["ClassReferenceAlt"] = dwarf.ClassReferenceAlt
	decs["ClassReferenceSig"] = dwarf.ClassReferenceSig
	decs["ClassRngList"] = dwarf.ClassRngList
	decs["ClassRngListsPtr"] = dwarf.ClassRngListsPtr
	decs["ClassStrOffsetsPtr"] = dwarf.ClassStrOffsetsPtr
	decs["ClassString"] = dwarf.ClassString
	decs["ClassStringAlt"] = dwarf.ClassStringAlt
	decs["ClassUnknown"] = dwarf.ClassUnknown
	decs["CommonType"] = reflect.TypeOf((*dwarf.CommonType)(nil)).Elem()
	decs["ComplexType"] = reflect.TypeOf((*dwarf.ComplexType)(nil)).Elem()
	decs["Data"] = reflect.TypeOf((*dwarf.Data)(nil)).Elem()
	decs["DecodeError"] = reflect.TypeOf((*dwarf.DecodeError)(nil)).Elem()
	decs["DotDotDotType"] = reflect.TypeOf((*dwarf.DotDotDotType)(nil)).Elem()
	decs["Entry"] = reflect.TypeOf((*dwarf.Entry)(nil)).Elem()
	decs["EnumType"] = reflect.TypeOf((*dwarf.EnumType)(nil)).Elem()
	decs["EnumValue"] = reflect.TypeOf((*dwarf.EnumValue)(nil)).Elem()
	decs["ErrUnknownPC"] = &dwarf.ErrUnknownPC
	decs["Field"] = reflect.TypeOf((*dwarf.Field)(nil)).Elem()
	decs["FloatType"] = reflect.TypeOf((*dwarf.FloatType)(nil)).Elem()
	decs["FuncType"] = reflect.TypeOf((*dwarf.FuncType)(nil)).Elem()
	decs["IntType"] = reflect.TypeOf((*dwarf.IntType)(nil)).Elem()
	decs["LineEntry"] = reflect.TypeOf((*dwarf.LineEntry)(nil)).Elem()
	decs["LineFile"] = reflect.TypeOf((*dwarf.LineFile)(nil)).Elem()
	decs["LineReader"] = reflect.TypeOf((*dwarf.LineReader)(nil)).Elem()
	decs["LineReaderPos"] = reflect.TypeOf((*dwarf.LineReaderPos)(nil)).Elem()
	decs["New"] = dwarf.New
	decs["Offset"] = reflect.TypeOf((*dwarf.Offset)(nil)).Elem()
	decs["PtrType"] = reflect.TypeOf((*dwarf.PtrType)(nil)).Elem()
	decs["QualType"] = reflect.TypeOf((*dwarf.QualType)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*dwarf.Reader)(nil)).Elem()
	decs["StructField"] = reflect.TypeOf((*dwarf.StructField)(nil)).Elem()
	decs["StructType"] = reflect.TypeOf((*dwarf.StructType)(nil)).Elem()
	decs["Tag"] = reflect.TypeOf((*dwarf.Tag)(nil)).Elem()
	decs["TagAccessDeclaration"] = dwarf.TagAccessDeclaration
	decs["TagArrayType"] = dwarf.TagArrayType
	decs["TagAtomicType"] = dwarf.TagAtomicType
	decs["TagBaseType"] = dwarf.TagBaseType
	decs["TagCallSite"] = dwarf.TagCallSite
	decs["TagCallSiteParameter"] = dwarf.TagCallSiteParameter
	decs["TagCatchDwarfBlock"] = dwarf.TagCatchDwarfBlock
	decs["TagClassType"] = dwarf.TagClassType
	decs["TagCoarrayType"] = dwarf.TagCoarrayType
	decs["TagCommonDwarfBlock"] = dwarf.TagCommonDwarfBlock
	decs["TagCommonInclusion"] = dwarf.TagCommonInclusion
	decs["TagCompileUnit"] = dwarf.TagCompileUnit
	decs["TagCondition"] = dwarf.TagCondition
	decs["TagConstType"] = dwarf.TagConstType
	decs["TagConstant"] = dwarf.TagConstant
	decs["TagDwarfProcedure"] = dwarf.TagDwarfProcedure
	decs["TagDynamicType"] = dwarf.TagDynamicType
	decs["TagEntryPoint"] = dwarf.TagEntryPoint
	decs["TagEnumerationType"] = dwarf.TagEnumerationType
	decs["TagEnumerator"] = dwarf.TagEnumerator
	decs["TagFileType"] = dwarf.TagFileType
	decs["TagFormalParameter"] = dwarf.TagFormalParameter
	decs["TagFriend"] = dwarf.TagFriend
	decs["TagGenericSubrange"] = dwarf.TagGenericSubrange
	decs["TagImmutableType"] = dwarf.TagImmutableType
	decs["TagImportedDeclaration"] = dwarf.TagImportedDeclaration
	decs["TagImportedModule"] = dwarf.TagImportedModule
	decs["TagImportedUnit"] = dwarf.TagImportedUnit
	decs["TagInheritance"] = dwarf.TagInheritance
	decs["TagInlinedSubroutine"] = dwarf.TagInlinedSubroutine
	decs["TagInterfaceType"] = dwarf.TagInterfaceType
	decs["TagLabel"] = dwarf.TagLabel
	decs["TagLexDwarfBlock"] = dwarf.TagLexDwarfBlock
	decs["TagMember"] = dwarf.TagMember
	decs["TagModule"] = dwarf.TagModule
	decs["TagMutableType"] = dwarf.TagMutableType
	decs["TagNamelist"] = dwarf.TagNamelist
	decs["TagNamelistItem"] = dwarf.TagNamelistItem
	decs["TagNamespace"] = dwarf.TagNamespace
	decs["TagPackedType"] = dwarf.TagPackedType
	decs["TagPartialUnit"] = dwarf.TagPartialUnit
	decs["TagPointerType"] = dwarf.TagPointerType
	decs["TagPtrToMemberType"] = dwarf.TagPtrToMemberType
	decs["TagReferenceType"] = dwarf.TagReferenceType
	decs["TagRestrictType"] = dwarf.TagRestrictType
	decs["TagRvalueReferenceType"] = dwarf.TagRvalueReferenceType
	decs["TagSetType"] = dwarf.TagSetType
	decs["TagSharedType"] = dwarf.TagSharedType
	decs["TagSkeletonUnit"] = dwarf.TagSkeletonUnit
	decs["TagStringType"] = dwarf.TagStringType
	decs["TagStructType"] = dwarf.TagStructType
	decs["TagSubprogram"] = dwarf.TagSubprogram
	decs["TagSubrangeType"] = dwarf.TagSubrangeType
	decs["TagSubroutineType"] = dwarf.TagSubroutineType
	decs["TagTemplateAlias"] = dwarf.TagTemplateAlias
	decs["TagTemplateTypeParameter"] = dwarf.TagTemplateTypeParameter
	decs["TagTemplateValueParameter"] = dwarf.TagTemplateValueParameter
	decs["TagThrownType"] = dwarf.TagThrownType
	decs["TagTryDwarfBlock"] = dwarf.TagTryDwarfBlock
	decs["TagTypeUnit"] = dwarf.TagTypeUnit
	decs["TagTypedef"] = dwarf.TagTypedef
	decs["TagUnionType"] = dwarf.TagUnionType
	decs["TagUnspecifiedParameters"] = dwarf.TagUnspecifiedParameters
	decs["TagUnspecifiedType"] = dwarf.TagUnspecifiedType
	decs["TagVariable"] = dwarf.TagVariable
	decs["TagVariant"] = dwarf.TagVariant
	decs["TagVariantPart"] = dwarf.TagVariantPart
	decs["TagVolatileType"] = dwarf.TagVolatileType
	decs["TagWithStmt"] = dwarf.TagWithStmt
	decs["Type"] = reflect.TypeOf((*dwarf.Type)(nil)).Elem()
	decs["TypedefType"] = reflect.TypeOf((*dwarf.TypedefType)(nil)).Elem()
	decs["UcharType"] = reflect.TypeOf((*dwarf.UcharType)(nil)).Elem()
	decs["UintType"] = reflect.TypeOf((*dwarf.UintType)(nil)).Elem()
	decs["UnspecifiedType"] = reflect.TypeOf((*dwarf.UnspecifiedType)(nil)).Elem()
	decs["UnsupportedType"] = reflect.TypeOf((*dwarf.UnsupportedType)(nil)).Elem()
	decs["VoidType"] = reflect.TypeOf((*dwarf.VoidType)(nil)).Elem()
	packages["debug/dwarf"] = &MapPackage{
		PkgName: "dwarf",
		Declarations: decs,
	}
	// "debug/elf"
	decs = make(map[string]interface{}, 1343)
	decs["ARM_MAGIC_TRAMP_NUMBER"] = UntypedNumericConst("1543503875")
	decs["COMPRESS_HIOS"] = elf.COMPRESS_HIOS
	decs["COMPRESS_HIPROC"] = elf.COMPRESS_HIPROC
	decs["COMPRESS_LOOS"] = elf.COMPRESS_LOOS
	decs["COMPRESS_LOPROC"] = elf.COMPRESS_LOPROC
	decs["COMPRESS_ZLIB"] = elf.COMPRESS_ZLIB
	decs["Chdr32"] = reflect.TypeOf((*elf.Chdr32)(nil)).Elem()
	decs["Chdr64"] = reflect.TypeOf((*elf.Chdr64)(nil)).Elem()
	decs["Class"] = reflect.TypeOf((*elf.Class)(nil)).Elem()
	decs["CompressionType"] = reflect.TypeOf((*elf.CompressionType)(nil)).Elem()
	decs["DF_BIND_NOW"] = elf.DF_BIND_NOW
	decs["DF_ORIGIN"] = elf.DF_ORIGIN
	decs["DF_STATIC_TLS"] = elf.DF_STATIC_TLS
	decs["DF_SYMBOLIC"] = elf.DF_SYMBOLIC
	decs["DF_TEXTREL"] = elf.DF_TEXTREL
	decs["DT_ADDRRNGHI"] = elf.DT_ADDRRNGHI
	decs["DT_ADDRRNGLO"] = elf.DT_ADDRRNGLO
	decs["DT_AUDIT"] = elf.DT_AUDIT
	decs["DT_AUXILIARY"] = elf.DT_AUXILIARY
	decs["DT_BIND_NOW"] = elf.DT_BIND_NOW
	decs["DT_CHECKSUM"] = elf.DT_CHECKSUM
	decs["DT_CONFIG"] = elf.DT_CONFIG
	decs["DT_DEBUG"] = elf.DT_DEBUG
	decs["DT_DEPAUDIT"] = elf.DT_DEPAUDIT
	decs["DT_ENCODING"] = elf.DT_ENCODING
	decs["DT_FEATURE"] = elf.DT_FEATURE
	decs["DT_FILTER"] = elf.DT_FILTER
	decs["DT_FINI"] = elf.DT_FINI
	decs["DT_FINI_ARRAY"] = elf.DT_FINI_ARRAY
	decs["DT_FINI_ARRAYSZ"] = elf.DT_FINI_ARRAYSZ
	decs["DT_FLAGS"] = elf.DT_FLAGS
	decs["DT_FLAGS_1"] = elf.DT_FLAGS_1
	decs["DT_GNU_CONFLICT"] = elf.DT_GNU_CONFLICT
	decs["DT_GNU_CONFLICTSZ"] = elf.DT_GNU_CONFLICTSZ
	decs["DT_GNU_HASH"] = elf.DT_GNU_HASH
	decs["DT_GNU_LIBLIST"] = elf.DT_GNU_LIBLIST
	decs["DT_GNU_LIBLISTSZ"] = elf.DT_GNU_LIBLISTSZ
	decs["DT_GNU_PRELINKED"] = elf.DT_GNU_PRELINKED
	decs["DT_HASH"] = elf.DT_HASH
	decs["DT_HIOS"] = elf.DT_HIOS
	decs["DT_HIPROC"] = elf.DT_HIPROC
	decs["DT_INIT"] = elf.DT_INIT
	decs["DT_INIT_ARRAY"] = elf.DT_INIT_ARRAY
	decs["DT_INIT_ARRAYSZ"] = elf.DT_INIT_ARRAYSZ
	decs["DT_JMPREL"] = elf.DT_JMPREL
	decs["DT_LOOS"] = elf.DT_LOOS
	decs["DT_LOPROC"] = elf.DT_LOPROC
	decs["DT_MIPS_AUX_DYNAMIC"] = elf.DT_MIPS_AUX_DYNAMIC
	decs["DT_MIPS_BASE_ADDRESS"] = elf.DT_MIPS_BASE_ADDRESS
	decs["DT_MIPS_COMPACT_SIZE"] = elf.DT_MIPS_COMPACT_SIZE
	decs["DT_MIPS_CONFLICT"] = elf.DT_MIPS_CONFLICT
	decs["DT_MIPS_CONFLICTNO"] = elf.DT_MIPS_CONFLICTNO
	decs["DT_MIPS_CXX_FLAGS"] = elf.DT_MIPS_CXX_FLAGS
	decs["DT_MIPS_DELTA_CLASS"] = elf.DT_MIPS_DELTA_CLASS
	decs["DT_MIPS_DELTA_CLASSSYM"] = elf.DT_MIPS_DELTA_CLASSSYM
	decs["DT_MIPS_DELTA_CLASSSYM_NO"] = elf.DT_MIPS_DELTA_CLASSSYM_NO
	decs["DT_MIPS_DELTA_CLASS_NO"] = elf.DT_MIPS_DELTA_CLASS_NO
	decs["DT_MIPS_DELTA_INSTANCE"] = elf.DT_MIPS_DELTA_INSTANCE
	decs["DT_MIPS_DELTA_INSTANCE_NO"] = elf.DT_MIPS_DELTA_INSTANCE_NO
	decs["DT_MIPS_DELTA_RELOC"] = elf.DT_MIPS_DELTA_RELOC
	decs["DT_MIPS_DELTA_RELOC_NO"] = elf.DT_MIPS_DELTA_RELOC_NO
	decs["DT_MIPS_DELTA_SYM"] = elf.DT_MIPS_DELTA_SYM
	decs["DT_MIPS_DELTA_SYM_NO"] = elf.DT_MIPS_DELTA_SYM_NO
	decs["DT_MIPS_DYNSTR_ALIGN"] = elf.DT_MIPS_DYNSTR_ALIGN
	decs["DT_MIPS_FLAGS"] = elf.DT_MIPS_FLAGS
	decs["DT_MIPS_GOTSYM"] = elf.DT_MIPS_GOTSYM
	decs["DT_MIPS_GP_VALUE"] = elf.DT_MIPS_GP_VALUE
	decs["DT_MIPS_HIDDEN_GOTIDX"] = elf.DT_MIPS_HIDDEN_GOTIDX
	decs["DT_MIPS_HIPAGENO"] = elf.DT_MIPS_HIPAGENO
	decs["DT_MIPS_ICHECKSUM"] = elf.DT_MIPS_ICHECKSUM
	decs["DT_MIPS_INTERFACE"] = elf.DT_MIPS_INTERFACE
	decs["DT_MIPS_INTERFACE_SIZE"] = elf.DT_MIPS_INTERFACE_SIZE
	decs["DT_MIPS_IVERSION"] = elf.DT_MIPS_IVERSION
	decs["DT_MIPS_LIBLIST"] = elf.DT_MIPS_LIBLIST
	decs["DT_MIPS_LIBLISTNO"] = elf.DT_MIPS_LIBLISTNO
	decs["DT_MIPS_LOCALPAGE_GOTIDX"] = elf.DT_MIPS_LOCALPAGE_GOTIDX
	decs["DT_MIPS_LOCAL_GOTIDX"] = elf.DT_MIPS_LOCAL_GOTIDX
	decs["DT_MIPS_LOCAL_GOTNO"] = elf.DT_MIPS_LOCAL_GOTNO
	decs["DT_MIPS_MSYM"] = elf.DT_MIPS_MSYM
	decs["DT_MIPS_OPTIONS"] = elf.DT_MIPS_OPTIONS
	decs["DT_MIPS_PERF_SUFFIX"] = elf.DT_MIPS_PERF_SUFFIX
	decs["DT_MIPS_PIXIE_INIT"] = elf.DT_MIPS_PIXIE_INIT
	decs["DT_MIPS_PLTGOT"] = elf.DT_MIPS_PLTGOT
	decs["DT_MIPS_PROTECTED_GOTIDX"] = elf.DT_MIPS_PROTECTED_GOTIDX
	decs["DT_MIPS_RLD_MAP"] = elf.DT_MIPS_RLD_MAP
	decs["DT_MIPS_RLD_MAP_REL"] = elf.DT_MIPS_RLD_MAP_REL
	decs["DT_MIPS_RLD_TEXT_RESOLVE_ADDR"] = elf.DT_MIPS_RLD_TEXT_RESOLVE_ADDR
	decs["DT_MIPS_RLD_VERSION"] = elf.DT_MIPS_RLD_VERSION
	decs["DT_MIPS_RWPLT"] = elf.DT_MIPS_RWPLT
	decs["DT_MIPS_SYMBOL_LIB"] = elf.DT_MIPS_SYMBOL_LIB
	decs["DT_MIPS_SYMTABNO"] = elf.DT_MIPS_SYMTABNO
	decs["DT_MIPS_TIME_STAMP"] = elf.DT_MIPS_TIME_STAMP
	decs["DT_MIPS_UNREFEXTNO"] = elf.DT_MIPS_UNREFEXTNO
	decs["DT_MOVEENT"] = elf.DT_MOVEENT
	decs["DT_MOVESZ"] = elf.DT_MOVESZ
	decs["DT_MOVETAB"] = elf.DT_MOVETAB
	decs["DT_NEEDED"] = elf.DT_NEEDED
	decs["DT_NULL"] = elf.DT_NULL
	decs["DT_PLTGOT"] = elf.DT_PLTGOT
	decs["DT_PLTPAD"] = elf.DT_PLTPAD
	decs["DT_PLTPADSZ"] = elf.DT_PLTPADSZ
	decs["DT_PLTREL"] = elf.DT_PLTREL
	decs["DT_PLTRELSZ"] = elf.DT_PLTRELSZ
	decs["DT_POSFLAG_1"] = elf.DT_POSFLAG_1
	decs["DT_PPC64_GLINK"] = elf.DT_PPC64_GLINK
	decs["DT_PPC64_OPD"] = elf.DT_PPC64_OPD
	decs["DT_PPC64_OPDSZ"] = elf.DT_PPC64_OPDSZ
	decs["DT_PPC64_OPT"] = elf.DT_PPC64_OPT
	decs["DT_PPC_GOT"] = elf.DT_PPC_GOT
	decs["DT_PPC_OPT"] = elf.DT_PPC_OPT
	decs["DT_PREINIT_ARRAY"] = elf.DT_PREINIT_ARRAY
	decs["DT_PREINIT_ARRAYSZ"] = elf.DT_PREINIT_ARRAYSZ
	decs["DT_REL"] = elf.DT_REL
	decs["DT_RELA"] = elf.DT_RELA
	decs["DT_RELACOUNT"] = elf.DT_RELACOUNT
	decs["DT_RELAENT"] = elf.DT_RELAENT
	decs["DT_RELASZ"] = elf.DT_RELASZ
	decs["DT_RELCOUNT"] = elf.DT_RELCOUNT
	decs["DT_RELENT"] = elf.DT_RELENT
	decs["DT_RELSZ"] = elf.DT_RELSZ
	decs["DT_RPATH"] = elf.DT_RPATH
	decs["DT_RUNPATH"] = elf.DT_RUNPATH
	decs["DT_SONAME"] = elf.DT_SONAME
	decs["DT_SPARC_REGISTER"] = elf.DT_SPARC_REGISTER
	decs["DT_STRSZ"] = elf.DT_STRSZ
	decs["DT_STRTAB"] = elf.DT_STRTAB
	decs["DT_SYMBOLIC"] = elf.DT_SYMBOLIC
	decs["DT_SYMENT"] = elf.DT_SYMENT
	decs["DT_SYMINENT"] = elf.DT_SYMINENT
	decs["DT_SYMINFO"] = elf.DT_SYMINFO
	decs["DT_SYMINSZ"] = elf.DT_SYMINSZ
	decs["DT_SYMTAB"] = elf.DT_SYMTAB
	decs["DT_SYMTAB_SHNDX"] = elf.DT_SYMTAB_SHNDX
	decs["DT_TEXTREL"] = elf.DT_TEXTREL
	decs["DT_TLSDESC_GOT"] = elf.DT_TLSDESC_GOT
	decs["DT_TLSDESC_PLT"] = elf.DT_TLSDESC_PLT
	decs["DT_USED"] = elf.DT_USED
	decs["DT_VALRNGHI"] = elf.DT_VALRNGHI
	decs["DT_VALRNGLO"] = elf.DT_VALRNGLO
	decs["DT_VERDEF"] = elf.DT_VERDEF
	decs["DT_VERDEFNUM"] = elf.DT_VERDEFNUM
	decs["DT_VERNEED"] = elf.DT_VERNEED
	decs["DT_VERNEEDNUM"] = elf.DT_VERNEEDNUM
	decs["DT_VERSYM"] = elf.DT_VERSYM
	decs["Data"] = reflect.TypeOf((*elf.Data)(nil)).Elem()
	decs["Dyn32"] = reflect.TypeOf((*elf.Dyn32)(nil)).Elem()
	decs["Dyn64"] = reflect.TypeOf((*elf.Dyn64)(nil)).Elem()
	decs["DynFlag"] = reflect.TypeOf((*elf.DynFlag)(nil)).Elem()
	decs["DynTag"] = reflect.TypeOf((*elf.DynTag)(nil)).Elem()
	decs["EI_ABIVERSION"] = UntypedNumericConst("8")
	decs["EI_CLASS"] = UntypedNumericConst("4")
	decs["EI_DATA"] = UntypedNumericConst("5")
	decs["EI_NIDENT"] = UntypedNumericConst("16")
	decs["EI_OSABI"] = UntypedNumericConst("7")
	decs["EI_PAD"] = UntypedNumericConst("9")
	decs["EI_VERSION"] = UntypedNumericConst("6")
	decs["ELFCLASS32"] = elf.ELFCLASS32
	decs["ELFCLASS64"] = elf.ELFCLASS64
	decs["ELFCLASSNONE"] = elf.ELFCLASSNONE
	decs["ELFDATA2LSB"] = elf.ELFDATA2LSB
	decs["ELFDATA2MSB"] = elf.ELFDATA2MSB
	decs["ELFDATANONE"] = elf.ELFDATANONE
	decs["ELFMAG"] = UntypedStringConst("\u007fELF")
	decs["ELFOSABI_86OPEN"] = elf.ELFOSABI_86OPEN
	decs["ELFOSABI_AIX"] = elf.ELFOSABI_AIX
	decs["ELFOSABI_ARM"] = elf.ELFOSABI_ARM
	decs["ELFOSABI_AROS"] = elf.ELFOSABI_AROS
	decs["ELFOSABI_CLOUDABI"] = elf.ELFOSABI_CLOUDABI
	decs["ELFOSABI_FENIXOS"] = elf.ELFOSABI_FENIXOS
	decs["ELFOSABI_FREEBSD"] = elf.ELFOSABI_FREEBSD
	decs["ELFOSABI_HPUX"] = elf.ELFOSABI_HPUX
	decs["ELFOSABI_HURD"] = elf.ELFOSABI_HURD
	decs["ELFOSABI_IRIX"] = elf.ELFOSABI_IRIX
	decs["ELFOSABI_LINUX"] = elf.ELFOSABI_LINUX
	decs["ELFOSABI_MODESTO"] = elf.ELFOSABI_MODESTO
	decs["ELFOSABI_NETBSD"] = elf.ELFOSABI_NETBSD
	decs["ELFOSABI_NONE"] = elf.ELFOSABI_NONE
	decs["ELFOSABI_NSK"] = elf.ELFOSABI_NSK
	decs["ELFOSABI_OPENBSD"] = elf.ELFOSABI_OPENBSD
	decs["ELFOSABI_OPENVMS"] = elf.ELFOSABI_OPENVMS
	decs["ELFOSABI_SOLARIS"] = elf.ELFOSABI_SOLARIS
	decs["ELFOSABI_STANDALONE"] = elf.ELFOSABI_STANDALONE
	decs["ELFOSABI_TRU64"] = elf.ELFOSABI_TRU64
	decs["EM_386"] = elf.EM_386
	decs["EM_486"] = elf.EM_486
	decs["EM_56800EX"] = elf.EM_56800EX
	decs["EM_68HC05"] = elf.EM_68HC05
	decs["EM_68HC08"] = elf.EM_68HC08
	decs["EM_68HC11"] = elf.EM_68HC11
	decs["EM_68HC12"] = elf.EM_68HC12
	decs["EM_68HC16"] = elf.EM_68HC16
	decs["EM_68K"] = elf.EM_68K
	decs["EM_78KOR"] = elf.EM_78KOR
	decs["EM_8051"] = elf.EM_8051
	decs["EM_860"] = elf.EM_860
	decs["EM_88K"] = elf.EM_88K
	decs["EM_960"] = elf.EM_960
	decs["EM_AARCH64"] = elf.EM_AARCH64
	decs["EM_ALPHA"] = elf.EM_ALPHA
	decs["EM_ALPHA_STD"] = elf.EM_ALPHA_STD
	decs["EM_ALTERA_NIOS2"] = elf.EM_ALTERA_NIOS2
	decs["EM_AMDGPU"] = elf.EM_AMDGPU
	decs["EM_ARC"] = elf.EM_ARC
	decs["EM_ARCA"] = elf.EM_ARCA
	decs["EM_ARC_COMPACT"] = elf.EM_ARC_COMPACT
	decs["EM_ARC_COMPACT2"] = elf.EM_ARC_COMPACT2
	decs["EM_ARM"] = elf.EM_ARM
	decs["EM_AVR"] = elf.EM_AVR
	decs["EM_AVR32"] = elf.EM_AVR32
	decs["EM_BA1"] = elf.EM_BA1
	decs["EM_BA2"] = elf.EM_BA2
	decs["EM_BLACKFIN"] = elf.EM_BLACKFIN
	decs["EM_BPF"] = elf.EM_BPF
	decs["EM_C166"] = elf.EM_C166
	decs["EM_CDP"] = elf.EM_CDP
	decs["EM_CE"] = elf.EM_CE
	decs["EM_CLOUDSHIELD"] = elf.EM_CLOUDSHIELD
	decs["EM_COGE"] = elf.EM_COGE
	decs["EM_COLDFIRE"] = elf.EM_COLDFIRE
	decs["EM_COOL"] = elf.EM_COOL
	decs["EM_COREA_1ST"] = elf.EM_COREA_1ST
	decs["EM_COREA_2ND"] = elf.EM_COREA_2ND
	decs["EM_CR"] = elf.EM_CR
	decs["EM_CR16"] = elf.EM_CR16
	decs["EM_CRAYNV2"] = elf.EM_CRAYNV2
	decs["EM_CRIS"] = elf.EM_CRIS
	decs["EM_CRX"] = elf.EM_CRX
	decs["EM_CSR_KALIMBA"] = elf.EM_CSR_KALIMBA
	decs["EM_CUDA"] = elf.EM_CUDA
	decs["EM_CYPRESS_M8C"] = elf.EM_CYPRESS_M8C
	decs["EM_D10V"] = elf.EM_D10V
	decs["EM_D30V"] = elf.EM_D30V
	decs["EM_DSP24"] = elf.EM_DSP24
	decs["EM_DSPIC30F"] = elf.EM_DSPIC30F
	decs["EM_DXP"] = elf.EM_DXP
	decs["EM_ECOG1"] = elf.EM_ECOG1
	decs["EM_ECOG16"] = elf.EM_ECOG16
	decs["EM_ECOG1X"] = elf.EM_ECOG1X
	decs["EM_ECOG2"] = elf.EM_ECOG2
	decs["EM_ETPU"] = elf.EM_ETPU
	decs["EM_EXCESS"] = elf.EM_EXCESS
	decs["EM_F2MC16"] = elf.EM_F2MC16
	decs["EM_FIREPATH"] = elf.EM_FIREPATH
	decs["EM_FR20"] = elf.EM_FR20
	decs["EM_FR30"] = elf.EM_FR30
	decs["EM_FT32"] = elf.EM_FT32
	decs["EM_FX66"] = elf.EM_FX66
	decs["EM_H8S"] = elf.EM_H8S
	decs["EM_H8_300"] = elf.EM_H8_300
	decs["EM_H8_300H"] = elf.EM_H8_300H
	decs["EM_H8_500"] = elf.EM_H8_500
	decs["EM_HUANY"] = elf.EM_HUANY
	decs["EM_IA_64"] = elf.EM_IA_64
	decs["EM_INTEL205"] = elf.EM_INTEL205
	decs["EM_INTEL206"] = elf.EM_INTEL206
	decs["EM_INTEL207"] = elf.EM_INTEL207
	decs["EM_INTEL208"] = elf.EM_INTEL208
	decs["EM_INTEL209"] = elf.EM_INTEL209
	decs["EM_IP2K"] = elf.EM_IP2K
	decs["EM_JAVELIN"] = elf.EM_JAVELIN
	decs["EM_K10M"] = elf.EM_K10M
	decs["EM_KM32"] = elf.EM_KM32
	decs["EM_KMX16"] = elf.EM_KMX16
	decs["EM_KMX32"] = elf.EM_KMX32
	decs["EM_KMX8"] = elf.EM_KMX8
	decs["EM_KVARC"] = elf.EM_KVARC
	decs["EM_L10M"] = elf.EM_L10M
	decs["EM_LANAI"] = elf.EM_LANAI
	decs["EM_LATTICEMICO32"] = elf.EM_LATTICEMICO32
	decs["EM_M16C"] = elf.EM_M16C
	decs["EM_M32"] = elf.EM_M32
	decs["EM_M32C"] = elf.EM_M32C
	decs["EM_M32R"] = elf.EM_M32R
	decs["EM_MANIK"] = elf.EM_MANIK
	decs["EM_MAX"] = elf.EM_MAX
	decs["EM_MAXQ30"] = elf.EM_MAXQ30
	decs["EM_MCHP_PIC"] = elf.EM_MCHP_PIC
	decs["EM_MCST_ELBRUS"] = elf.EM_MCST_ELBRUS
	decs["EM_ME16"] = elf.EM_ME16
	decs["EM_METAG"] = elf.EM_METAG
	decs["EM_MICROBLAZE"] = elf.EM_MICROBLAZE
	decs["EM_MIPS"] = elf.EM_MIPS
	decs["EM_MIPS_RS3_LE"] = elf.EM_MIPS_RS3_LE
	decs["EM_MIPS_RS4_BE"] = elf.EM_MIPS_RS4_BE
	decs["EM_MIPS_X"] = elf.EM_MIPS_X
	decs["EM_MMA"] = elf.EM_MMA
	decs["EM_MMDSP_PLUS"] = elf.EM_MMDSP_PLUS
	decs["EM_MMIX"] = elf.EM_MMIX
	decs["EM_MN10200"] = elf.EM_MN10200
	decs["EM_MN10300"] = elf.EM_MN10300
	decs["EM_MOXIE"] = elf.EM_MOXIE
	decs["EM_MSP430"] = elf.EM_MSP430
	decs["EM_NCPU"] = elf.EM_NCPU
	decs["EM_NDR1"] = elf.EM_NDR1
	decs["EM_NDS32"] = elf.EM_NDS32
	decs["EM_NONE"] = elf.EM_NONE
	decs["EM_NORC"] = elf.EM_NORC
	decs["EM_NS32K"] = elf.EM_NS32K
	decs["EM_OPEN8"] = elf.EM_OPEN8
	decs["EM_OPENRISC"] = elf.EM_OPENRISC
	decs["EM_PARISC"] = elf.EM_PARISC
	decs["EM_PCP"] = elf.EM_PCP
	decs["EM_PDP10"] = elf.EM_PDP10
	decs["EM_PDP11"] = elf.EM_PDP11
	decs["EM_PDSP"] = elf.EM_PDSP
	decs["EM_PJ"] = elf.EM_PJ
	decs["EM_PPC"] = elf.EM_PPC
	decs["EM_PPC64"] = elf.EM_PPC64
	decs["EM_PRISM"] = elf.EM_PRISM
	decs["EM_QDSP6"] = elf.EM_QDSP6
	decs["EM_R32C"] = elf.EM_R32C
	decs["EM_RCE"] = elf.EM_RCE
	decs["EM_RH32"] = elf.EM_RH32
	decs["EM_RISCV"] = elf.EM_RISCV
	decs["EM_RL78"] = elf.EM_RL78
	decs["EM_RS08"] = elf.EM_RS08
	decs["EM_RX"] = elf.EM_RX
	decs["EM_S370"] = elf.EM_S370
	decs["EM_S390"] = elf.EM_S390
	decs["EM_SCORE7"] = elf.EM_SCORE7
	decs["EM_SEP"] = elf.EM_SEP
	decs["EM_SE_C17"] = elf.EM_SE_C17
	decs["EM_SE_C33"] = elf.EM_SE_C33
	decs["EM_SH"] = elf.EM_SH
	decs["EM_SHARC"] = elf.EM_SHARC
	decs["EM_SLE9X"] = elf.EM_SLE9X
	decs["EM_SNP1K"] = elf.EM_SNP1K
	decs["EM_SPARC"] = elf.EM_SPARC
	decs["EM_SPARC32PLUS"] = elf.EM_SPARC32PLUS
	decs["EM_SPARCV9"] = elf.EM_SPARCV9
	decs["EM_ST100"] = elf.EM_ST100
	decs["EM_ST19"] = elf.EM_ST19
	decs["EM_ST200"] = elf.EM_ST200
	decs["EM_ST7"] = elf.EM_ST7
	decs["EM_ST9PLUS"] = elf.EM_ST9PLUS
	decs["EM_STARCORE"] = elf.EM_STARCORE
	decs["EM_STM8"] = elf.EM_STM8
	decs["EM_STXP7X"] = elf.EM_STXP7X
	decs["EM_SVX"] = elf.EM_SVX
	decs["EM_TILE64"] = elf.EM_TILE64
	decs["EM_TILEGX"] = elf.EM_TILEGX
	decs["EM_TILEPRO"] = elf.EM_TILEPRO
	decs["EM_TINYJ"] = elf.EM_TINYJ
	decs["EM_TI_ARP32"] = elf.EM_TI_ARP32
	decs["EM_TI_C2000"] = elf.EM_TI_C2000
	decs["EM_TI_C5500"] = elf.EM_TI_C5500
	decs["EM_TI_C6000"] = elf.EM_TI_C6000
	decs["EM_TI_PRU"] = elf.EM_TI_PRU
	decs["EM_TMM_GPP"] = elf.EM_TMM_GPP
	decs["EM_TPC"] = elf.EM_TPC
	decs["EM_TRICORE"] = elf.EM_TRICORE
	decs["EM_TRIMEDIA"] = elf.EM_TRIMEDIA
	decs["EM_TSK3000"] = elf.EM_TSK3000
	decs["EM_UNICORE"] = elf.EM_UNICORE
	decs["EM_V800"] = elf.EM_V800
	decs["EM_V850"] = elf.EM_V850
	decs["EM_VAX"] = elf.EM_VAX
	decs["EM_VIDEOCORE"] = elf.EM_VIDEOCORE
	decs["EM_VIDEOCORE3"] = elf.EM_VIDEOCORE3
	decs["EM_VIDEOCORE5"] = elf.EM_VIDEOCORE5
	decs["EM_VISIUM"] = elf.EM_VISIUM
	decs["EM_VPP500"] = elf.EM_VPP500
	decs["EM_X86_64"] = elf.EM_X86_64
	decs["EM_XCORE"] = elf.EM_XCORE
	decs["EM_XGATE"] = elf.EM_XGATE
	decs["EM_XIMO16"] = elf.EM_XIMO16
	decs["EM_XTENSA"] = elf.EM_XTENSA
	decs["EM_Z80"] = elf.EM_Z80
	decs["EM_ZSP"] = elf.EM_ZSP
	decs["ET_CORE"] = elf.ET_CORE
	decs["ET_DYN"] = elf.ET_DYN
	decs["ET_EXEC"] = elf.ET_EXEC
	decs["ET_HIOS"] = elf.ET_HIOS
	decs["ET_HIPROC"] = elf.ET_HIPROC
	decs["ET_LOOS"] = elf.ET_LOOS
	decs["ET_LOPROC"] = elf.ET_LOPROC
	decs["ET_NONE"] = elf.ET_NONE
	decs["ET_REL"] = elf.ET_REL
	decs["EV_CURRENT"] = elf.EV_CURRENT
	decs["EV_NONE"] = elf.EV_NONE
	decs["ErrNoSymbols"] = &elf.ErrNoSymbols
	decs["File"] = reflect.TypeOf((*elf.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*elf.FileHeader)(nil)).Elem()
	decs["FormatError"] = reflect.TypeOf((*elf.FormatError)(nil)).Elem()
	decs["Header32"] = reflect.TypeOf((*elf.Header32)(nil)).Elem()
	decs["Header64"] = reflect.TypeOf((*elf.Header64)(nil)).Elem()
	decs["ImportedSymbol"] = reflect.TypeOf((*elf.ImportedSymbol)(nil)).Elem()
	decs["Machine"] = reflect.TypeOf((*elf.Machine)(nil)).Elem()
	decs["NT_FPREGSET"] = elf.NT_FPREGSET
	decs["NT_PRPSINFO"] = elf.NT_PRPSINFO
	decs["NT_PRSTATUS"] = elf.NT_PRSTATUS
	decs["NType"] = reflect.TypeOf((*elf.NType)(nil)).Elem()
	decs["NewFile"] = elf.NewFile
	decs["OSABI"] = reflect.TypeOf((*elf.OSABI)(nil)).Elem()
	decs["Open"] = elf.Open
	decs["PF_MASKOS"] = elf.PF_MASKOS
	decs["PF_MASKPROC"] = elf.PF_MASKPROC
	decs["PF_R"] = elf.PF_R
	decs["PF_W"] = elf.PF_W
	decs["PF_X"] = elf.PF_X
	decs["PT_AARCH64_ARCHEXT"] = elf.PT_AARCH64_ARCHEXT
	decs["PT_AARCH64_UNWIND"] = elf.PT_AARCH64_UNWIND
	decs["PT_ARM_ARCHEXT"] = elf.PT_ARM_ARCHEXT
	decs["PT_ARM_EXIDX"] = elf.PT_ARM_EXIDX
	decs["PT_DYNAMIC"] = elf.PT_DYNAMIC
	decs["PT_GNU_EH_FRAME"] = elf.PT_GNU_EH_FRAME
	decs["PT_GNU_MBIND_HI"] = elf.PT_GNU_MBIND_HI
	decs["PT_GNU_MBIND_LO"] = elf.PT_GNU_MBIND_LO
	decs["PT_GNU_PROPERTY"] = elf.PT_GNU_PROPERTY
	decs["PT_GNU_RELRO"] = elf.PT_GNU_RELRO
	decs["PT_GNU_STACK"] = elf.PT_GNU_STACK
	decs["PT_HIOS"] = elf.PT_HIOS
	decs["PT_HIPROC"] = elf.PT_HIPROC
	decs["PT_INTERP"] = elf.PT_INTERP
	decs["PT_LOAD"] = elf.PT_LOAD
	decs["PT_LOOS"] = elf.PT_LOOS
	decs["PT_LOPROC"] = elf.PT_LOPROC
	decs["PT_MIPS_ABIFLAGS"] = elf.PT_MIPS_ABIFLAGS
	decs["PT_MIPS_OPTIONS"] = elf.PT_MIPS_OPTIONS
	decs["PT_MIPS_REGINFO"] = elf.PT_MIPS_REGINFO
	decs["PT_MIPS_RTPROC"] = elf.PT_MIPS_RTPROC
	decs["PT_NOTE"] = elf.PT_NOTE
	decs["PT_NULL"] = elf.PT_NULL
	decs["PT_OPENBSD_BOOTDATA"] = elf.PT_OPENBSD_BOOTDATA
	decs["PT_OPENBSD_RANDOMIZE"] = elf.PT_OPENBSD_RANDOMIZE
	decs["PT_OPENBSD_WXNEEDED"] = elf.PT_OPENBSD_WXNEEDED
	decs["PT_PAX_FLAGS"] = elf.PT_PAX_FLAGS
	decs["PT_PHDR"] = elf.PT_PHDR
	decs["PT_S390_PGSTE"] = elf.PT_S390_PGSTE
	decs["PT_SHLIB"] = elf.PT_SHLIB
	decs["PT_SUNWSTACK"] = elf.PT_SUNWSTACK
	decs["PT_SUNW_EH_FRAME"] = elf.PT_SUNW_EH_FRAME
	decs["PT_TLS"] = elf.PT_TLS
	decs["Prog"] = reflect.TypeOf((*elf.Prog)(nil)).Elem()
	decs["Prog32"] = reflect.TypeOf((*elf.Prog32)(nil)).Elem()
	decs["Prog64"] = reflect.TypeOf((*elf.Prog64)(nil)).Elem()
	decs["ProgFlag"] = reflect.TypeOf((*elf.ProgFlag)(nil)).Elem()
	decs["ProgHeader"] = reflect.TypeOf((*elf.ProgHeader)(nil)).Elem()
	decs["ProgType"] = reflect.TypeOf((*elf.ProgType)(nil)).Elem()
	decs["R_386"] = reflect.TypeOf((*elf.R_386)(nil)).Elem()
	decs["R_386_16"] = elf.R_386_16
	decs["R_386_32"] = elf.R_386_32
	decs["R_386_32PLT"] = elf.R_386_32PLT
	decs["R_386_8"] = elf.R_386_8
	decs["R_386_COPY"] = elf.R_386_COPY
	decs["R_386_GLOB_DAT"] = elf.R_386_GLOB_DAT
	decs["R_386_GOT32"] = elf.R_386_GOT32
	decs["R_386_GOT32X"] = elf.R_386_GOT32X
	decs["R_386_GOTOFF"] = elf.R_386_GOTOFF
	decs["R_386_GOTPC"] = elf.R_386_GOTPC
	decs["R_386_IRELATIVE"] = elf.R_386_IRELATIVE
	decs["R_386_JMP_SLOT"] = elf.R_386_JMP_SLOT
	decs["R_386_NONE"] = elf.R_386_NONE
	decs["R_386_PC16"] = elf.R_386_PC16
	decs["R_386_PC32"] = elf.R_386_PC32
	decs["R_386_PC8"] = elf.R_386_PC8
	decs["R_386_PLT32"] = elf.R_386_PLT32
	decs["R_386_RELATIVE"] = elf.R_386_RELATIVE
	decs["R_386_SIZE32"] = elf.R_386_SIZE32
	decs["R_386_TLS_DESC"] = elf.R_386_TLS_DESC
	decs["R_386_TLS_DESC_CALL"] = elf.R_386_TLS_DESC_CALL
	decs["R_386_TLS_DTPMOD32"] = elf.R_386_TLS_DTPMOD32
	decs["R_386_TLS_DTPOFF32"] = elf.R_386_TLS_DTPOFF32
	decs["R_386_TLS_GD"] = elf.R_386_TLS_GD
	decs["R_386_TLS_GD_32"] = elf.R_386_TLS_GD_32
	decs["R_386_TLS_GD_CALL"] = elf.R_386_TLS_GD_CALL
	decs["R_386_TLS_GD_POP"] = elf.R_386_TLS_GD_POP
	decs["R_386_TLS_GD_PUSH"] = elf.R_386_TLS_GD_PUSH
	decs["R_386_TLS_GOTDESC"] = elf.R_386_TLS_GOTDESC
	decs["R_386_TLS_GOTIE"] = elf.R_386_TLS_GOTIE
	decs["R_386_TLS_IE"] = elf.R_386_TLS_IE
	decs["R_386_TLS_IE_32"] = elf.R_386_TLS_IE_32
	decs["R_386_TLS_LDM"] = elf.R_386_TLS_LDM
	decs["R_386_TLS_LDM_32"] = elf.R_386_TLS_LDM_32
	decs["R_386_TLS_LDM_CALL"] = elf.R_386_TLS_LDM_CALL
	decs["R_386_TLS_LDM_POP"] = elf.R_386_TLS_LDM_POP
	decs["R_386_TLS_LDM_PUSH"] = elf.R_386_TLS_LDM_PUSH
	decs["R_386_TLS_LDO_32"] = elf.R_386_TLS_LDO_32
	decs["R_386_TLS_LE"] = elf.R_386_TLS_LE
	decs["R_386_TLS_LE_32"] = elf.R_386_TLS_LE_32
	decs["R_386_TLS_TPOFF"] = elf.R_386_TLS_TPOFF
	decs["R_386_TLS_TPOFF32"] = elf.R_386_TLS_TPOFF32
	decs["R_390"] = reflect.TypeOf((*elf.R_390)(nil)).Elem()
	decs["R_390_12"] = elf.R_390_12
	decs["R_390_16"] = elf.R_390_16
	decs["R_390_20"] = elf.R_390_20
	decs["R_390_32"] = elf.R_390_32
	decs["R_390_64"] = elf.R_390_64
	decs["R_390_8"] = elf.R_390_8
	decs["R_390_COPY"] = elf.R_390_COPY
	decs["R_390_GLOB_DAT"] = elf.R_390_GLOB_DAT
	decs["R_390_GOT12"] = elf.R_390_GOT12
	decs["R_390_GOT16"] = elf.R_390_GOT16
	decs["R_390_GOT20"] = elf.R_390_GOT20
	decs["R_390_GOT32"] = elf.R_390_GOT32
	decs["R_390_GOT64"] = elf.R_390_GOT64
	decs["R_390_GOTENT"] = elf.R_390_GOTENT
	decs["R_390_GOTOFF"] = elf.R_390_GOTOFF
	decs["R_390_GOTOFF16"] = elf.R_390_GOTOFF16
	decs["R_390_GOTOFF64"] = elf.R_390_GOTOFF64
	decs["R_390_GOTPC"] = elf.R_390_GOTPC
	decs["R_390_GOTPCDBL"] = elf.R_390_GOTPCDBL
	decs["R_390_GOTPLT12"] = elf.R_390_GOTPLT12
	decs["R_390_GOTPLT16"] = elf.R_390_GOTPLT16
	decs["R_390_GOTPLT20"] = elf.R_390_GOTPLT20
	decs["R_390_GOTPLT32"] = elf.R_390_GOTPLT32
	decs["R_390_GOTPLT64"] = elf.R_390_GOTPLT64
	decs["R_390_GOTPLTENT"] = elf.R_390_GOTPLTENT
	decs["R_390_GOTPLTOFF16"] = elf.R_390_GOTPLTOFF16
	decs["R_390_GOTPLTOFF32"] = elf.R_390_GOTPLTOFF32
	decs["R_390_GOTPLTOFF64"] = elf.R_390_GOTPLTOFF64
	decs["R_390_JMP_SLOT"] = elf.R_390_JMP_SLOT
	decs["R_390_NONE"] = elf.R_390_NONE
	decs["R_390_PC16"] = elf.R_390_PC16
	decs["R_390_PC16DBL"] = elf.R_390_PC16DBL
	decs["R_390_PC32"] = elf.R_390_PC32
	decs["R_390_PC32DBL"] = elf.R_390_PC32DBL
	decs["R_390_PC64"] = elf.R_390_PC64
	decs["R_390_PLT16DBL"] = elf.R_390_PLT16DBL
	decs["R_390_PLT32"] = elf.R_390_PLT32
	decs["R_390_PLT32DBL"] = elf.R_390_PLT32DBL
	decs["R_390_PLT64"] = elf.R_390_PLT64
	decs["R_390_RELATIVE"] = elf.R_390_RELATIVE
	decs["R_390_TLS_DTPMOD"] = elf.R_390_TLS_DTPMOD
	decs["R_390_TLS_DTPOFF"] = elf.R_390_TLS_DTPOFF
	decs["R_390_TLS_GD32"] = elf.R_390_TLS_GD32
	decs["R_390_TLS_GD64"] = elf.R_390_TLS_GD64
	decs["R_390_TLS_GDCALL"] = elf.R_390_TLS_GDCALL
	decs["R_390_TLS_GOTIE12"] = elf.R_390_TLS_GOTIE12
	decs["R_390_TLS_GOTIE20"] = elf.R_390_TLS_GOTIE20
	decs["R_390_TLS_GOTIE32"] = elf.R_390_TLS_GOTIE32
	decs["R_390_TLS_GOTIE64"] = elf.R_390_TLS_GOTIE64
	decs["R_390_TLS_IE32"] = elf.R_390_TLS_IE32
	decs["R_390_TLS_IE64"] = elf.R_390_TLS_IE64
	decs["R_390_TLS_IEENT"] = elf.R_390_TLS_IEENT
	decs["R_390_TLS_LDCALL"] = elf.R_390_TLS_LDCALL
	decs["R_390_TLS_LDM32"] = elf.R_390_TLS_LDM32
	decs["R_390_TLS_LDM64"] = elf.R_390_TLS_LDM64
	decs["R_390_TLS_LDO32"] = elf.R_390_TLS_LDO32
	decs["R_390_TLS_LDO64"] = elf.R_390_TLS_LDO64
	decs["R_390_TLS_LE32"] = elf.R_390_TLS_LE32
	decs["R_390_TLS_LE64"] = elf.R_390_TLS_LE64
	decs["R_390_TLS_LOAD"] = elf.R_390_TLS_LOAD
	decs["R_390_TLS_TPOFF"] = elf.R_390_TLS_TPOFF
	decs["R_AARCH64"] = reflect.TypeOf((*elf.R_AARCH64)(nil)).Elem()
	decs["R_AARCH64_ABS16"] = elf.R_AARCH64_ABS16
	decs["R_AARCH64_ABS32"] = elf.R_AARCH64_ABS32
	decs["R_AARCH64_ABS64"] = elf.R_AARCH64_ABS64
	decs["R_AARCH64_ADD_ABS_LO12_NC"] = elf.R_AARCH64_ADD_ABS_LO12_NC
	decs["R_AARCH64_ADR_GOT_PAGE"] = elf.R_AARCH64_ADR_GOT_PAGE
	decs["R_AARCH64_ADR_PREL_LO21"] = elf.R_AARCH64_ADR_PREL_LO21
	decs["R_AARCH64_ADR_PREL_PG_HI21"] = elf.R_AARCH64_ADR_PREL_PG_HI21
	decs["R_AARCH64_ADR_PREL_PG_HI21_NC"] = elf.R_AARCH64_ADR_PREL_PG_HI21_NC
	decs["R_AARCH64_CALL26"] = elf.R_AARCH64_CALL26
	decs["R_AARCH64_CONDBR19"] = elf.R_AARCH64_CONDBR19
	decs["R_AARCH64_COPY"] = elf.R_AARCH64_COPY
	decs["R_AARCH64_GLOB_DAT"] = elf.R_AARCH64_GLOB_DAT
	decs["R_AARCH64_GOT_LD_PREL19"] = elf.R_AARCH64_GOT_LD_PREL19
	decs["R_AARCH64_IRELATIVE"] = elf.R_AARCH64_IRELATIVE
	decs["R_AARCH64_JUMP26"] = elf.R_AARCH64_JUMP26
	decs["R_AARCH64_JUMP_SLOT"] = elf.R_AARCH64_JUMP_SLOT
	decs["R_AARCH64_LD64_GOTOFF_LO15"] = elf.R_AARCH64_LD64_GOTOFF_LO15
	decs["R_AARCH64_LD64_GOTPAGE_LO15"] = elf.R_AARCH64_LD64_GOTPAGE_LO15
	decs["R_AARCH64_LD64_GOT_LO12_NC"] = elf.R_AARCH64_LD64_GOT_LO12_NC
	decs["R_AARCH64_LDST128_ABS_LO12_NC"] = elf.R_AARCH64_LDST128_ABS_LO12_NC
	decs["R_AARCH64_LDST16_ABS_LO12_NC"] = elf.R_AARCH64_LDST16_ABS_LO12_NC
	decs["R_AARCH64_LDST32_ABS_LO12_NC"] = elf.R_AARCH64_LDST32_ABS_LO12_NC
	decs["R_AARCH64_LDST64_ABS_LO12_NC"] = elf.R_AARCH64_LDST64_ABS_LO12_NC
	decs["R_AARCH64_LDST8_ABS_LO12_NC"] = elf.R_AARCH64_LDST8_ABS_LO12_NC
	decs["R_AARCH64_LD_PREL_LO19"] = elf.R_AARCH64_LD_PREL_LO19
	decs["R_AARCH64_MOVW_SABS_G0"] = elf.R_AARCH64_MOVW_SABS_G0
	decs["R_AARCH64_MOVW_SABS_G1"] = elf.R_AARCH64_MOVW_SABS_G1
	decs["R_AARCH64_MOVW_SABS_G2"] = elf.R_AARCH64_MOVW_SABS_G2
	decs["R_AARCH64_MOVW_UABS_G0"] = elf.R_AARCH64_MOVW_UABS_G0
	decs["R_AARCH64_MOVW_UABS_G0_NC"] = elf.R_AARCH64_MOVW_UABS_G0_NC
	decs["R_AARCH64_MOVW_UABS_G1"] = elf.R_AARCH64_MOVW_UABS_G1
	decs["R_AARCH64_MOVW_UABS_G1_NC"] = elf.R_AARCH64_MOVW_UABS_G1_NC
	decs["R_AARCH64_MOVW_UABS_G2"] = elf.R_AARCH64_MOVW_UABS_G2
	decs["R_AARCH64_MOVW_UABS_G2_NC"] = elf.R_AARCH64_MOVW_UABS_G2_NC
	decs["R_AARCH64_MOVW_UABS_G3"] = elf.R_AARCH64_MOVW_UABS_G3
	decs["R_AARCH64_NONE"] = elf.R_AARCH64_NONE
	decs["R_AARCH64_NULL"] = elf.R_AARCH64_NULL
	decs["R_AARCH64_P32_ABS16"] = elf.R_AARCH64_P32_ABS16
	decs["R_AARCH64_P32_ABS32"] = elf.R_AARCH64_P32_ABS32
	decs["R_AARCH64_P32_ADD_ABS_LO12_NC"] = elf.R_AARCH64_P32_ADD_ABS_LO12_NC
	decs["R_AARCH64_P32_ADR_GOT_PAGE"] = elf.R_AARCH64_P32_ADR_GOT_PAGE
	decs["R_AARCH64_P32_ADR_PREL_LO21"] = elf.R_AARCH64_P32_ADR_PREL_LO21
	decs["R_AARCH64_P32_ADR_PREL_PG_HI21"] = elf.R_AARCH64_P32_ADR_PREL_PG_HI21
	decs["R_AARCH64_P32_CALL26"] = elf.R_AARCH64_P32_CALL26
	decs["R_AARCH64_P32_CONDBR19"] = elf.R_AARCH64_P32_CONDBR19
	decs["R_AARCH64_P32_COPY"] = elf.R_AARCH64_P32_COPY
	decs["R_AARCH64_P32_GLOB_DAT"] = elf.R_AARCH64_P32_GLOB_DAT
	decs["R_AARCH64_P32_GOT_LD_PREL19"] = elf.R_AARCH64_P32_GOT_LD_PREL19
	decs["R_AARCH64_P32_IRELATIVE"] = elf.R_AARCH64_P32_IRELATIVE
	decs["R_AARCH64_P32_JUMP26"] = elf.R_AARCH64_P32_JUMP26
	decs["R_AARCH64_P32_JUMP_SLOT"] = elf.R_AARCH64_P32_JUMP_SLOT
	decs["R_AARCH64_P32_LD32_GOT_LO12_NC"] = elf.R_AARCH64_P32_LD32_GOT_LO12_NC
	decs["R_AARCH64_P32_LDST128_ABS_LO12_NC"] = elf.R_AARCH64_P32_LDST128_ABS_LO12_NC
	decs["R_AARCH64_P32_LDST16_ABS_LO12_NC"] = elf.R_AARCH64_P32_LDST16_ABS_LO12_NC
	decs["R_AARCH64_P32_LDST32_ABS_LO12_NC"] = elf.R_AARCH64_P32_LDST32_ABS_LO12_NC
	decs["R_AARCH64_P32_LDST64_ABS_LO12_NC"] = elf.R_AARCH64_P32_LDST64_ABS_LO12_NC
	decs["R_AARCH64_P32_LDST8_ABS_LO12_NC"] = elf.R_AARCH64_P32_LDST8_ABS_LO12_NC
	decs["R_AARCH64_P32_LD_PREL_LO19"] = elf.R_AARCH64_P32_LD_PREL_LO19
	decs["R_AARCH64_P32_MOVW_SABS_G0"] = elf.R_AARCH64_P32_MOVW_SABS_G0
	decs["R_AARCH64_P32_MOVW_UABS_G0"] = elf.R_AARCH64_P32_MOVW_UABS_G0
	decs["R_AARCH64_P32_MOVW_UABS_G0_NC"] = elf.R_AARCH64_P32_MOVW_UABS_G0_NC
	decs["R_AARCH64_P32_MOVW_UABS_G1"] = elf.R_AARCH64_P32_MOVW_UABS_G1
	decs["R_AARCH64_P32_PREL16"] = elf.R_AARCH64_P32_PREL16
	decs["R_AARCH64_P32_PREL32"] = elf.R_AARCH64_P32_PREL32
	decs["R_AARCH64_P32_RELATIVE"] = elf.R_AARCH64_P32_RELATIVE
	decs["R_AARCH64_P32_TLSDESC"] = elf.R_AARCH64_P32_TLSDESC
	decs["R_AARCH64_P32_TLSDESC_ADD_LO12_NC"] = elf.R_AARCH64_P32_TLSDESC_ADD_LO12_NC
	decs["R_AARCH64_P32_TLSDESC_ADR_PAGE21"] = elf.R_AARCH64_P32_TLSDESC_ADR_PAGE21
	decs["R_AARCH64_P32_TLSDESC_ADR_PREL21"] = elf.R_AARCH64_P32_TLSDESC_ADR_PREL21
	decs["R_AARCH64_P32_TLSDESC_CALL"] = elf.R_AARCH64_P32_TLSDESC_CALL
	decs["R_AARCH64_P32_TLSDESC_LD32_LO12_NC"] = elf.R_AARCH64_P32_TLSDESC_LD32_LO12_NC
	decs["R_AARCH64_P32_TLSDESC_LD_PREL19"] = elf.R_AARCH64_P32_TLSDESC_LD_PREL19
	decs["R_AARCH64_P32_TLSGD_ADD_LO12_NC"] = elf.R_AARCH64_P32_TLSGD_ADD_LO12_NC
	decs["R_AARCH64_P32_TLSGD_ADR_PAGE21"] = elf.R_AARCH64_P32_TLSGD_ADR_PAGE21
	decs["R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21"] = elf.R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21
	decs["R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC"] = elf.R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC
	decs["R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19"] = elf.R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19
	decs["R_AARCH64_P32_TLSLE_ADD_TPREL_HI12"] = elf.R_AARCH64_P32_TLSLE_ADD_TPREL_HI12
	decs["R_AARCH64_P32_TLSLE_ADD_TPREL_LO12"] = elf.R_AARCH64_P32_TLSLE_ADD_TPREL_LO12
	decs["R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC"] = elf.R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC
	decs["R_AARCH64_P32_TLSLE_MOVW_TPREL_G0"] = elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G0
	decs["R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC"] = elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC
	decs["R_AARCH64_P32_TLSLE_MOVW_TPREL_G1"] = elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G1
	decs["R_AARCH64_P32_TLS_DTPMOD"] = elf.R_AARCH64_P32_TLS_DTPMOD
	decs["R_AARCH64_P32_TLS_DTPREL"] = elf.R_AARCH64_P32_TLS_DTPREL
	decs["R_AARCH64_P32_TLS_TPREL"] = elf.R_AARCH64_P32_TLS_TPREL
	decs["R_AARCH64_P32_TSTBR14"] = elf.R_AARCH64_P32_TSTBR14
	decs["R_AARCH64_PREL16"] = elf.R_AARCH64_PREL16
	decs["R_AARCH64_PREL32"] = elf.R_AARCH64_PREL32
	decs["R_AARCH64_PREL64"] = elf.R_AARCH64_PREL64
	decs["R_AARCH64_RELATIVE"] = elf.R_AARCH64_RELATIVE
	decs["R_AARCH64_TLSDESC"] = elf.R_AARCH64_TLSDESC
	decs["R_AARCH64_TLSDESC_ADD"] = elf.R_AARCH64_TLSDESC_ADD
	decs["R_AARCH64_TLSDESC_ADD_LO12_NC"] = elf.R_AARCH64_TLSDESC_ADD_LO12_NC
	decs["R_AARCH64_TLSDESC_ADR_PAGE21"] = elf.R_AARCH64_TLSDESC_ADR_PAGE21
	decs["R_AARCH64_TLSDESC_ADR_PREL21"] = elf.R_AARCH64_TLSDESC_ADR_PREL21
	decs["R_AARCH64_TLSDESC_CALL"] = elf.R_AARCH64_TLSDESC_CALL
	decs["R_AARCH64_TLSDESC_LD64_LO12_NC"] = elf.R_AARCH64_TLSDESC_LD64_LO12_NC
	decs["R_AARCH64_TLSDESC_LDR"] = elf.R_AARCH64_TLSDESC_LDR
	decs["R_AARCH64_TLSDESC_LD_PREL19"] = elf.R_AARCH64_TLSDESC_LD_PREL19
	decs["R_AARCH64_TLSDESC_OFF_G0_NC"] = elf.R_AARCH64_TLSDESC_OFF_G0_NC
	decs["R_AARCH64_TLSDESC_OFF_G1"] = elf.R_AARCH64_TLSDESC_OFF_G1
	decs["R_AARCH64_TLSGD_ADD_LO12_NC"] = elf.R_AARCH64_TLSGD_ADD_LO12_NC
	decs["R_AARCH64_TLSGD_ADR_PAGE21"] = elf.R_AARCH64_TLSGD_ADR_PAGE21
	decs["R_AARCH64_TLSGD_ADR_PREL21"] = elf.R_AARCH64_TLSGD_ADR_PREL21
	decs["R_AARCH64_TLSGD_MOVW_G0_NC"] = elf.R_AARCH64_TLSGD_MOVW_G0_NC
	decs["R_AARCH64_TLSGD_MOVW_G1"] = elf.R_AARCH64_TLSGD_MOVW_G1
	decs["R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21"] = elf.R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
	decs["R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC"] = elf.R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
	decs["R_AARCH64_TLSIE_LD_GOTTPREL_PREL19"] = elf.R_AARCH64_TLSIE_LD_GOTTPREL_PREL19
	decs["R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC"] = elf.R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
	decs["R_AARCH64_TLSIE_MOVW_GOTTPREL_G1"] = elf.R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
	decs["R_AARCH64_TLSLD_ADR_PAGE21"] = elf.R_AARCH64_TLSLD_ADR_PAGE21
	decs["R_AARCH64_TLSLD_ADR_PREL21"] = elf.R_AARCH64_TLSLD_ADR_PREL21
	decs["R_AARCH64_TLSLD_LDST128_DTPREL_LO12"] = elf.R_AARCH64_TLSLD_LDST128_DTPREL_LO12
	decs["R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC"] = elf.R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC
	decs["R_AARCH64_TLSLE_ADD_TPREL_HI12"] = elf.R_AARCH64_TLSLE_ADD_TPREL_HI12
	decs["R_AARCH64_TLSLE_ADD_TPREL_LO12"] = elf.R_AARCH64_TLSLE_ADD_TPREL_LO12
	decs["R_AARCH64_TLSLE_ADD_TPREL_LO12_NC"] = elf.R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
	decs["R_AARCH64_TLSLE_LDST128_TPREL_LO12"] = elf.R_AARCH64_TLSLE_LDST128_TPREL_LO12
	decs["R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC"] = elf.R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC
	decs["R_AARCH64_TLSLE_MOVW_TPREL_G0"] = elf.R_AARCH64_TLSLE_MOVW_TPREL_G0
	decs["R_AARCH64_TLSLE_MOVW_TPREL_G0_NC"] = elf.R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
	decs["R_AARCH64_TLSLE_MOVW_TPREL_G1"] = elf.R_AARCH64_TLSLE_MOVW_TPREL_G1
	decs["R_AARCH64_TLSLE_MOVW_TPREL_G1_NC"] = elf.R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
	decs["R_AARCH64_TLSLE_MOVW_TPREL_G2"] = elf.R_AARCH64_TLSLE_MOVW_TPREL_G2
	decs["R_AARCH64_TLS_DTPMOD64"] = elf.R_AARCH64_TLS_DTPMOD64
	decs["R_AARCH64_TLS_DTPREL64"] = elf.R_AARCH64_TLS_DTPREL64
	decs["R_AARCH64_TLS_TPREL64"] = elf.R_AARCH64_TLS_TPREL64
	decs["R_AARCH64_TSTBR14"] = elf.R_AARCH64_TSTBR14
	decs["R_ALPHA"] = reflect.TypeOf((*elf.R_ALPHA)(nil)).Elem()
	decs["R_ALPHA_BRADDR"] = elf.R_ALPHA_BRADDR
	decs["R_ALPHA_COPY"] = elf.R_ALPHA_COPY
	decs["R_ALPHA_GLOB_DAT"] = elf.R_ALPHA_GLOB_DAT
	decs["R_ALPHA_GPDISP"] = elf.R_ALPHA_GPDISP
	decs["R_ALPHA_GPREL32"] = elf.R_ALPHA_GPREL32
	decs["R_ALPHA_GPRELHIGH"] = elf.R_ALPHA_GPRELHIGH
	decs["R_ALPHA_GPRELLOW"] = elf.R_ALPHA_GPRELLOW
	decs["R_ALPHA_GPVALUE"] = elf.R_ALPHA_GPVALUE
	decs["R_ALPHA_HINT"] = elf.R_ALPHA_HINT
	decs["R_ALPHA_IMMED_BR_HI32"] = elf.R_ALPHA_IMMED_BR_HI32
	decs["R_ALPHA_IMMED_GP_16"] = elf.R_ALPHA_IMMED_GP_16
	decs["R_ALPHA_IMMED_GP_HI32"] = elf.R_ALPHA_IMMED_GP_HI32
	decs["R_ALPHA_IMMED_LO32"] = elf.R_ALPHA_IMMED_LO32
	decs["R_ALPHA_IMMED_SCN_HI32"] = elf.R_ALPHA_IMMED_SCN_HI32
	decs["R_ALPHA_JMP_SLOT"] = elf.R_ALPHA_JMP_SLOT
	decs["R_ALPHA_LITERAL"] = elf.R_ALPHA_LITERAL
	decs["R_ALPHA_LITUSE"] = elf.R_ALPHA_LITUSE
	decs["R_ALPHA_NONE"] = elf.R_ALPHA_NONE
	decs["R_ALPHA_OP_PRSHIFT"] = elf.R_ALPHA_OP_PRSHIFT
	decs["R_ALPHA_OP_PSUB"] = elf.R_ALPHA_OP_PSUB
	decs["R_ALPHA_OP_PUSH"] = elf.R_ALPHA_OP_PUSH
	decs["R_ALPHA_OP_STORE"] = elf.R_ALPHA_OP_STORE
	decs["R_ALPHA_REFLONG"] = elf.R_ALPHA_REFLONG
	decs["R_ALPHA_REFQUAD"] = elf.R_ALPHA_REFQUAD
	decs["R_ALPHA_RELATIVE"] = elf.R_ALPHA_RELATIVE
	decs["R_ALPHA_SREL16"] = elf.R_ALPHA_SREL16
	decs["R_ALPHA_SREL32"] = elf.R_ALPHA_SREL32
	decs["R_ALPHA_SREL64"] = elf.R_ALPHA_SREL64
	decs["R_ARM"] = reflect.TypeOf((*elf.R_ARM)(nil)).Elem()
	decs["R_ARM_ABS12"] = elf.R_ARM_ABS12
	decs["R_ARM_ABS16"] = elf.R_ARM_ABS16
	decs["R_ARM_ABS32"] = elf.R_ARM_ABS32
	decs["R_ARM_ABS32_NOI"] = elf.R_ARM_ABS32_NOI
	decs["R_ARM_ABS8"] = elf.R_ARM_ABS8
	decs["R_ARM_ALU_PCREL_15_8"] = elf.R_ARM_ALU_PCREL_15_8
	decs["R_ARM_ALU_PCREL_23_15"] = elf.R_ARM_ALU_PCREL_23_15
	decs["R_ARM_ALU_PCREL_7_0"] = elf.R_ARM_ALU_PCREL_7_0
	decs["R_ARM_ALU_PC_G0"] = elf.R_ARM_ALU_PC_G0
	decs["R_ARM_ALU_PC_G0_NC"] = elf.R_ARM_ALU_PC_G0_NC
	decs["R_ARM_ALU_PC_G1"] = elf.R_ARM_ALU_PC_G1
	decs["R_ARM_ALU_PC_G1_NC"] = elf.R_ARM_ALU_PC_G1_NC
	decs["R_ARM_ALU_PC_G2"] = elf.R_ARM_ALU_PC_G2
	decs["R_ARM_ALU_SBREL_19_12_NC"] = elf.R_ARM_ALU_SBREL_19_12_NC
	decs["R_ARM_ALU_SBREL_27_20_CK"] = elf.R_ARM_ALU_SBREL_27_20_CK
	decs["R_ARM_ALU_SB_G0"] = elf.R_ARM_ALU_SB_G0
	decs["R_ARM_ALU_SB_G0_NC"] = elf.R_ARM_ALU_SB_G0_NC
	decs["R_ARM_ALU_SB_G1"] = elf.R_ARM_ALU_SB_G1
	decs["R_ARM_ALU_SB_G1_NC"] = elf.R_ARM_ALU_SB_G1_NC
	decs["R_ARM_ALU_SB_G2"] = elf.R_ARM_ALU_SB_G2
	decs["R_ARM_AMP_VCALL9"] = elf.R_ARM_AMP_VCALL9
	decs["R_ARM_BASE_ABS"] = elf.R_ARM_BASE_ABS
	decs["R_ARM_CALL"] = elf.R_ARM_CALL
	decs["R_ARM_COPY"] = elf.R_ARM_COPY
	decs["R_ARM_GLOB_DAT"] = elf.R_ARM_GLOB_DAT
	decs["R_ARM_GNU_VTENTRY"] = elf.R_ARM_GNU_VTENTRY
	decs["R_ARM_GNU_VTINHERIT"] = elf.R_ARM_GNU_VTINHERIT
	decs["R_ARM_GOT32"] = elf.R_ARM_GOT32
	decs["R_ARM_GOTOFF"] = elf.R_ARM_GOTOFF
	decs["R_ARM_GOTOFF12"] = elf.R_ARM_GOTOFF12
	decs["R_ARM_GOTPC"] = elf.R_ARM_GOTPC
	decs["R_ARM_GOTRELAX"] = elf.R_ARM_GOTRELAX
	decs["R_ARM_GOT_ABS"] = elf.R_ARM_GOT_ABS
	decs["R_ARM_GOT_BREL12"] = elf.R_ARM_GOT_BREL12
	decs["R_ARM_GOT_PREL"] = elf.R_ARM_GOT_PREL
	decs["R_ARM_IRELATIVE"] = elf.R_ARM_IRELATIVE
	decs["R_ARM_JUMP24"] = elf.R_ARM_JUMP24
	decs["R_ARM_JUMP_SLOT"] = elf.R_ARM_JUMP_SLOT
	decs["R_ARM_LDC_PC_G0"] = elf.R_ARM_LDC_PC_G0
	decs["R_ARM_LDC_PC_G1"] = elf.R_ARM_LDC_PC_G1
	decs["R_ARM_LDC_PC_G2"] = elf.R_ARM_LDC_PC_G2
	decs["R_ARM_LDC_SB_G0"] = elf.R_ARM_LDC_SB_G0
	decs["R_ARM_LDC_SB_G1"] = elf.R_ARM_LDC_SB_G1
	decs["R_ARM_LDC_SB_G2"] = elf.R_ARM_LDC_SB_G2
	decs["R_ARM_LDRS_PC_G0"] = elf.R_ARM_LDRS_PC_G0
	decs["R_ARM_LDRS_PC_G1"] = elf.R_ARM_LDRS_PC_G1
	decs["R_ARM_LDRS_PC_G2"] = elf.R_ARM_LDRS_PC_G2
	decs["R_ARM_LDRS_SB_G0"] = elf.R_ARM_LDRS_SB_G0
	decs["R_ARM_LDRS_SB_G1"] = elf.R_ARM_LDRS_SB_G1
	decs["R_ARM_LDRS_SB_G2"] = elf.R_ARM_LDRS_SB_G2
	decs["R_ARM_LDR_PC_G1"] = elf.R_ARM_LDR_PC_G1
	decs["R_ARM_LDR_PC_G2"] = elf.R_ARM_LDR_PC_G2
	decs["R_ARM_LDR_SBREL_11_10_NC"] = elf.R_ARM_LDR_SBREL_11_10_NC
	decs["R_ARM_LDR_SB_G0"] = elf.R_ARM_LDR_SB_G0
	decs["R_ARM_LDR_SB_G1"] = elf.R_ARM_LDR_SB_G1
	decs["R_ARM_LDR_SB_G2"] = elf.R_ARM_LDR_SB_G2
	decs["R_ARM_ME_TOO"] = elf.R_ARM_ME_TOO
	decs["R_ARM_MOVT_ABS"] = elf.R_ARM_MOVT_ABS
	decs["R_ARM_MOVT_BREL"] = elf.R_ARM_MOVT_BREL
	decs["R_ARM_MOVT_PREL"] = elf.R_ARM_MOVT_PREL
	decs["R_ARM_MOVW_ABS_NC"] = elf.R_ARM_MOVW_ABS_NC
	decs["R_ARM_MOVW_BREL"] = elf.R_ARM_MOVW_BREL
	decs["R_ARM_MOVW_BREL_NC"] = elf.R_ARM_MOVW_BREL_NC
	decs["R_ARM_MOVW_PREL_NC"] = elf.R_ARM_MOVW_PREL_NC
	decs["R_ARM_NONE"] = elf.R_ARM_NONE
	decs["R_ARM_PC13"] = elf.R_ARM_PC13
	decs["R_ARM_PC24"] = elf.R_ARM_PC24
	decs["R_ARM_PLT32"] = elf.R_ARM_PLT32
	decs["R_ARM_PLT32_ABS"] = elf.R_ARM_PLT32_ABS
	decs["R_ARM_PREL31"] = elf.R_ARM_PREL31
	decs["R_ARM_PRIVATE_0"] = elf.R_ARM_PRIVATE_0
	decs["R_ARM_PRIVATE_1"] = elf.R_ARM_PRIVATE_1
	decs["R_ARM_PRIVATE_10"] = elf.R_ARM_PRIVATE_10
	decs["R_ARM_PRIVATE_11"] = elf.R_ARM_PRIVATE_11
	decs["R_ARM_PRIVATE_12"] = elf.R_ARM_PRIVATE_12
	decs["R_ARM_PRIVATE_13"] = elf.R_ARM_PRIVATE_13
	decs["R_ARM_PRIVATE_14"] = elf.R_ARM_PRIVATE_14
	decs["R_ARM_PRIVATE_15"] = elf.R_ARM_PRIVATE_15
	decs["R_ARM_PRIVATE_2"] = elf.R_ARM_PRIVATE_2
	decs["R_ARM_PRIVATE_3"] = elf.R_ARM_PRIVATE_3
	decs["R_ARM_PRIVATE_4"] = elf.R_ARM_PRIVATE_4
	decs["R_ARM_PRIVATE_5"] = elf.R_ARM_PRIVATE_5
	decs["R_ARM_PRIVATE_6"] = elf.R_ARM_PRIVATE_6
	decs["R_ARM_PRIVATE_7"] = elf.R_ARM_PRIVATE_7
	decs["R_ARM_PRIVATE_8"] = elf.R_ARM_PRIVATE_8
	decs["R_ARM_PRIVATE_9"] = elf.R_ARM_PRIVATE_9
	decs["R_ARM_RABS32"] = elf.R_ARM_RABS32
	decs["R_ARM_RBASE"] = elf.R_ARM_RBASE
	decs["R_ARM_REL32"] = elf.R_ARM_REL32
	decs["R_ARM_REL32_NOI"] = elf.R_ARM_REL32_NOI
	decs["R_ARM_RELATIVE"] = elf.R_ARM_RELATIVE
	decs["R_ARM_RPC24"] = elf.R_ARM_RPC24
	decs["R_ARM_RREL32"] = elf.R_ARM_RREL32
	decs["R_ARM_RSBREL32"] = elf.R_ARM_RSBREL32
	decs["R_ARM_RXPC25"] = elf.R_ARM_RXPC25
	decs["R_ARM_SBREL31"] = elf.R_ARM_SBREL31
	decs["R_ARM_SBREL32"] = elf.R_ARM_SBREL32
	decs["R_ARM_SWI24"] = elf.R_ARM_SWI24
	decs["R_ARM_TARGET1"] = elf.R_ARM_TARGET1
	decs["R_ARM_TARGET2"] = elf.R_ARM_TARGET2
	decs["R_ARM_THM_ABS5"] = elf.R_ARM_THM_ABS5
	decs["R_ARM_THM_ALU_ABS_G0_NC"] = elf.R_ARM_THM_ALU_ABS_G0_NC
	decs["R_ARM_THM_ALU_ABS_G1_NC"] = elf.R_ARM_THM_ALU_ABS_G1_NC
	decs["R_ARM_THM_ALU_ABS_G2_NC"] = elf.R_ARM_THM_ALU_ABS_G2_NC
	decs["R_ARM_THM_ALU_ABS_G3"] = elf.R_ARM_THM_ALU_ABS_G3
	decs["R_ARM_THM_ALU_PREL_11_0"] = elf.R_ARM_THM_ALU_PREL_11_0
	decs["R_ARM_THM_GOT_BREL12"] = elf.R_ARM_THM_GOT_BREL12
	decs["R_ARM_THM_JUMP11"] = elf.R_ARM_THM_JUMP11
	decs["R_ARM_THM_JUMP19"] = elf.R_ARM_THM_JUMP19
	decs["R_ARM_THM_JUMP24"] = elf.R_ARM_THM_JUMP24
	decs["R_ARM_THM_JUMP6"] = elf.R_ARM_THM_JUMP6
	decs["R_ARM_THM_JUMP8"] = elf.R_ARM_THM_JUMP8
	decs["R_ARM_THM_MOVT_ABS"] = elf.R_ARM_THM_MOVT_ABS
	decs["R_ARM_THM_MOVT_BREL"] = elf.R_ARM_THM_MOVT_BREL
	decs["R_ARM_THM_MOVT_PREL"] = elf.R_ARM_THM_MOVT_PREL
	decs["R_ARM_THM_MOVW_ABS_NC"] = elf.R_ARM_THM_MOVW_ABS_NC
	decs["R_ARM_THM_MOVW_BREL"] = elf.R_ARM_THM_MOVW_BREL
	decs["R_ARM_THM_MOVW_BREL_NC"] = elf.R_ARM_THM_MOVW_BREL_NC
	decs["R_ARM_THM_MOVW_PREL_NC"] = elf.R_ARM_THM_MOVW_PREL_NC
	decs["R_ARM_THM_PC12"] = elf.R_ARM_THM_PC12
	decs["R_ARM_THM_PC22"] = elf.R_ARM_THM_PC22
	decs["R_ARM_THM_PC8"] = elf.R_ARM_THM_PC8
	decs["R_ARM_THM_RPC22"] = elf.R_ARM_THM_RPC22
	decs["R_ARM_THM_SWI8"] = elf.R_ARM_THM_SWI8
	decs["R_ARM_THM_TLS_CALL"] = elf.R_ARM_THM_TLS_CALL
	decs["R_ARM_THM_TLS_DESCSEQ16"] = elf.R_ARM_THM_TLS_DESCSEQ16
	decs["R_ARM_THM_TLS_DESCSEQ32"] = elf.R_ARM_THM_TLS_DESCSEQ32
	decs["R_ARM_THM_XPC22"] = elf.R_ARM_THM_XPC22
	decs["R_ARM_TLS_CALL"] = elf.R_ARM_TLS_CALL
	decs["R_ARM_TLS_DESCSEQ"] = elf.R_ARM_TLS_DESCSEQ
	decs["R_ARM_TLS_DTPMOD32"] = elf.R_ARM_TLS_DTPMOD32
	decs["R_ARM_TLS_DTPOFF32"] = elf.R_ARM_TLS_DTPOFF32
	decs["R_ARM_TLS_GD32"] = elf.R_ARM_TLS_GD32
	decs["R_ARM_TLS_GOTDESC"] = elf.R_ARM_TLS_GOTDESC
	decs["R_ARM_TLS_IE12GP"] = elf.R_ARM_TLS_IE12GP
	decs["R_ARM_TLS_IE32"] = elf.R_ARM_TLS_IE32
	decs["R_ARM_TLS_LDM32"] = elf.R_ARM_TLS_LDM32
	decs["R_ARM_TLS_LDO12"] = elf.R_ARM_TLS_LDO12
	decs["R_ARM_TLS_LDO32"] = elf.R_ARM_TLS_LDO32
	decs["R_ARM_TLS_LE12"] = elf.R_ARM_TLS_LE12
	decs["R_ARM_TLS_LE32"] = elf.R_ARM_TLS_LE32
	decs["R_ARM_TLS_TPOFF32"] = elf.R_ARM_TLS_TPOFF32
	decs["R_ARM_V4BX"] = elf.R_ARM_V4BX
	decs["R_ARM_XPC25"] = elf.R_ARM_XPC25
	decs["R_INFO"] = elf.R_INFO
	decs["R_INFO32"] = elf.R_INFO32
	decs["R_MIPS"] = reflect.TypeOf((*elf.R_MIPS)(nil)).Elem()
	decs["R_MIPS_16"] = elf.R_MIPS_16
	decs["R_MIPS_26"] = elf.R_MIPS_26
	decs["R_MIPS_32"] = elf.R_MIPS_32
	decs["R_MIPS_64"] = elf.R_MIPS_64
	decs["R_MIPS_ADD_IMMEDIATE"] = elf.R_MIPS_ADD_IMMEDIATE
	decs["R_MIPS_CALL16"] = elf.R_MIPS_CALL16
	decs["R_MIPS_CALL_HI16"] = elf.R_MIPS_CALL_HI16
	decs["R_MIPS_CALL_LO16"] = elf.R_MIPS_CALL_LO16
	decs["R_MIPS_DELETE"] = elf.R_MIPS_DELETE
	decs["R_MIPS_GOT16"] = elf.R_MIPS_GOT16
	decs["R_MIPS_GOT_DISP"] = elf.R_MIPS_GOT_DISP
	decs["R_MIPS_GOT_HI16"] = elf.R_MIPS_GOT_HI16
	decs["R_MIPS_GOT_LO16"] = elf.R_MIPS_GOT_LO16
	decs["R_MIPS_GOT_OFST"] = elf.R_MIPS_GOT_OFST
	decs["R_MIPS_GOT_PAGE"] = elf.R_MIPS_GOT_PAGE
	decs["R_MIPS_GPREL16"] = elf.R_MIPS_GPREL16
	decs["R_MIPS_GPREL32"] = elf.R_MIPS_GPREL32
	decs["R_MIPS_HI16"] = elf.R_MIPS_HI16
	decs["R_MIPS_HIGHER"] = elf.R_MIPS_HIGHER
	decs["R_MIPS_HIGHEST"] = elf.R_MIPS_HIGHEST
	decs["R_MIPS_INSERT_A"] = elf.R_MIPS_INSERT_A
	decs["R_MIPS_INSERT_B"] = elf.R_MIPS_INSERT_B
	decs["R_MIPS_JALR"] = elf.R_MIPS_JALR
	decs["R_MIPS_LITERAL"] = elf.R_MIPS_LITERAL
	decs["R_MIPS_LO16"] = elf.R_MIPS_LO16
	decs["R_MIPS_NONE"] = elf.R_MIPS_NONE
	decs["R_MIPS_PC16"] = elf.R_MIPS_PC16
	decs["R_MIPS_PJUMP"] = elf.R_MIPS_PJUMP
	decs["R_MIPS_REL16"] = elf.R_MIPS_REL16
	decs["R_MIPS_REL32"] = elf.R_MIPS_REL32
	decs["R_MIPS_RELGOT"] = elf.R_MIPS_RELGOT
	decs["R_MIPS_SCN_DISP"] = elf.R_MIPS_SCN_DISP
	decs["R_MIPS_SHIFT5"] = elf.R_MIPS_SHIFT5
	decs["R_MIPS_SHIFT6"] = elf.R_MIPS_SHIFT6
	decs["R_MIPS_SUB"] = elf.R_MIPS_SUB
	decs["R_MIPS_TLS_DTPMOD32"] = elf.R_MIPS_TLS_DTPMOD32
	decs["R_MIPS_TLS_DTPMOD64"] = elf.R_MIPS_TLS_DTPMOD64
	decs["R_MIPS_TLS_DTPREL32"] = elf.R_MIPS_TLS_DTPREL32
	decs["R_MIPS_TLS_DTPREL64"] = elf.R_MIPS_TLS_DTPREL64
	decs["R_MIPS_TLS_DTPREL_HI16"] = elf.R_MIPS_TLS_DTPREL_HI16
	decs["R_MIPS_TLS_DTPREL_LO16"] = elf.R_MIPS_TLS_DTPREL_LO16
	decs["R_MIPS_TLS_GD"] = elf.R_MIPS_TLS_GD
	decs["R_MIPS_TLS_GOTTPREL"] = elf.R_MIPS_TLS_GOTTPREL
	decs["R_MIPS_TLS_LDM"] = elf.R_MIPS_TLS_LDM
	decs["R_MIPS_TLS_TPREL32"] = elf.R_MIPS_TLS_TPREL32
	decs["R_MIPS_TLS_TPREL64"] = elf.R_MIPS_TLS_TPREL64
	decs["R_MIPS_TLS_TPREL_HI16"] = elf.R_MIPS_TLS_TPREL_HI16
	decs["R_MIPS_TLS_TPREL_LO16"] = elf.R_MIPS_TLS_TPREL_LO16
	decs["R_PPC"] = reflect.TypeOf((*elf.R_PPC)(nil)).Elem()
	decs["R_PPC64"] = reflect.TypeOf((*elf.R_PPC64)(nil)).Elem()
	decs["R_PPC64_ADDR14"] = elf.R_PPC64_ADDR14
	decs["R_PPC64_ADDR14_BRNTAKEN"] = elf.R_PPC64_ADDR14_BRNTAKEN
	decs["R_PPC64_ADDR14_BRTAKEN"] = elf.R_PPC64_ADDR14_BRTAKEN
	decs["R_PPC64_ADDR16"] = elf.R_PPC64_ADDR16
	decs["R_PPC64_ADDR16_DS"] = elf.R_PPC64_ADDR16_DS
	decs["R_PPC64_ADDR16_HA"] = elf.R_PPC64_ADDR16_HA
	decs["R_PPC64_ADDR16_HI"] = elf.R_PPC64_ADDR16_HI
	decs["R_PPC64_ADDR16_HIGH"] = elf.R_PPC64_ADDR16_HIGH
	decs["R_PPC64_ADDR16_HIGHA"] = elf.R_PPC64_ADDR16_HIGHA
	decs["R_PPC64_ADDR16_HIGHER"] = elf.R_PPC64_ADDR16_HIGHER
	decs["R_PPC64_ADDR16_HIGHERA"] = elf.R_PPC64_ADDR16_HIGHERA
	decs["R_PPC64_ADDR16_HIGHEST"] = elf.R_PPC64_ADDR16_HIGHEST
	decs["R_PPC64_ADDR16_HIGHESTA"] = elf.R_PPC64_ADDR16_HIGHESTA
	decs["R_PPC64_ADDR16_LO"] = elf.R_PPC64_ADDR16_LO
	decs["R_PPC64_ADDR16_LO_DS"] = elf.R_PPC64_ADDR16_LO_DS
	decs["R_PPC64_ADDR24"] = elf.R_PPC64_ADDR24
	decs["R_PPC64_ADDR32"] = elf.R_PPC64_ADDR32
	decs["R_PPC64_ADDR64"] = elf.R_PPC64_ADDR64
	decs["R_PPC64_ADDR64_LOCAL"] = elf.R_PPC64_ADDR64_LOCAL
	decs["R_PPC64_DTPMOD64"] = elf.R_PPC64_DTPMOD64
	decs["R_PPC64_DTPREL16"] = elf.R_PPC64_DTPREL16
	decs["R_PPC64_DTPREL16_DS"] = elf.R_PPC64_DTPREL16_DS
	decs["R_PPC64_DTPREL16_HA"] = elf.R_PPC64_DTPREL16_HA
	decs["R_PPC64_DTPREL16_HI"] = elf.R_PPC64_DTPREL16_HI
	decs["R_PPC64_DTPREL16_HIGH"] = elf.R_PPC64_DTPREL16_HIGH
	decs["R_PPC64_DTPREL16_HIGHA"] = elf.R_PPC64_DTPREL16_HIGHA
	decs["R_PPC64_DTPREL16_HIGHER"] = elf.R_PPC64_DTPREL16_HIGHER
	decs["R_PPC64_DTPREL16_HIGHERA"] = elf.R_PPC64_DTPREL16_HIGHERA
	decs["R_PPC64_DTPREL16_HIGHEST"] = elf.R_PPC64_DTPREL16_HIGHEST
	decs["R_PPC64_DTPREL16_HIGHESTA"] = elf.R_PPC64_DTPREL16_HIGHESTA
	decs["R_PPC64_DTPREL16_LO"] = elf.R_PPC64_DTPREL16_LO
	decs["R_PPC64_DTPREL16_LO_DS"] = elf.R_PPC64_DTPREL16_LO_DS
	decs["R_PPC64_DTPREL64"] = elf.R_PPC64_DTPREL64
	decs["R_PPC64_ENTRY"] = elf.R_PPC64_ENTRY
	decs["R_PPC64_GOT16"] = elf.R_PPC64_GOT16
	decs["R_PPC64_GOT16_DS"] = elf.R_PPC64_GOT16_DS
	decs["R_PPC64_GOT16_HA"] = elf.R_PPC64_GOT16_HA
	decs["R_PPC64_GOT16_HI"] = elf.R_PPC64_GOT16_HI
	decs["R_PPC64_GOT16_LO"] = elf.R_PPC64_GOT16_LO
	decs["R_PPC64_GOT16_LO_DS"] = elf.R_PPC64_GOT16_LO_DS
	decs["R_PPC64_GOT_DTPREL16_DS"] = elf.R_PPC64_GOT_DTPREL16_DS
	decs["R_PPC64_GOT_DTPREL16_HA"] = elf.R_PPC64_GOT_DTPREL16_HA
	decs["R_PPC64_GOT_DTPREL16_HI"] = elf.R_PPC64_GOT_DTPREL16_HI
	decs["R_PPC64_GOT_DTPREL16_LO_DS"] = elf.R_PPC64_GOT_DTPREL16_LO_DS
	decs["R_PPC64_GOT_TLSGD16"] = elf.R_PPC64_GOT_TLSGD16
	decs["R_PPC64_GOT_TLSGD16_HA"] = elf.R_PPC64_GOT_TLSGD16_HA
	decs["R_PPC64_GOT_TLSGD16_HI"] = elf.R_PPC64_GOT_TLSGD16_HI
	decs["R_PPC64_GOT_TLSGD16_LO"] = elf.R_PPC64_GOT_TLSGD16_LO
	decs["R_PPC64_GOT_TLSLD16"] = elf.R_PPC64_GOT_TLSLD16
	decs["R_PPC64_GOT_TLSLD16_HA"] = elf.R_PPC64_GOT_TLSLD16_HA
	decs["R_PPC64_GOT_TLSLD16_HI"] = elf.R_PPC64_GOT_TLSLD16_HI
	decs["R_PPC64_GOT_TLSLD16_LO"] = elf.R_PPC64_GOT_TLSLD16_LO
	decs["R_PPC64_GOT_TPREL16_DS"] = elf.R_PPC64_GOT_TPREL16_DS
	decs["R_PPC64_GOT_TPREL16_HA"] = elf.R_PPC64_GOT_TPREL16_HA
	decs["R_PPC64_GOT_TPREL16_HI"] = elf.R_PPC64_GOT_TPREL16_HI
	decs["R_PPC64_GOT_TPREL16_LO_DS"] = elf.R_PPC64_GOT_TPREL16_LO_DS
	decs["R_PPC64_IRELATIVE"] = elf.R_PPC64_IRELATIVE
	decs["R_PPC64_JMP_IREL"] = elf.R_PPC64_JMP_IREL
	decs["R_PPC64_JMP_SLOT"] = elf.R_PPC64_JMP_SLOT
	decs["R_PPC64_NONE"] = elf.R_PPC64_NONE
	decs["R_PPC64_PLT16_LO_DS"] = elf.R_PPC64_PLT16_LO_DS
	decs["R_PPC64_PLTGOT16"] = elf.R_PPC64_PLTGOT16
	decs["R_PPC64_PLTGOT16_DS"] = elf.R_PPC64_PLTGOT16_DS
	decs["R_PPC64_PLTGOT16_HA"] = elf.R_PPC64_PLTGOT16_HA
	decs["R_PPC64_PLTGOT16_HI"] = elf.R_PPC64_PLTGOT16_HI
	decs["R_PPC64_PLTGOT16_LO"] = elf.R_PPC64_PLTGOT16_LO
	decs["R_PPC64_PLTGOT_LO_DS"] = elf.R_PPC64_PLTGOT_LO_DS
	decs["R_PPC64_REL14"] = elf.R_PPC64_REL14
	decs["R_PPC64_REL14_BRNTAKEN"] = elf.R_PPC64_REL14_BRNTAKEN
	decs["R_PPC64_REL14_BRTAKEN"] = elf.R_PPC64_REL14_BRTAKEN
	decs["R_PPC64_REL16"] = elf.R_PPC64_REL16
	decs["R_PPC64_REL16DX_HA"] = elf.R_PPC64_REL16DX_HA
	decs["R_PPC64_REL16_HA"] = elf.R_PPC64_REL16_HA
	decs["R_PPC64_REL16_HI"] = elf.R_PPC64_REL16_HI
	decs["R_PPC64_REL16_LO"] = elf.R_PPC64_REL16_LO
	decs["R_PPC64_REL24"] = elf.R_PPC64_REL24
	decs["R_PPC64_REL24_NOTOC"] = elf.R_PPC64_REL24_NOTOC
	decs["R_PPC64_REL32"] = elf.R_PPC64_REL32
	decs["R_PPC64_REL64"] = elf.R_PPC64_REL64
	decs["R_PPC64_SECTOFF_DS"] = elf.R_PPC64_SECTOFF_DS
	decs["R_PPC64_SECTOFF_LO_DS"] = elf.R_PPC64_SECTOFF_LO_DS
	decs["R_PPC64_TLS"] = elf.R_PPC64_TLS
	decs["R_PPC64_TLSGD"] = elf.R_PPC64_TLSGD
	decs["R_PPC64_TLSLD"] = elf.R_PPC64_TLSLD
	decs["R_PPC64_TOC"] = elf.R_PPC64_TOC
	decs["R_PPC64_TOC16"] = elf.R_PPC64_TOC16
	decs["R_PPC64_TOC16_DS"] = elf.R_PPC64_TOC16_DS
	decs["R_PPC64_TOC16_HA"] = elf.R_PPC64_TOC16_HA
	decs["R_PPC64_TOC16_HI"] = elf.R_PPC64_TOC16_HI
	decs["R_PPC64_TOC16_LO"] = elf.R_PPC64_TOC16_LO
	decs["R_PPC64_TOC16_LO_DS"] = elf.R_PPC64_TOC16_LO_DS
	decs["R_PPC64_TOCSAVE"] = elf.R_PPC64_TOCSAVE
	decs["R_PPC64_TPREL16"] = elf.R_PPC64_TPREL16
	decs["R_PPC64_TPREL16_DS"] = elf.R_PPC64_TPREL16_DS
	decs["R_PPC64_TPREL16_HA"] = elf.R_PPC64_TPREL16_HA
	decs["R_PPC64_TPREL16_HI"] = elf.R_PPC64_TPREL16_HI
	decs["R_PPC64_TPREL16_HIGH"] = elf.R_PPC64_TPREL16_HIGH
	decs["R_PPC64_TPREL16_HIGHA"] = elf.R_PPC64_TPREL16_HIGHA
	decs["R_PPC64_TPREL16_HIGHER"] = elf.R_PPC64_TPREL16_HIGHER
	decs["R_PPC64_TPREL16_HIGHERA"] = elf.R_PPC64_TPREL16_HIGHERA
	decs["R_PPC64_TPREL16_HIGHEST"] = elf.R_PPC64_TPREL16_HIGHEST
	decs["R_PPC64_TPREL16_HIGHESTA"] = elf.R_PPC64_TPREL16_HIGHESTA
	decs["R_PPC64_TPREL16_LO"] = elf.R_PPC64_TPREL16_LO
	decs["R_PPC64_TPREL16_LO_DS"] = elf.R_PPC64_TPREL16_LO_DS
	decs["R_PPC64_TPREL64"] = elf.R_PPC64_TPREL64
	decs["R_PPC_ADDR14"] = elf.R_PPC_ADDR14
	decs["R_PPC_ADDR14_BRNTAKEN"] = elf.R_PPC_ADDR14_BRNTAKEN
	decs["R_PPC_ADDR14_BRTAKEN"] = elf.R_PPC_ADDR14_BRTAKEN
	decs["R_PPC_ADDR16"] = elf.R_PPC_ADDR16
	decs["R_PPC_ADDR16_HA"] = elf.R_PPC_ADDR16_HA
	decs["R_PPC_ADDR16_HI"] = elf.R_PPC_ADDR16_HI
	decs["R_PPC_ADDR16_LO"] = elf.R_PPC_ADDR16_LO
	decs["R_PPC_ADDR24"] = elf.R_PPC_ADDR24
	decs["R_PPC_ADDR32"] = elf.R_PPC_ADDR32
	decs["R_PPC_COPY"] = elf.R_PPC_COPY
	decs["R_PPC_DTPMOD32"] = elf.R_PPC_DTPMOD32
	decs["R_PPC_DTPREL16"] = elf.R_PPC_DTPREL16
	decs["R_PPC_DTPREL16_HA"] = elf.R_PPC_DTPREL16_HA
	decs["R_PPC_DTPREL16_HI"] = elf.R_PPC_DTPREL16_HI
	decs["R_PPC_DTPREL16_LO"] = elf.R_PPC_DTPREL16_LO
	decs["R_PPC_DTPREL32"] = elf.R_PPC_DTPREL32
	decs["R_PPC_EMB_BIT_FLD"] = elf.R_PPC_EMB_BIT_FLD
	decs["R_PPC_EMB_MRKREF"] = elf.R_PPC_EMB_MRKREF
	decs["R_PPC_EMB_NADDR16"] = elf.R_PPC_EMB_NADDR16
	decs["R_PPC_EMB_NADDR16_HA"] = elf.R_PPC_EMB_NADDR16_HA
	decs["R_PPC_EMB_NADDR16_HI"] = elf.R_PPC_EMB_NADDR16_HI
	decs["R_PPC_EMB_NADDR16_LO"] = elf.R_PPC_EMB_NADDR16_LO
	decs["R_PPC_EMB_NADDR32"] = elf.R_PPC_EMB_NADDR32
	decs["R_PPC_EMB_RELSDA"] = elf.R_PPC_EMB_RELSDA
	decs["R_PPC_EMB_RELSEC16"] = elf.R_PPC_EMB_RELSEC16
	decs["R_PPC_EMB_RELST_HA"] = elf.R_PPC_EMB_RELST_HA
	decs["R_PPC_EMB_RELST_HI"] = elf.R_PPC_EMB_RELST_HI
	decs["R_PPC_EMB_RELST_LO"] = elf.R_PPC_EMB_RELST_LO
	decs["R_PPC_EMB_SDA21"] = elf.R_PPC_EMB_SDA21
	decs["R_PPC_EMB_SDA2I16"] = elf.R_PPC_EMB_SDA2I16
	decs["R_PPC_EMB_SDA2REL"] = elf.R_PPC_EMB_SDA2REL
	decs["R_PPC_EMB_SDAI16"] = elf.R_PPC_EMB_SDAI16
	decs["R_PPC_GLOB_DAT"] = elf.R_PPC_GLOB_DAT
	decs["R_PPC_GOT16"] = elf.R_PPC_GOT16
	decs["R_PPC_GOT16_HA"] = elf.R_PPC_GOT16_HA
	decs["R_PPC_GOT16_HI"] = elf.R_PPC_GOT16_HI
	decs["R_PPC_GOT16_LO"] = elf.R_PPC_GOT16_LO
	decs["R_PPC_GOT_TLSGD16"] = elf.R_PPC_GOT_TLSGD16
	decs["R_PPC_GOT_TLSGD16_HA"] = elf.R_PPC_GOT_TLSGD16_HA
	decs["R_PPC_GOT_TLSGD16_HI"] = elf.R_PPC_GOT_TLSGD16_HI
	decs["R_PPC_GOT_TLSGD16_LO"] = elf.R_PPC_GOT_TLSGD16_LO
	decs["R_PPC_GOT_TLSLD16"] = elf.R_PPC_GOT_TLSLD16
	decs["R_PPC_GOT_TLSLD16_HA"] = elf.R_PPC_GOT_TLSLD16_HA
	decs["R_PPC_GOT_TLSLD16_HI"] = elf.R_PPC_GOT_TLSLD16_HI
	decs["R_PPC_GOT_TLSLD16_LO"] = elf.R_PPC_GOT_TLSLD16_LO
	decs["R_PPC_GOT_TPREL16"] = elf.R_PPC_GOT_TPREL16
	decs["R_PPC_GOT_TPREL16_HA"] = elf.R_PPC_GOT_TPREL16_HA
	decs["R_PPC_GOT_TPREL16_HI"] = elf.R_PPC_GOT_TPREL16_HI
	decs["R_PPC_GOT_TPREL16_LO"] = elf.R_PPC_GOT_TPREL16_LO
	decs["R_PPC_JMP_SLOT"] = elf.R_PPC_JMP_SLOT
	decs["R_PPC_LOCAL24PC"] = elf.R_PPC_LOCAL24PC
	decs["R_PPC_NONE"] = elf.R_PPC_NONE
	decs["R_PPC_PLT16_HA"] = elf.R_PPC_PLT16_HA
	decs["R_PPC_PLT16_HI"] = elf.R_PPC_PLT16_HI
	decs["R_PPC_PLT16_LO"] = elf.R_PPC_PLT16_LO
	decs["R_PPC_PLT32"] = elf.R_PPC_PLT32
	decs["R_PPC_PLTREL24"] = elf.R_PPC_PLTREL24
	decs["R_PPC_PLTREL32"] = elf.R_PPC_PLTREL32
	decs["R_PPC_REL14"] = elf.R_PPC_REL14
	decs["R_PPC_REL14_BRNTAKEN"] = elf.R_PPC_REL14_BRNTAKEN
	decs["R_PPC_REL14_BRTAKEN"] = elf.R_PPC_REL14_BRTAKEN
	decs["R_PPC_REL24"] = elf.R_PPC_REL24
	decs["R_PPC_REL32"] = elf.R_PPC_REL32
	decs["R_PPC_RELATIVE"] = elf.R_PPC_RELATIVE
	decs["R_PPC_SDAREL16"] = elf.R_PPC_SDAREL16
	decs["R_PPC_SECTOFF"] = elf.R_PPC_SECTOFF
	decs["R_PPC_SECTOFF_HA"] = elf.R_PPC_SECTOFF_HA
	decs["R_PPC_SECTOFF_HI"] = elf.R_PPC_SECTOFF_HI
	decs["R_PPC_SECTOFF_LO"] = elf.R_PPC_SECTOFF_LO
	decs["R_PPC_TLS"] = elf.R_PPC_TLS
	decs["R_PPC_TPREL16"] = elf.R_PPC_TPREL16
	decs["R_PPC_TPREL16_HA"] = elf.R_PPC_TPREL16_HA
	decs["R_PPC_TPREL16_HI"] = elf.R_PPC_TPREL16_HI
	decs["R_PPC_TPREL16_LO"] = elf.R_PPC_TPREL16_LO
	decs["R_PPC_TPREL32"] = elf.R_PPC_TPREL32
	decs["R_PPC_UADDR16"] = elf.R_PPC_UADDR16
	decs["R_PPC_UADDR32"] = elf.R_PPC_UADDR32
	decs["R_RISCV"] = reflect.TypeOf((*elf.R_RISCV)(nil)).Elem()
	decs["R_RISCV_32"] = elf.R_RISCV_32
	decs["R_RISCV_32_PCREL"] = elf.R_RISCV_32_PCREL
	decs["R_RISCV_64"] = elf.R_RISCV_64
	decs["R_RISCV_ADD16"] = elf.R_RISCV_ADD16
	decs["R_RISCV_ADD32"] = elf.R_RISCV_ADD32
	decs["R_RISCV_ADD64"] = elf.R_RISCV_ADD64
	decs["R_RISCV_ADD8"] = elf.R_RISCV_ADD8
	decs["R_RISCV_ALIGN"] = elf.R_RISCV_ALIGN
	decs["R_RISCV_BRANCH"] = elf.R_RISCV_BRANCH
	decs["R_RISCV_CALL"] = elf.R_RISCV_CALL
	decs["R_RISCV_CALL_PLT"] = elf.R_RISCV_CALL_PLT
	decs["R_RISCV_COPY"] = elf.R_RISCV_COPY
	decs["R_RISCV_GNU_VTENTRY"] = elf.R_RISCV_GNU_VTENTRY
	decs["R_RISCV_GNU_VTINHERIT"] = elf.R_RISCV_GNU_VTINHERIT
	decs["R_RISCV_GOT_HI20"] = elf.R_RISCV_GOT_HI20
	decs["R_RISCV_GPREL_I"] = elf.R_RISCV_GPREL_I
	decs["R_RISCV_GPREL_S"] = elf.R_RISCV_GPREL_S
	decs["R_RISCV_HI20"] = elf.R_RISCV_HI20
	decs["R_RISCV_JAL"] = elf.R_RISCV_JAL
	decs["R_RISCV_JUMP_SLOT"] = elf.R_RISCV_JUMP_SLOT
	decs["R_RISCV_LO12_I"] = elf.R_RISCV_LO12_I
	decs["R_RISCV_LO12_S"] = elf.R_RISCV_LO12_S
	decs["R_RISCV_NONE"] = elf.R_RISCV_NONE
	decs["R_RISCV_PCREL_HI20"] = elf.R_RISCV_PCREL_HI20
	decs["R_RISCV_PCREL_LO12_I"] = elf.R_RISCV_PCREL_LO12_I
	decs["R_RISCV_PCREL_LO12_S"] = elf.R_RISCV_PCREL_LO12_S
	decs["R_RISCV_RELATIVE"] = elf.R_RISCV_RELATIVE
	decs["R_RISCV_RELAX"] = elf.R_RISCV_RELAX
	decs["R_RISCV_RVC_BRANCH"] = elf.R_RISCV_RVC_BRANCH
	decs["R_RISCV_RVC_JUMP"] = elf.R_RISCV_RVC_JUMP
	decs["R_RISCV_RVC_LUI"] = elf.R_RISCV_RVC_LUI
	decs["R_RISCV_SET16"] = elf.R_RISCV_SET16
	decs["R_RISCV_SET32"] = elf.R_RISCV_SET32
	decs["R_RISCV_SET6"] = elf.R_RISCV_SET6
	decs["R_RISCV_SET8"] = elf.R_RISCV_SET8
	decs["R_RISCV_SUB16"] = elf.R_RISCV_SUB16
	decs["R_RISCV_SUB32"] = elf.R_RISCV_SUB32
	decs["R_RISCV_SUB6"] = elf.R_RISCV_SUB6
	decs["R_RISCV_SUB64"] = elf.R_RISCV_SUB64
	decs["R_RISCV_SUB8"] = elf.R_RISCV_SUB8
	decs["R_RISCV_TLS_DTPMOD32"] = elf.R_RISCV_TLS_DTPMOD32
	decs["R_RISCV_TLS_DTPMOD64"] = elf.R_RISCV_TLS_DTPMOD64
	decs["R_RISCV_TLS_DTPREL32"] = elf.R_RISCV_TLS_DTPREL32
	decs["R_RISCV_TLS_DTPREL64"] = elf.R_RISCV_TLS_DTPREL64
	decs["R_RISCV_TLS_GD_HI20"] = elf.R_RISCV_TLS_GD_HI20
	decs["R_RISCV_TLS_GOT_HI20"] = elf.R_RISCV_TLS_GOT_HI20
	decs["R_RISCV_TLS_TPREL32"] = elf.R_RISCV_TLS_TPREL32
	decs["R_RISCV_TLS_TPREL64"] = elf.R_RISCV_TLS_TPREL64
	decs["R_RISCV_TPREL_ADD"] = elf.R_RISCV_TPREL_ADD
	decs["R_RISCV_TPREL_HI20"] = elf.R_RISCV_TPREL_HI20
	decs["R_RISCV_TPREL_I"] = elf.R_RISCV_TPREL_I
	decs["R_RISCV_TPREL_LO12_I"] = elf.R_RISCV_TPREL_LO12_I
	decs["R_RISCV_TPREL_LO12_S"] = elf.R_RISCV_TPREL_LO12_S
	decs["R_RISCV_TPREL_S"] = elf.R_RISCV_TPREL_S
	decs["R_SPARC"] = reflect.TypeOf((*elf.R_SPARC)(nil)).Elem()
	decs["R_SPARC_10"] = elf.R_SPARC_10
	decs["R_SPARC_11"] = elf.R_SPARC_11
	decs["R_SPARC_13"] = elf.R_SPARC_13
	decs["R_SPARC_16"] = elf.R_SPARC_16
	decs["R_SPARC_22"] = elf.R_SPARC_22
	decs["R_SPARC_32"] = elf.R_SPARC_32
	decs["R_SPARC_5"] = elf.R_SPARC_5
	decs["R_SPARC_6"] = elf.R_SPARC_6
	decs["R_SPARC_64"] = elf.R_SPARC_64
	decs["R_SPARC_7"] = elf.R_SPARC_7
	decs["R_SPARC_8"] = elf.R_SPARC_8
	decs["R_SPARC_COPY"] = elf.R_SPARC_COPY
	decs["R_SPARC_DISP16"] = elf.R_SPARC_DISP16
	decs["R_SPARC_DISP32"] = elf.R_SPARC_DISP32
	decs["R_SPARC_DISP64"] = elf.R_SPARC_DISP64
	decs["R_SPARC_DISP8"] = elf.R_SPARC_DISP8
	decs["R_SPARC_GLOB_DAT"] = elf.R_SPARC_GLOB_DAT
	decs["R_SPARC_GLOB_JMP"] = elf.R_SPARC_GLOB_JMP
	decs["R_SPARC_GOT10"] = elf.R_SPARC_GOT10
	decs["R_SPARC_GOT13"] = elf.R_SPARC_GOT13
	decs["R_SPARC_GOT22"] = elf.R_SPARC_GOT22
	decs["R_SPARC_H44"] = elf.R_SPARC_H44
	decs["R_SPARC_HH22"] = elf.R_SPARC_HH22
	decs["R_SPARC_HI22"] = elf.R_SPARC_HI22
	decs["R_SPARC_HIPLT22"] = elf.R_SPARC_HIPLT22
	decs["R_SPARC_HIX22"] = elf.R_SPARC_HIX22
	decs["R_SPARC_HM10"] = elf.R_SPARC_HM10
	decs["R_SPARC_JMP_SLOT"] = elf.R_SPARC_JMP_SLOT
	decs["R_SPARC_L44"] = elf.R_SPARC_L44
	decs["R_SPARC_LM22"] = elf.R_SPARC_LM22
	decs["R_SPARC_LO10"] = elf.R_SPARC_LO10
	decs["R_SPARC_LOPLT10"] = elf.R_SPARC_LOPLT10
	decs["R_SPARC_LOX10"] = elf.R_SPARC_LOX10
	decs["R_SPARC_M44"] = elf.R_SPARC_M44
	decs["R_SPARC_NONE"] = elf.R_SPARC_NONE
	decs["R_SPARC_OLO10"] = elf.R_SPARC_OLO10
	decs["R_SPARC_PC10"] = elf.R_SPARC_PC10
	decs["R_SPARC_PC22"] = elf.R_SPARC_PC22
	decs["R_SPARC_PCPLT10"] = elf.R_SPARC_PCPLT10
	decs["R_SPARC_PCPLT22"] = elf.R_SPARC_PCPLT22
	decs["R_SPARC_PCPLT32"] = elf.R_SPARC_PCPLT32
	decs["R_SPARC_PC_HH22"] = elf.R_SPARC_PC_HH22
	decs["R_SPARC_PC_HM10"] = elf.R_SPARC_PC_HM10
	decs["R_SPARC_PC_LM22"] = elf.R_SPARC_PC_LM22
	decs["R_SPARC_PLT32"] = elf.R_SPARC_PLT32
	decs["R_SPARC_PLT64"] = elf.R_SPARC_PLT64
	decs["R_SPARC_REGISTER"] = elf.R_SPARC_REGISTER
	decs["R_SPARC_RELATIVE"] = elf.R_SPARC_RELATIVE
	decs["R_SPARC_UA16"] = elf.R_SPARC_UA16
	decs["R_SPARC_UA32"] = elf.R_SPARC_UA32
	decs["R_SPARC_UA64"] = elf.R_SPARC_UA64
	decs["R_SPARC_WDISP16"] = elf.R_SPARC_WDISP16
	decs["R_SPARC_WDISP19"] = elf.R_SPARC_WDISP19
	decs["R_SPARC_WDISP22"] = elf.R_SPARC_WDISP22
	decs["R_SPARC_WDISP30"] = elf.R_SPARC_WDISP30
	decs["R_SPARC_WPLT30"] = elf.R_SPARC_WPLT30
	decs["R_SYM32"] = elf.R_SYM32
	decs["R_SYM64"] = elf.R_SYM64
	decs["R_TYPE32"] = elf.R_TYPE32
	decs["R_TYPE64"] = elf.R_TYPE64
	decs["R_X86_64"] = reflect.TypeOf((*elf.R_X86_64)(nil)).Elem()
	decs["R_X86_64_16"] = elf.R_X86_64_16
	decs["R_X86_64_32"] = elf.R_X86_64_32
	decs["R_X86_64_32S"] = elf.R_X86_64_32S
	decs["R_X86_64_64"] = elf.R_X86_64_64
	decs["R_X86_64_8"] = elf.R_X86_64_8
	decs["R_X86_64_COPY"] = elf.R_X86_64_COPY
	decs["R_X86_64_DTPMOD64"] = elf.R_X86_64_DTPMOD64
	decs["R_X86_64_DTPOFF32"] = elf.R_X86_64_DTPOFF32
	decs["R_X86_64_DTPOFF64"] = elf.R_X86_64_DTPOFF64
	decs["R_X86_64_GLOB_DAT"] = elf.R_X86_64_GLOB_DAT
	decs["R_X86_64_GOT32"] = elf.R_X86_64_GOT32
	decs["R_X86_64_GOT64"] = elf.R_X86_64_GOT64
	decs["R_X86_64_GOTOFF64"] = elf.R_X86_64_GOTOFF64
	decs["R_X86_64_GOTPC32"] = elf.R_X86_64_GOTPC32
	decs["R_X86_64_GOTPC32_TLSDESC"] = elf.R_X86_64_GOTPC32_TLSDESC
	decs["R_X86_64_GOTPC64"] = elf.R_X86_64_GOTPC64
	decs["R_X86_64_GOTPCREL"] = elf.R_X86_64_GOTPCREL
	decs["R_X86_64_GOTPCREL64"] = elf.R_X86_64_GOTPCREL64
	decs["R_X86_64_GOTPCRELX"] = elf.R_X86_64_GOTPCRELX
	decs["R_X86_64_GOTPLT64"] = elf.R_X86_64_GOTPLT64
	decs["R_X86_64_GOTTPOFF"] = elf.R_X86_64_GOTTPOFF
	decs["R_X86_64_IRELATIVE"] = elf.R_X86_64_IRELATIVE
	decs["R_X86_64_JMP_SLOT"] = elf.R_X86_64_JMP_SLOT
	decs["R_X86_64_NONE"] = elf.R_X86_64_NONE
	decs["R_X86_64_PC16"] = elf.R_X86_64_PC16
	decs["R_X86_64_PC32"] = elf.R_X86_64_PC32
	decs["R_X86_64_PC32_BND"] = elf.R_X86_64_PC32_BND
	decs["R_X86_64_PC64"] = elf.R_X86_64_PC64
	decs["R_X86_64_PC8"] = elf.R_X86_64_PC8
	decs["R_X86_64_PLT32"] = elf.R_X86_64_PLT32
	decs["R_X86_64_PLT32_BND"] = elf.R_X86_64_PLT32_BND
	decs["R_X86_64_PLTOFF64"] = elf.R_X86_64_PLTOFF64
	decs["R_X86_64_RELATIVE"] = elf.R_X86_64_RELATIVE
	decs["R_X86_64_RELATIVE64"] = elf.R_X86_64_RELATIVE64
	decs["R_X86_64_REX_GOTPCRELX"] = elf.R_X86_64_REX_GOTPCRELX
	decs["R_X86_64_SIZE32"] = elf.R_X86_64_SIZE32
	decs["R_X86_64_SIZE64"] = elf.R_X86_64_SIZE64
	decs["R_X86_64_TLSDESC"] = elf.R_X86_64_TLSDESC
	decs["R_X86_64_TLSDESC_CALL"] = elf.R_X86_64_TLSDESC_CALL
	decs["R_X86_64_TLSGD"] = elf.R_X86_64_TLSGD
	decs["R_X86_64_TLSLD"] = elf.R_X86_64_TLSLD
	decs["R_X86_64_TPOFF32"] = elf.R_X86_64_TPOFF32
	decs["R_X86_64_TPOFF64"] = elf.R_X86_64_TPOFF64
	decs["Rel32"] = reflect.TypeOf((*elf.Rel32)(nil)).Elem()
	decs["Rel64"] = reflect.TypeOf((*elf.Rel64)(nil)).Elem()
	decs["Rela32"] = reflect.TypeOf((*elf.Rela32)(nil)).Elem()
	decs["Rela64"] = reflect.TypeOf((*elf.Rela64)(nil)).Elem()
	decs["SHF_ALLOC"] = elf.SHF_ALLOC
	decs["SHF_COMPRESSED"] = elf.SHF_COMPRESSED
	decs["SHF_EXECINSTR"] = elf.SHF_EXECINSTR
	decs["SHF_GROUP"] = elf.SHF_GROUP
	decs["SHF_INFO_LINK"] = elf.SHF_INFO_LINK
	decs["SHF_LINK_ORDER"] = elf.SHF_LINK_ORDER
	decs["SHF_MASKOS"] = elf.SHF_MASKOS
	decs["SHF_MASKPROC"] = elf.SHF_MASKPROC
	decs["SHF_MERGE"] = elf.SHF_MERGE
	decs["SHF_OS_NONCONFORMING"] = elf.SHF_OS_NONCONFORMING
	decs["SHF_STRINGS"] = elf.SHF_STRINGS
	decs["SHF_TLS"] = elf.SHF_TLS
	decs["SHF_WRITE"] = elf.SHF_WRITE
	decs["SHN_ABS"] = elf.SHN_ABS
	decs["SHN_COMMON"] = elf.SHN_COMMON
	decs["SHN_HIOS"] = elf.SHN_HIOS
	decs["SHN_HIPROC"] = elf.SHN_HIPROC
	decs["SHN_HIRESERVE"] = elf.SHN_HIRESERVE
	decs["SHN_LOOS"] = elf.SHN_LOOS
	decs["SHN_LOPROC"] = elf.SHN_LOPROC
	decs["SHN_LORESERVE"] = elf.SHN_LORESERVE
	decs["SHN_UNDEF"] = elf.SHN_UNDEF
	decs["SHN_XINDEX"] = elf.SHN_XINDEX
	decs["SHT_DYNAMIC"] = elf.SHT_DYNAMIC
	decs["SHT_DYNSYM"] = elf.SHT_DYNSYM
	decs["SHT_FINI_ARRAY"] = elf.SHT_FINI_ARRAY
	decs["SHT_GNU_ATTRIBUTES"] = elf.SHT_GNU_ATTRIBUTES
	decs["SHT_GNU_HASH"] = elf.SHT_GNU_HASH
	decs["SHT_GNU_LIBLIST"] = elf.SHT_GNU_LIBLIST
	decs["SHT_GNU_VERDEF"] = elf.SHT_GNU_VERDEF
	decs["SHT_GNU_VERNEED"] = elf.SHT_GNU_VERNEED
	decs["SHT_GNU_VERSYM"] = elf.SHT_GNU_VERSYM
	decs["SHT_GROUP"] = elf.SHT_GROUP
	decs["SHT_HASH"] = elf.SHT_HASH
	decs["SHT_HIOS"] = elf.SHT_HIOS
	decs["SHT_HIPROC"] = elf.SHT_HIPROC
	decs["SHT_HIUSER"] = elf.SHT_HIUSER
	decs["SHT_INIT_ARRAY"] = elf.SHT_INIT_ARRAY
	decs["SHT_LOOS"] = elf.SHT_LOOS
	decs["SHT_LOPROC"] = elf.SHT_LOPROC
	decs["SHT_LOUSER"] = elf.SHT_LOUSER
	decs["SHT_NOBITS"] = elf.SHT_NOBITS
	decs["SHT_NOTE"] = elf.SHT_NOTE
	decs["SHT_NULL"] = elf.SHT_NULL
	decs["SHT_PREINIT_ARRAY"] = elf.SHT_PREINIT_ARRAY
	decs["SHT_PROGBITS"] = elf.SHT_PROGBITS
	decs["SHT_REL"] = elf.SHT_REL
	decs["SHT_RELA"] = elf.SHT_RELA
	decs["SHT_SHLIB"] = elf.SHT_SHLIB
	decs["SHT_STRTAB"] = elf.SHT_STRTAB
	decs["SHT_SYMTAB"] = elf.SHT_SYMTAB
	decs["SHT_SYMTAB_SHNDX"] = elf.SHT_SYMTAB_SHNDX
	decs["STB_GLOBAL"] = elf.STB_GLOBAL
	decs["STB_HIOS"] = elf.STB_HIOS
	decs["STB_HIPROC"] = elf.STB_HIPROC
	decs["STB_LOCAL"] = elf.STB_LOCAL
	decs["STB_LOOS"] = elf.STB_LOOS
	decs["STB_LOPROC"] = elf.STB_LOPROC
	decs["STB_WEAK"] = elf.STB_WEAK
	decs["STT_COMMON"] = elf.STT_COMMON
	decs["STT_FILE"] = elf.STT_FILE
	decs["STT_FUNC"] = elf.STT_FUNC
	decs["STT_HIOS"] = elf.STT_HIOS
	decs["STT_HIPROC"] = elf.STT_HIPROC
	decs["STT_LOOS"] = elf.STT_LOOS
	decs["STT_LOPROC"] = elf.STT_LOPROC
	decs["STT_NOTYPE"] = elf.STT_NOTYPE
	decs["STT_OBJECT"] = elf.STT_OBJECT
	decs["STT_SECTION"] = elf.STT_SECTION
	decs["STT_TLS"] = elf.STT_TLS
	decs["STV_DEFAULT"] = elf.STV_DEFAULT
	decs["STV_HIDDEN"] = elf.STV_HIDDEN
	decs["STV_INTERNAL"] = elf.STV_INTERNAL
	decs["STV_PROTECTED"] = elf.STV_PROTECTED
	decs["ST_BIND"] = elf.ST_BIND
	decs["ST_INFO"] = elf.ST_INFO
	decs["ST_TYPE"] = elf.ST_TYPE
	decs["ST_VISIBILITY"] = elf.ST_VISIBILITY
	decs["Section"] = reflect.TypeOf((*elf.Section)(nil)).Elem()
	decs["Section32"] = reflect.TypeOf((*elf.Section32)(nil)).Elem()
	decs["Section64"] = reflect.TypeOf((*elf.Section64)(nil)).Elem()
	decs["SectionFlag"] = reflect.TypeOf((*elf.SectionFlag)(nil)).Elem()
	decs["SectionHeader"] = reflect.TypeOf((*elf.SectionHeader)(nil)).Elem()
	decs["SectionIndex"] = reflect.TypeOf((*elf.SectionIndex)(nil)).Elem()
	decs["SectionType"] = reflect.TypeOf((*elf.SectionType)(nil)).Elem()
	decs["Sym32"] = reflect.TypeOf((*elf.Sym32)(nil)).Elem()
	decs["Sym32Size"] = UntypedNumericConst("16")
	decs["Sym64"] = reflect.TypeOf((*elf.Sym64)(nil)).Elem()
	decs["Sym64Size"] = UntypedNumericConst("24")
	decs["SymBind"] = reflect.TypeOf((*elf.SymBind)(nil)).Elem()
	decs["SymType"] = reflect.TypeOf((*elf.SymType)(nil)).Elem()
	decs["SymVis"] = reflect.TypeOf((*elf.SymVis)(nil)).Elem()
	decs["Symbol"] = reflect.TypeOf((*elf.Symbol)(nil)).Elem()
	decs["Type"] = reflect.TypeOf((*elf.Type)(nil)).Elem()
	decs["Version"] = reflect.TypeOf((*elf.Version)(nil)).Elem()
	packages["debug/elf"] = &MapPackage{
		PkgName: "elf",
		Declarations: decs,
	}
	// "debug/gosym"
	decs = make(map[string]interface{}, 10)
	decs["DecodingError"] = reflect.TypeOf((*gosym.DecodingError)(nil)).Elem()
	decs["Func"] = reflect.TypeOf((*gosym.Func)(nil)).Elem()
	decs["LineTable"] = reflect.TypeOf((*gosym.LineTable)(nil)).Elem()
	decs["NewLineTable"] = gosym.NewLineTable
	decs["NewTable"] = gosym.NewTable
	decs["Obj"] = reflect.TypeOf((*gosym.Obj)(nil)).Elem()
	decs["Sym"] = reflect.TypeOf((*gosym.Sym)(nil)).Elem()
	decs["Table"] = reflect.TypeOf((*gosym.Table)(nil)).Elem()
	decs["UnknownFileError"] = reflect.TypeOf((*gosym.UnknownFileError)(nil)).Elem()
	decs["UnknownLineError"] = reflect.TypeOf((*gosym.UnknownLineError)(nil)).Elem()
	packages["debug/gosym"] = &MapPackage{
		PkgName: "gosym",
		Declarations: decs,
	}
	// "debug/macho"
	decs = make(map[string]interface{}, 128)
	decs["ARM64_RELOC_ADDEND"] = macho.ARM64_RELOC_ADDEND
	decs["ARM64_RELOC_BRANCH26"] = macho.ARM64_RELOC_BRANCH26
	decs["ARM64_RELOC_GOT_LOAD_PAGE21"] = macho.ARM64_RELOC_GOT_LOAD_PAGE21
	decs["ARM64_RELOC_GOT_LOAD_PAGEOFF12"] = macho.ARM64_RELOC_GOT_LOAD_PAGEOFF12
	decs["ARM64_RELOC_PAGE21"] = macho.ARM64_RELOC_PAGE21
	decs["ARM64_RELOC_PAGEOFF12"] = macho.ARM64_RELOC_PAGEOFF12
	decs["ARM64_RELOC_POINTER_TO_GOT"] = macho.ARM64_RELOC_POINTER_TO_GOT
	decs["ARM64_RELOC_SUBTRACTOR"] = macho.ARM64_RELOC_SUBTRACTOR
	decs["ARM64_RELOC_TLVP_LOAD_PAGE21"] = macho.ARM64_RELOC_TLVP_LOAD_PAGE21
	decs["ARM64_RELOC_TLVP_LOAD_PAGEOFF12"] = macho.ARM64_RELOC_TLVP_LOAD_PAGEOFF12
	decs["ARM64_RELOC_UNSIGNED"] = macho.ARM64_RELOC_UNSIGNED
	decs["ARM_RELOC_BR24"] = macho.ARM_RELOC_BR24
	decs["ARM_RELOC_HALF"] = macho.ARM_RELOC_HALF
	decs["ARM_RELOC_HALF_SECTDIFF"] = macho.ARM_RELOC_HALF_SECTDIFF
	decs["ARM_RELOC_LOCAL_SECTDIFF"] = macho.ARM_RELOC_LOCAL_SECTDIFF
	decs["ARM_RELOC_PAIR"] = macho.ARM_RELOC_PAIR
	decs["ARM_RELOC_PB_LA_PTR"] = macho.ARM_RELOC_PB_LA_PTR
	decs["ARM_RELOC_SECTDIFF"] = macho.ARM_RELOC_SECTDIFF
	decs["ARM_RELOC_VANILLA"] = macho.ARM_RELOC_VANILLA
	decs["ARM_THUMB_32BIT_BRANCH"] = macho.ARM_THUMB_32BIT_BRANCH
	decs["ARM_THUMB_RELOC_BR22"] = macho.ARM_THUMB_RELOC_BR22
	decs["Cpu"] = reflect.TypeOf((*macho.Cpu)(nil)).Elem()
	decs["Cpu386"] = macho.Cpu386
	decs["CpuAmd64"] = macho.CpuAmd64
	decs["CpuArm"] = macho.CpuArm
	decs["CpuArm64"] = macho.CpuArm64
	decs["CpuPpc"] = macho.CpuPpc
	decs["CpuPpc64"] = macho.CpuPpc64
	decs["Dylib"] = reflect.TypeOf((*macho.Dylib)(nil)).Elem()
	decs["DylibCmd"] = reflect.TypeOf((*macho.DylibCmd)(nil)).Elem()
	decs["Dysymtab"] = reflect.TypeOf((*macho.Dysymtab)(nil)).Elem()
	decs["DysymtabCmd"] = reflect.TypeOf((*macho.DysymtabCmd)(nil)).Elem()
	decs["ErrNotFat"] = &macho.ErrNotFat
	decs["FatArch"] = reflect.TypeOf((*macho.FatArch)(nil)).Elem()
	decs["FatArchHeader"] = reflect.TypeOf((*macho.FatArchHeader)(nil)).Elem()
	decs["FatFile"] = reflect.TypeOf((*macho.FatFile)(nil)).Elem()
	decs["File"] = reflect.TypeOf((*macho.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*macho.FileHeader)(nil)).Elem()
	decs["FlagAllModsBound"] = macho.FlagAllModsBound
	decs["FlagAllowStackExecution"] = macho.FlagAllowStackExecution
	decs["FlagAppExtensionSafe"] = macho.FlagAppExtensionSafe
	decs["FlagBindAtLoad"] = macho.FlagBindAtLoad
	decs["FlagBindsToWeak"] = macho.FlagBindsToWeak
	decs["FlagCanonical"] = macho.FlagCanonical
	decs["FlagDeadStrippableDylib"] = macho.FlagDeadStrippableDylib
	decs["FlagDyldLink"] = macho.FlagDyldLink
	decs["FlagForceFlat"] = macho.FlagForceFlat
	decs["FlagHasTLVDescriptors"] = macho.FlagHasTLVDescriptors
	decs["FlagIncrLink"] = macho.FlagIncrLink
	decs["FlagLazyInit"] = macho.FlagLazyInit
	decs["FlagNoFixPrebinding"] = macho.FlagNoFixPrebinding
	decs["FlagNoHeapExecution"] = macho.FlagNoHeapExecution
	decs["FlagNoMultiDefs"] = macho.FlagNoMultiDefs
	decs["FlagNoReexportedDylibs"] = macho.FlagNoReexportedDylibs
	decs["FlagNoUndefs"] = macho.FlagNoUndefs
	decs["FlagPIE"] = macho.FlagPIE
	decs["FlagPrebindable"] = macho.FlagPrebindable
	decs["FlagPrebound"] = macho.FlagPrebound
	decs["FlagRootSafe"] = macho.FlagRootSafe
	decs["FlagSetuidSafe"] = macho.FlagSetuidSafe
	decs["FlagSplitSegs"] = macho.FlagSplitSegs
	decs["FlagSubsectionsViaSymbols"] = macho.FlagSubsectionsViaSymbols
	decs["FlagTwoLevel"] = macho.FlagTwoLevel
	decs["FlagWeakDefines"] = macho.FlagWeakDefines
	decs["FormatError"] = reflect.TypeOf((*macho.FormatError)(nil)).Elem()
	decs["GENERIC_RELOC_LOCAL_SECTDIFF"] = macho.GENERIC_RELOC_LOCAL_SECTDIFF
	decs["GENERIC_RELOC_PAIR"] = macho.GENERIC_RELOC_PAIR
	decs["GENERIC_RELOC_PB_LA_PTR"] = macho.GENERIC_RELOC_PB_LA_PTR
	decs["GENERIC_RELOC_SECTDIFF"] = macho.GENERIC_RELOC_SECTDIFF
	decs["GENERIC_RELOC_TLV"] = macho.GENERIC_RELOC_TLV
	decs["GENERIC_RELOC_VANILLA"] = macho.GENERIC_RELOC_VANILLA
	decs["Load"] = reflect.TypeOf((*macho.Load)(nil)).Elem()
	decs["LoadBytes"] = reflect.TypeOf((*macho.LoadBytes)(nil)).Elem()
	decs["LoadCmd"] = reflect.TypeOf((*macho.LoadCmd)(nil)).Elem()
	decs["LoadCmdDylib"] = macho.LoadCmdDylib
	decs["LoadCmdDylinker"] = macho.LoadCmdDylinker
	decs["LoadCmdDysymtab"] = macho.LoadCmdDysymtab
	decs["LoadCmdRpath"] = macho.LoadCmdRpath
	decs["LoadCmdSegment"] = macho.LoadCmdSegment
	decs["LoadCmdSegment64"] = macho.LoadCmdSegment64
	decs["LoadCmdSymtab"] = macho.LoadCmdSymtab
	decs["LoadCmdThread"] = macho.LoadCmdThread
	decs["LoadCmdUnixThread"] = macho.LoadCmdUnixThread
	decs["Magic32"] = macho.Magic32
	decs["Magic64"] = macho.Magic64
	decs["MagicFat"] = macho.MagicFat
	decs["NewFatFile"] = macho.NewFatFile
	decs["NewFile"] = macho.NewFile
	decs["Nlist32"] = reflect.TypeOf((*macho.Nlist32)(nil)).Elem()
	decs["Nlist64"] = reflect.TypeOf((*macho.Nlist64)(nil)).Elem()
	decs["Open"] = macho.Open
	decs["OpenFat"] = macho.OpenFat
	decs["Regs386"] = reflect.TypeOf((*macho.Regs386)(nil)).Elem()
	decs["RegsAMD64"] = reflect.TypeOf((*macho.RegsAMD64)(nil)).Elem()
	decs["Reloc"] = reflect.TypeOf((*macho.Reloc)(nil)).Elem()
	decs["RelocTypeARM"] = reflect.TypeOf((*macho.RelocTypeARM)(nil)).Elem()
	decs["RelocTypeARM64"] = reflect.TypeOf((*macho.RelocTypeARM64)(nil)).Elem()
	decs["RelocTypeGeneric"] = reflect.TypeOf((*macho.RelocTypeGeneric)(nil)).Elem()
	decs["RelocTypeX86_64"] = reflect.TypeOf((*macho.RelocTypeX86_64)(nil)).Elem()
	decs["Rpath"] = reflect.TypeOf((*macho.Rpath)(nil)).Elem()
	decs["RpathCmd"] = reflect.TypeOf((*macho.RpathCmd)(nil)).Elem()
	decs["Section"] = reflect.TypeOf((*macho.Section)(nil)).Elem()
	decs["Section32"] = reflect.TypeOf((*macho.Section32)(nil)).Elem()
	decs["Section64"] = reflect.TypeOf((*macho.Section64)(nil)).Elem()
	decs["SectionHeader"] = reflect.TypeOf((*macho.SectionHeader)(nil)).Elem()
	decs["Segment"] = reflect.TypeOf((*macho.Segment)(nil)).Elem()
	decs["Segment32"] = reflect.TypeOf((*macho.Segment32)(nil)).Elem()
	decs["Segment64"] = reflect.TypeOf((*macho.Segment64)(nil)).Elem()
	decs["SegmentHeader"] = reflect.TypeOf((*macho.SegmentHeader)(nil)).Elem()
	decs["Symbol"] = reflect.TypeOf((*macho.Symbol)(nil)).Elem()
	decs["Symtab"] = reflect.TypeOf((*macho.Symtab)(nil)).Elem()
	decs["SymtabCmd"] = reflect.TypeOf((*macho.SymtabCmd)(nil)).Elem()
	decs["Thread"] = reflect.TypeOf((*macho.Thread)(nil)).Elem()
	decs["Type"] = reflect.TypeOf((*macho.Type)(nil)).Elem()
	decs["TypeBundle"] = macho.TypeBundle
	decs["TypeDylib"] = macho.TypeDylib
	decs["TypeExec"] = macho.TypeExec
	decs["TypeObj"] = macho.TypeObj
	decs["X86_64_RELOC_BRANCH"] = macho.X86_64_RELOC_BRANCH
	decs["X86_64_RELOC_GOT"] = macho.X86_64_RELOC_GOT
	decs["X86_64_RELOC_GOT_LOAD"] = macho.X86_64_RELOC_GOT_LOAD
	decs["X86_64_RELOC_SIGNED"] = macho.X86_64_RELOC_SIGNED
	decs["X86_64_RELOC_SIGNED_1"] = macho.X86_64_RELOC_SIGNED_1
	decs["X86_64_RELOC_SIGNED_2"] = macho.X86_64_RELOC_SIGNED_2
	decs["X86_64_RELOC_SIGNED_4"] = macho.X86_64_RELOC_SIGNED_4
	decs["X86_64_RELOC_SUBTRACTOR"] = macho.X86_64_RELOC_SUBTRACTOR
	decs["X86_64_RELOC_TLV"] = macho.X86_64_RELOC_TLV
	decs["X86_64_RELOC_UNSIGNED"] = macho.X86_64_RELOC_UNSIGNED
	packages["debug/macho"] = &MapPackage{
		PkgName: "macho",
		Declarations: decs,
	}
	// "debug/pe"
	decs = make(map[string]interface{}, 94)
	decs["COFFSymbol"] = reflect.TypeOf((*pe.COFFSymbol)(nil)).Elem()
	decs["COFFSymbolSize"] = UntypedNumericConst("18")
	decs["DataDirectory"] = reflect.TypeOf((*pe.DataDirectory)(nil)).Elem()
	decs["File"] = reflect.TypeOf((*pe.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*pe.FileHeader)(nil)).Elem()
	decs["FormatError"] = reflect.TypeOf((*pe.FormatError)(nil)).Elem()
	decs["IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"] = UntypedNumericConst("7")
	decs["IMAGE_DIRECTORY_ENTRY_BASERELOC"] = UntypedNumericConst("5")
	decs["IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"] = UntypedNumericConst("11")
	decs["IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"] = UntypedNumericConst("14")
	decs["IMAGE_DIRECTORY_ENTRY_DEBUG"] = UntypedNumericConst("6")
	decs["IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"] = UntypedNumericConst("13")
	decs["IMAGE_DIRECTORY_ENTRY_EXCEPTION"] = UntypedNumericConst("3")
	decs["IMAGE_DIRECTORY_ENTRY_EXPORT"] = UntypedNumericConst("0")
	decs["IMAGE_DIRECTORY_ENTRY_GLOBALPTR"] = UntypedNumericConst("8")
	decs["IMAGE_DIRECTORY_ENTRY_IAT"] = UntypedNumericConst("12")
	decs["IMAGE_DIRECTORY_ENTRY_IMPORT"] = UntypedNumericConst("1")
	decs["IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG"] = UntypedNumericConst("10")
	decs["IMAGE_DIRECTORY_ENTRY_RESOURCE"] = UntypedNumericConst("2")
	decs["IMAGE_DIRECTORY_ENTRY_SECURITY"] = UntypedNumericConst("4")
	decs["IMAGE_DIRECTORY_ENTRY_TLS"] = UntypedNumericConst("9")
	decs["IMAGE_DLLCHARACTERISTICS_APPCONTAINER"] = UntypedNumericConst("4096")
	decs["IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE"] = UntypedNumericConst("64")
	decs["IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY"] = UntypedNumericConst("128")
	decs["IMAGE_DLLCHARACTERISTICS_GUARD_CF"] = UntypedNumericConst("16384")
	decs["IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA"] = UntypedNumericConst("32")
	decs["IMAGE_DLLCHARACTERISTICS_NO_BIND"] = UntypedNumericConst("2048")
	decs["IMAGE_DLLCHARACTERISTICS_NO_ISOLATION"] = UntypedNumericConst("512")
	decs["IMAGE_DLLCHARACTERISTICS_NO_SEH"] = UntypedNumericConst("1024")
	decs["IMAGE_DLLCHARACTERISTICS_NX_COMPAT"] = UntypedNumericConst("256")
	decs["IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE"] = UntypedNumericConst("32768")
	decs["IMAGE_DLLCHARACTERISTICS_WDM_DRIVER"] = UntypedNumericConst("8192")
	decs["IMAGE_FILE_32BIT_MACHINE"] = UntypedNumericConst("256")
	decs["IMAGE_FILE_AGGRESIVE_WS_TRIM"] = UntypedNumericConst("16")
	decs["IMAGE_FILE_BYTES_REVERSED_HI"] = UntypedNumericConst("32768")
	decs["IMAGE_FILE_BYTES_REVERSED_LO"] = UntypedNumericConst("128")
	decs["IMAGE_FILE_DEBUG_STRIPPED"] = UntypedNumericConst("512")
	decs["IMAGE_FILE_DLL"] = UntypedNumericConst("8192")
	decs["IMAGE_FILE_EXECUTABLE_IMAGE"] = UntypedNumericConst("2")
	decs["IMAGE_FILE_LARGE_ADDRESS_AWARE"] = UntypedNumericConst("32")
	decs["IMAGE_FILE_LINE_NUMS_STRIPPED"] = UntypedNumericConst("4")
	decs["IMAGE_FILE_LOCAL_SYMS_STRIPPED"] = UntypedNumericConst("8")
	decs["IMAGE_FILE_MACHINE_AM33"] = UntypedNumericConst("467")
	decs["IMAGE_FILE_MACHINE_AMD64"] = UntypedNumericConst("34404")
	decs["IMAGE_FILE_MACHINE_ARM"] = UntypedNumericConst("448")
	decs["IMAGE_FILE_MACHINE_ARM64"] = UntypedNumericConst("43620")
	decs["IMAGE_FILE_MACHINE_ARMNT"] = UntypedNumericConst("452")
	decs["IMAGE_FILE_MACHINE_EBC"] = UntypedNumericConst("3772")
	decs["IMAGE_FILE_MACHINE_I386"] = UntypedNumericConst("332")
	decs["IMAGE_FILE_MACHINE_IA64"] = UntypedNumericConst("512")
	decs["IMAGE_FILE_MACHINE_M32R"] = UntypedNumericConst("36929")
	decs["IMAGE_FILE_MACHINE_MIPS16"] = UntypedNumericConst("614")
	decs["IMAGE_FILE_MACHINE_MIPSFPU"] = UntypedNumericConst("870")
	decs["IMAGE_FILE_MACHINE_MIPSFPU16"] = UntypedNumericConst("1126")
	decs["IMAGE_FILE_MACHINE_POWERPC"] = UntypedNumericConst("496")
	decs["IMAGE_FILE_MACHINE_POWERPCFP"] = UntypedNumericConst("497")
	decs["IMAGE_FILE_MACHINE_R4000"] = UntypedNumericConst("358")
	decs["IMAGE_FILE_MACHINE_SH3"] = UntypedNumericConst("418")
	decs["IMAGE_FILE_MACHINE_SH3DSP"] = UntypedNumericConst("419")
	decs["IMAGE_FILE_MACHINE_SH4"] = UntypedNumericConst("422")
	decs["IMAGE_FILE_MACHINE_SH5"] = UntypedNumericConst("424")
	decs["IMAGE_FILE_MACHINE_THUMB"] = UntypedNumericConst("450")
	decs["IMAGE_FILE_MACHINE_UNKNOWN"] = UntypedNumericConst("0")
	decs["IMAGE_FILE_MACHINE_WCEMIPSV2"] = UntypedNumericConst("361")
	decs["IMAGE_FILE_NET_RUN_FROM_SWAP"] = UntypedNumericConst("2048")
	decs["IMAGE_FILE_RELOCS_STRIPPED"] = UntypedNumericConst("1")
	decs["IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP"] = UntypedNumericConst("1024")
	decs["IMAGE_FILE_SYSTEM"] = UntypedNumericConst("4096")
	decs["IMAGE_FILE_UP_SYSTEM_ONLY"] = UntypedNumericConst("16384")
	decs["IMAGE_SUBSYSTEM_EFI_APPLICATION"] = UntypedNumericConst("10")
	decs["IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER"] = UntypedNumericConst("11")
	decs["IMAGE_SUBSYSTEM_EFI_ROM"] = UntypedNumericConst("13")
	decs["IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER"] = UntypedNumericConst("12")
	decs["IMAGE_SUBSYSTEM_NATIVE"] = UntypedNumericConst("1")
	decs["IMAGE_SUBSYSTEM_NATIVE_WINDOWS"] = UntypedNumericConst("8")
	decs["IMAGE_SUBSYSTEM_OS2_CUI"] = UntypedNumericConst("5")
	decs["IMAGE_SUBSYSTEM_POSIX_CUI"] = UntypedNumericConst("7")
	decs["IMAGE_SUBSYSTEM_UNKNOWN"] = UntypedNumericConst("0")
	decs["IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION"] = UntypedNumericConst("16")
	decs["IMAGE_SUBSYSTEM_WINDOWS_CE_GUI"] = UntypedNumericConst("9")
	decs["IMAGE_SUBSYSTEM_WINDOWS_CUI"] = UntypedNumericConst("3")
	decs["IMAGE_SUBSYSTEM_WINDOWS_GUI"] = UntypedNumericConst("2")
	decs["IMAGE_SUBSYSTEM_XBOX"] = UntypedNumericConst("14")
	decs["ImportDirectory"] = reflect.TypeOf((*pe.ImportDirectory)(nil)).Elem()
	decs["NewFile"] = pe.NewFile
	decs["Open"] = pe.Open
	decs["OptionalHeader32"] = reflect.TypeOf((*pe.OptionalHeader32)(nil)).Elem()
	decs["OptionalHeader64"] = reflect.TypeOf((*pe.OptionalHeader64)(nil)).Elem()
	decs["Reloc"] = reflect.TypeOf((*pe.Reloc)(nil)).Elem()
	decs["Section"] = reflect.TypeOf((*pe.Section)(nil)).Elem()
	decs["SectionHeader"] = reflect.TypeOf((*pe.SectionHeader)(nil)).Elem()
	decs["SectionHeader32"] = reflect.TypeOf((*pe.SectionHeader32)(nil)).Elem()
	decs["StringTable"] = reflect.TypeOf((*pe.StringTable)(nil)).Elem()
	decs["Symbol"] = reflect.TypeOf((*pe.Symbol)(nil)).Elem()
	packages["debug/pe"] = &MapPackage{
		PkgName: "pe",
		Declarations: decs,
	}
	// "debug/plan9obj"
	decs = make(map[string]interface{}, 11)
	decs["File"] = reflect.TypeOf((*plan9obj.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*plan9obj.FileHeader)(nil)).Elem()
	decs["Magic386"] = UntypedNumericConst("491")
	decs["Magic64"] = UntypedNumericConst("32768")
	decs["MagicAMD64"] = UntypedNumericConst("35479")
	decs["MagicARM"] = UntypedNumericConst("1607")
	decs["NewFile"] = plan9obj.NewFile
	decs["Open"] = plan9obj.Open
	decs["Section"] = reflect.TypeOf((*plan9obj.Section)(nil)).Elem()
	decs["SectionHeader"] = reflect.TypeOf((*plan9obj.SectionHeader)(nil)).Elem()
	decs["Sym"] = reflect.TypeOf((*plan9obj.Sym)(nil)).Elem()
	packages["debug/plan9obj"] = &MapPackage{
		PkgName: "plan9obj",
		Declarations: decs,
	}
	// "encoding"
	decs = make(map[string]interface{}, 4)
	decs["BinaryMarshaler"] = reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()
	decs["BinaryUnmarshaler"] = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()
	decs["TextMarshaler"] = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
	decs["TextUnmarshaler"] = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
	packages["encoding"] = &MapPackage{
		PkgName: "encoding",
		Declarations: decs,
	}
	// "encoding/ascii85"
	decs = make(map[string]interface{}, 6)
	decs["CorruptInputError"] = reflect.TypeOf((*ascii85.CorruptInputError)(nil)).Elem()
	decs["Decode"] = ascii85.Decode
	decs["Encode"] = ascii85.Encode
	decs["MaxEncodedLen"] = ascii85.MaxEncodedLen
	decs["NewDecoder"] = ascii85.NewDecoder
	decs["NewEncoder"] = ascii85.NewEncoder
	packages["encoding/ascii85"] = &MapPackage{
		PkgName: "ascii85",
		Declarations: decs,
	}
	// "encoding/asn1"
	decs = make(map[string]interface{}, 36)
	decs["BitString"] = reflect.TypeOf((*asn1.BitString)(nil)).Elem()
	decs["ClassApplication"] = UntypedNumericConst("1")
	decs["ClassContextSpecific"] = UntypedNumericConst("2")
	decs["ClassPrivate"] = UntypedNumericConst("3")
	decs["ClassUniversal"] = UntypedNumericConst("0")
	decs["Enumerated"] = reflect.TypeOf((*asn1.Enumerated)(nil)).Elem()
	decs["Flag"] = reflect.TypeOf((*asn1.Flag)(nil)).Elem()
	decs["Marshal"] = asn1.Marshal
	decs["MarshalWithParams"] = asn1.MarshalWithParams
	decs["NullBytes"] = &asn1.NullBytes
	decs["NullRawValue"] = &asn1.NullRawValue
	decs["ObjectIdentifier"] = reflect.TypeOf((*asn1.ObjectIdentifier)(nil)).Elem()
	decs["RawContent"] = reflect.TypeOf((*asn1.RawContent)(nil)).Elem()
	decs["RawValue"] = reflect.TypeOf((*asn1.RawValue)(nil)).Elem()
	decs["StructuralError"] = reflect.TypeOf((*asn1.StructuralError)(nil)).Elem()
	decs["SyntaxError"] = reflect.TypeOf((*asn1.SyntaxError)(nil)).Elem()
	decs["TagBMPString"] = UntypedNumericConst("30")
	decs["TagBitString"] = UntypedNumericConst("3")
	decs["TagBoolean"] = UntypedNumericConst("1")
	decs["TagEnum"] = UntypedNumericConst("10")
	decs["TagGeneralString"] = UntypedNumericConst("27")
	decs["TagGeneralizedTime"] = UntypedNumericConst("24")
	decs["TagIA5String"] = UntypedNumericConst("22")
	decs["TagInteger"] = UntypedNumericConst("2")
	decs["TagNull"] = UntypedNumericConst("5")
	decs["TagNumericString"] = UntypedNumericConst("18")
	decs["TagOID"] = UntypedNumericConst("6")
	decs["TagOctetString"] = UntypedNumericConst("4")
	decs["TagPrintableString"] = UntypedNumericConst("19")
	decs["TagSequence"] = UntypedNumericConst("16")
	decs["TagSet"] = UntypedNumericConst("17")
	decs["TagT61String"] = UntypedNumericConst("20")
	decs["TagUTCTime"] = UntypedNumericConst("23")
	decs["TagUTF8String"] = UntypedNumericConst("12")
	decs["Unmarshal"] = asn1.Unmarshal
	decs["UnmarshalWithParams"] = asn1.UnmarshalWithParams
	packages["encoding/asn1"] = &MapPackage{
		PkgName: "asn1",
		Declarations: decs,
	}
	// "encoding/base32"
	decs = make(map[string]interface{}, 9)
	decs["CorruptInputError"] = reflect.TypeOf((*base32.CorruptInputError)(nil)).Elem()
	decs["Encoding"] = reflect.TypeOf((*base32.Encoding)(nil)).Elem()
	decs["HexEncoding"] = &base32.HexEncoding
	decs["NewDecoder"] = base32.NewDecoder
	decs["NewEncoder"] = base32.NewEncoder
	decs["NewEncoding"] = base32.NewEncoding
	decs["NoPadding"] = base32.NoPadding
	decs["StdEncoding"] = &base32.StdEncoding
	decs["StdPadding"] = base32.StdPadding
	packages["encoding/base32"] = &MapPackage{
		PkgName: "base32",
		Declarations: decs,
	}
	// "encoding/base64"
	decs = make(map[string]interface{}, 11)
	decs["CorruptInputError"] = reflect.TypeOf((*base64.CorruptInputError)(nil)).Elem()
	decs["Encoding"] = reflect.TypeOf((*base64.Encoding)(nil)).Elem()
	decs["NewDecoder"] = base64.NewDecoder
	decs["NewEncoder"] = base64.NewEncoder
	decs["NewEncoding"] = base64.NewEncoding
	decs["NoPadding"] = base64.NoPadding
	decs["RawStdEncoding"] = &base64.RawStdEncoding
	decs["RawURLEncoding"] = &base64.RawURLEncoding
	decs["StdEncoding"] = &base64.StdEncoding
	decs["StdPadding"] = base64.StdPadding
	decs["URLEncoding"] = &base64.URLEncoding
	packages["encoding/base64"] = &MapPackage{
		PkgName: "base64",
		Declarations: decs,
	}
	// "encoding/binary"
	decs = make(map[string]interface{}, 15)
	decs["BigEndian"] = &binary.BigEndian
	decs["ByteOrder"] = reflect.TypeOf((*binary.ByteOrder)(nil)).Elem()
	decs["LittleEndian"] = &binary.LittleEndian
	decs["MaxVarintLen16"] = UntypedNumericConst("3")
	decs["MaxVarintLen32"] = UntypedNumericConst("5")
	decs["MaxVarintLen64"] = UntypedNumericConst("10")
	decs["PutUvarint"] = binary.PutUvarint
	decs["PutVarint"] = binary.PutVarint
	decs["Read"] = binary.Read
	decs["ReadUvarint"] = binary.ReadUvarint
	decs["ReadVarint"] = binary.ReadVarint
	decs["Size"] = binary.Size
	decs["Uvarint"] = binary.Uvarint
	decs["Varint"] = binary.Varint
	decs["Write"] = binary.Write
	packages["encoding/binary"] = &MapPackage{
		PkgName: "binary",
		Declarations: decs,
	}
	// "encoding/csv"
	decs = make(map[string]interface{}, 9)
	decs["ErrBareQuote"] = &csv.ErrBareQuote
	decs["ErrFieldCount"] = &csv.ErrFieldCount
	decs["ErrQuote"] = &csv.ErrQuote
	decs["ErrTrailingComma"] = &csv.ErrTrailingComma
	decs["NewReader"] = csv.NewReader
	decs["NewWriter"] = csv.NewWriter
	decs["ParseError"] = reflect.TypeOf((*csv.ParseError)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*csv.Reader)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*csv.Writer)(nil)).Elem()
	packages["encoding/csv"] = &MapPackage{
		PkgName: "csv",
		Declarations: decs,
	}
	// "encoding/gob"
	decs = make(map[string]interface{}, 9)
	decs["CommonType"] = reflect.TypeOf((*gob.CommonType)(nil)).Elem()
	decs["Decoder"] = reflect.TypeOf((*gob.Decoder)(nil)).Elem()
	decs["Encoder"] = reflect.TypeOf((*gob.Encoder)(nil)).Elem()
	decs["GobDecoder"] = reflect.TypeOf((*gob.GobDecoder)(nil)).Elem()
	decs["GobEncoder"] = reflect.TypeOf((*gob.GobEncoder)(nil)).Elem()
	decs["NewDecoder"] = gob.NewDecoder
	decs["NewEncoder"] = gob.NewEncoder
	decs["Register"] = gob.Register
	decs["RegisterName"] = gob.RegisterName
	packages["encoding/gob"] = &MapPackage{
		PkgName: "gob",
		Declarations: decs,
	}
	// "encoding/hex"
	decs = make(map[string]interface{}, 12)
	decs["Decode"] = hex.Decode
	decs["DecodeString"] = hex.DecodeString
	decs["DecodedLen"] = hex.DecodedLen
	decs["Dump"] = hex.Dump
	decs["Dumper"] = hex.Dumper
	decs["Encode"] = hex.Encode
	decs["EncodeToString"] = hex.EncodeToString
	decs["EncodedLen"] = hex.EncodedLen
	decs["ErrLength"] = &hex.ErrLength
	decs["InvalidByteError"] = reflect.TypeOf((*hex.InvalidByteError)(nil)).Elem()
	decs["NewDecoder"] = hex.NewDecoder
	decs["NewEncoder"] = hex.NewEncoder
	packages["encoding/hex"] = &MapPackage{
		PkgName: "hex",
		Declarations: decs,
	}
	// "encoding/json"
	decs = make(map[string]interface{}, 25)
	decs["Compact"] = json.Compact
	decs["Decoder"] = reflect.TypeOf((*json.Decoder)(nil)).Elem()
	decs["Delim"] = reflect.TypeOf((*json.Delim)(nil)).Elem()
	decs["Encoder"] = reflect.TypeOf((*json.Encoder)(nil)).Elem()
	decs["HTMLEscape"] = json.HTMLEscape
	decs["Indent"] = json.Indent
	decs["InvalidUTF8Error"] = reflect.TypeOf((*json.InvalidUTF8Error)(nil)).Elem()
	decs["InvalidUnmarshalError"] = reflect.TypeOf((*json.InvalidUnmarshalError)(nil)).Elem()
	decs["Marshal"] = json.Marshal
	decs["MarshalIndent"] = json.MarshalIndent
	decs["Marshaler"] = reflect.TypeOf((*json.Marshaler)(nil)).Elem()
	decs["MarshalerError"] = reflect.TypeOf((*json.MarshalerError)(nil)).Elem()
	decs["NewDecoder"] = json.NewDecoder
	decs["NewEncoder"] = json.NewEncoder
	decs["Number"] = reflect.TypeOf((*json.Number)(nil)).Elem()
	decs["RawMessage"] = reflect.TypeOf((*json.RawMessage)(nil)).Elem()
	decs["SyntaxError"] = reflect.TypeOf((*json.SyntaxError)(nil)).Elem()
	decs["Token"] = reflect.TypeOf((*json.Token)(nil)).Elem()
	decs["Unmarshal"] = json.Unmarshal
	decs["UnmarshalFieldError"] = reflect.TypeOf((*json.UnmarshalFieldError)(nil)).Elem()
	decs["UnmarshalTypeError"] = reflect.TypeOf((*json.UnmarshalTypeError)(nil)).Elem()
	decs["Unmarshaler"] = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
	decs["UnsupportedTypeError"] = reflect.TypeOf((*json.UnsupportedTypeError)(nil)).Elem()
	decs["UnsupportedValueError"] = reflect.TypeOf((*json.UnsupportedValueError)(nil)).Elem()
	decs["Valid"] = json.Valid
	packages["encoding/json"] = &MapPackage{
		PkgName: "json",
		Declarations: decs,
	}
	// "encoding/pem"
	decs = make(map[string]interface{}, 4)
	decs["Block"] = reflect.TypeOf((*pem.Block)(nil)).Elem()
	decs["Decode"] = pem.Decode
	decs["Encode"] = pem.Encode
	decs["EncodeToMemory"] = pem.EncodeToMemory
	packages["encoding/pem"] = &MapPackage{
		PkgName: "pem",
		Declarations: decs,
	}
	// "encoding/xml"
	decs = make(map[string]interface{}, 32)
	decs["Attr"] = reflect.TypeOf((*xml.Attr)(nil)).Elem()
	decs["CharData"] = reflect.TypeOf((*xml.CharData)(nil)).Elem()
	decs["Comment"] = reflect.TypeOf((*xml.Comment)(nil)).Elem()
	decs["CopyToken"] = xml.CopyToken
	decs["Decoder"] = reflect.TypeOf((*xml.Decoder)(nil)).Elem()
	decs["Directive"] = reflect.TypeOf((*xml.Directive)(nil)).Elem()
	decs["Encoder"] = reflect.TypeOf((*xml.Encoder)(nil)).Elem()
	decs["EndElement"] = reflect.TypeOf((*xml.EndElement)(nil)).Elem()
	decs["Escape"] = xml.Escape
	decs["EscapeText"] = xml.EscapeText
	decs["HTMLAutoClose"] = &xml.HTMLAutoClose
	decs["HTMLEntity"] = &xml.HTMLEntity
	decs["Header"] = UntypedStringConst("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
	decs["Marshal"] = xml.Marshal
	decs["MarshalIndent"] = xml.MarshalIndent
	decs["Marshaler"] = reflect.TypeOf((*xml.Marshaler)(nil)).Elem()
	decs["MarshalerAttr"] = reflect.TypeOf((*xml.MarshalerAttr)(nil)).Elem()
	decs["Name"] = reflect.TypeOf((*xml.Name)(nil)).Elem()
	decs["NewDecoder"] = xml.NewDecoder
	decs["NewEncoder"] = xml.NewEncoder
	decs["NewTokenDecoder"] = xml.NewTokenDecoder
	decs["ProcInst"] = reflect.TypeOf((*xml.ProcInst)(nil)).Elem()
	decs["StartElement"] = reflect.TypeOf((*xml.StartElement)(nil)).Elem()
	decs["SyntaxError"] = reflect.TypeOf((*xml.SyntaxError)(nil)).Elem()
	decs["TagPathError"] = reflect.TypeOf((*xml.TagPathError)(nil)).Elem()
	decs["Token"] = reflect.TypeOf((*xml.Token)(nil)).Elem()
	decs["TokenReader"] = reflect.TypeOf((*xml.TokenReader)(nil)).Elem()
	decs["Unmarshal"] = xml.Unmarshal
	decs["UnmarshalError"] = reflect.TypeOf((*xml.UnmarshalError)(nil)).Elem()
	decs["Unmarshaler"] = reflect.TypeOf((*xml.Unmarshaler)(nil)).Elem()
	decs["UnmarshalerAttr"] = reflect.TypeOf((*xml.UnmarshalerAttr)(nil)).Elem()
	decs["UnsupportedTypeError"] = reflect.TypeOf((*xml.UnsupportedTypeError)(nil)).Elem()
	packages["encoding/xml"] = &MapPackage{
		PkgName: "xml",
		Declarations: decs,
	}
	// "errors"
	decs = make(map[string]interface{}, 4)
	decs["As"] = errors.As
	decs["Is"] = errors.Is
	decs["New"] = errors.New
	decs["Unwrap"] = errors.Unwrap
	packages["errors"] = &MapPackage{
		PkgName: "errors",
		Declarations: decs,
	}
	// "expvar"
	decs = make(map[string]interface{}, 15)
	decs["Do"] = expvar.Do
	decs["Float"] = reflect.TypeOf((*expvar.Float)(nil)).Elem()
	decs["Func"] = reflect.TypeOf((*expvar.Func)(nil)).Elem()
	decs["Get"] = expvar.Get
	decs["Handler"] = expvar.Handler
	decs["Int"] = reflect.TypeOf((*expvar.Int)(nil)).Elem()
	decs["KeyValue"] = reflect.TypeOf((*expvar.KeyValue)(nil)).Elem()
	decs["Map"] = reflect.TypeOf((*expvar.Map)(nil)).Elem()
	decs["NewFloat"] = expvar.NewFloat
	decs["NewInt"] = expvar.NewInt
	decs["NewMap"] = expvar.NewMap
	decs["NewString"] = expvar.NewString
	decs["Publish"] = expvar.Publish
	decs["String"] = reflect.TypeOf((*expvar.String)(nil)).Elem()
	decs["Var"] = reflect.TypeOf((*expvar.Var)(nil)).Elem()
	packages["expvar"] = &MapPackage{
		PkgName: "expvar",
		Declarations: decs,
	}
	// "flag"
	decs = make(map[string]interface{}, 42)
	decs["Arg"] = flag.Arg
	decs["Args"] = flag.Args
	decs["Bool"] = flag.Bool
	decs["BoolVar"] = flag.BoolVar
	decs["CommandLine"] = &flag.CommandLine
	decs["ContinueOnError"] = flag.ContinueOnError
	decs["Duration"] = flag.Duration
	decs["DurationVar"] = flag.DurationVar
	decs["ErrHelp"] = &flag.ErrHelp
	decs["ErrorHandling"] = reflect.TypeOf((*flag.ErrorHandling)(nil)).Elem()
	decs["ExitOnError"] = flag.ExitOnError
	decs["Flag"] = reflect.TypeOf((*flag.Flag)(nil)).Elem()
	decs["FlagSet"] = reflect.TypeOf((*flag.FlagSet)(nil)).Elem()
	decs["Float64"] = flag.Float64
	decs["Float64Var"] = flag.Float64Var
	decs["Func"] = flag.Func
	decs["Getter"] = reflect.TypeOf((*flag.Getter)(nil)).Elem()
	decs["Int"] = flag.Int
	decs["Int64"] = flag.Int64
	decs["Int64Var"] = flag.Int64Var
	decs["IntVar"] = flag.IntVar
	decs["Lookup"] = flag.Lookup
	decs["NArg"] = flag.NArg
	decs["NFlag"] = flag.NFlag
	decs["NewFlagSet"] = flag.NewFlagSet
	decs["PanicOnError"] = flag.PanicOnError
	decs["Parse"] = flag.Parse
	decs["Parsed"] = flag.Parsed
	decs["PrintDefaults"] = flag.PrintDefaults
	decs["Set"] = flag.Set
	decs["String"] = flag.String
	decs["StringVar"] = flag.StringVar
	decs["Uint"] = flag.Uint
	decs["Uint64"] = flag.Uint64
	decs["Uint64Var"] = flag.Uint64Var
	decs["UintVar"] = flag.UintVar
	decs["UnquoteUsage"] = flag.UnquoteUsage
	decs["Usage"] = &flag.Usage
	decs["Value"] = reflect.TypeOf((*flag.Value)(nil)).Elem()
	decs["Var"] = flag.Var
	decs["Visit"] = flag.Visit
	decs["VisitAll"] = flag.VisitAll
	packages["flag"] = &MapPackage{
		PkgName: "flag",
		Declarations: decs,
	}
	// "fmt"
	decs = make(map[string]interface{}, 25)
	decs["Errorf"] = fmt.Errorf
	decs["Formatter"] = reflect.TypeOf((*fmt.Formatter)(nil)).Elem()
	decs["Fprint"] = fmt.Fprint
	decs["Fprintf"] = fmt.Fprintf
	decs["Fprintln"] = fmt.Fprintln
	decs["Fscan"] = fmt.Fscan
	decs["Fscanf"] = fmt.Fscanf
	decs["Fscanln"] = fmt.Fscanln
	decs["GoStringer"] = reflect.TypeOf((*fmt.GoStringer)(nil)).Elem()
	decs["Print"] = fmt.Print
	decs["Printf"] = fmt.Printf
	decs["Println"] = fmt.Println
	decs["Scan"] = fmt.Scan
	decs["ScanState"] = reflect.TypeOf((*fmt.ScanState)(nil)).Elem()
	decs["Scanf"] = fmt.Scanf
	decs["Scanln"] = fmt.Scanln
	decs["Scanner"] = reflect.TypeOf((*fmt.Scanner)(nil)).Elem()
	decs["Sprint"] = fmt.Sprint
	decs["Sprintf"] = fmt.Sprintf
	decs["Sprintln"] = fmt.Sprintln
	decs["Sscan"] = fmt.Sscan
	decs["Sscanf"] = fmt.Sscanf
	decs["Sscanln"] = fmt.Sscanln
	decs["State"] = reflect.TypeOf((*fmt.State)(nil)).Elem()
	decs["Stringer"] = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
	packages["fmt"] = &MapPackage{
		PkgName: "fmt",
		Declarations: decs,
	}
	// "go/ast"
	decs = make(map[string]interface{}, 100)
	decs["ArrayType"] = reflect.TypeOf((*ast.ArrayType)(nil)).Elem()
	decs["AssignStmt"] = reflect.TypeOf((*ast.AssignStmt)(nil)).Elem()
	decs["Bad"] = ast.Bad
	decs["BadDecl"] = reflect.TypeOf((*ast.BadDecl)(nil)).Elem()
	decs["BadExpr"] = reflect.TypeOf((*ast.BadExpr)(nil)).Elem()
	decs["BadStmt"] = reflect.TypeOf((*ast.BadStmt)(nil)).Elem()
	decs["BasicLit"] = reflect.TypeOf((*ast.BasicLit)(nil)).Elem()
	decs["BinaryExpr"] = reflect.TypeOf((*ast.BinaryExpr)(nil)).Elem()
	decs["BlockStmt"] = reflect.TypeOf((*ast.BlockStmt)(nil)).Elem()
	decs["BranchStmt"] = reflect.TypeOf((*ast.BranchStmt)(nil)).Elem()
	decs["CallExpr"] = reflect.TypeOf((*ast.CallExpr)(nil)).Elem()
	decs["CaseClause"] = reflect.TypeOf((*ast.CaseClause)(nil)).Elem()
	decs["ChanDir"] = reflect.TypeOf((*ast.ChanDir)(nil)).Elem()
	decs["ChanType"] = reflect.TypeOf((*ast.ChanType)(nil)).Elem()
	decs["CommClause"] = reflect.TypeOf((*ast.CommClause)(nil)).Elem()
	decs["Comment"] = reflect.TypeOf((*ast.Comment)(nil)).Elem()
	decs["CommentGroup"] = reflect.TypeOf((*ast.CommentGroup)(nil)).Elem()
	decs["CommentMap"] = reflect.TypeOf((*ast.CommentMap)(nil)).Elem()
	decs["CompositeLit"] = reflect.TypeOf((*ast.CompositeLit)(nil)).Elem()
	decs["Con"] = ast.Con
	decs["Decl"] = reflect.TypeOf((*ast.Decl)(nil)).Elem()
	decs["DeclStmt"] = reflect.TypeOf((*ast.DeclStmt)(nil)).Elem()
	decs["DeferStmt"] = reflect.TypeOf((*ast.DeferStmt)(nil)).Elem()
	decs["Ellipsis"] = reflect.TypeOf((*ast.Ellipsis)(nil)).Elem()
	decs["EmptyStmt"] = reflect.TypeOf((*ast.EmptyStmt)(nil)).Elem()
	decs["Expr"] = reflect.TypeOf((*ast.Expr)(nil)).Elem()
	decs["ExprStmt"] = reflect.TypeOf((*ast.ExprStmt)(nil)).Elem()
	decs["Field"] = reflect.TypeOf((*ast.Field)(nil)).Elem()
	decs["FieldFilter"] = reflect.TypeOf((*ast.FieldFilter)(nil)).Elem()
	decs["FieldList"] = reflect.TypeOf((*ast.FieldList)(nil)).Elem()
	decs["File"] = reflect.TypeOf((*ast.File)(nil)).Elem()
	decs["FileExports"] = ast.FileExports
	decs["Filter"] = reflect.TypeOf((*ast.Filter)(nil)).Elem()
	decs["FilterDecl"] = ast.FilterDecl
	decs["FilterFile"] = ast.FilterFile
	decs["FilterFuncDuplicates"] = ast.FilterFuncDuplicates
	decs["FilterImportDuplicates"] = ast.FilterImportDuplicates
	decs["FilterPackage"] = ast.FilterPackage
	decs["FilterUnassociatedComments"] = ast.FilterUnassociatedComments
	decs["ForStmt"] = reflect.TypeOf((*ast.ForStmt)(nil)).Elem()
	decs["Fprint"] = ast.Fprint
	decs["Fun"] = ast.Fun
	decs["FuncDecl"] = reflect.TypeOf((*ast.FuncDecl)(nil)).Elem()
	decs["FuncLit"] = reflect.TypeOf((*ast.FuncLit)(nil)).Elem()
	decs["FuncType"] = reflect.TypeOf((*ast.FuncType)(nil)).Elem()
	decs["GenDecl"] = reflect.TypeOf((*ast.GenDecl)(nil)).Elem()
	decs["GoStmt"] = reflect.TypeOf((*ast.GoStmt)(nil)).Elem()
	decs["Ident"] = reflect.TypeOf((*ast.Ident)(nil)).Elem()
	decs["IfStmt"] = reflect.TypeOf((*ast.IfStmt)(nil)).Elem()
	decs["ImportSpec"] = reflect.TypeOf((*ast.ImportSpec)(nil)).Elem()
	decs["Importer"] = reflect.TypeOf((*ast.Importer)(nil)).Elem()
	decs["IncDecStmt"] = reflect.TypeOf((*ast.IncDecStmt)(nil)).Elem()
	decs["IndexExpr"] = reflect.TypeOf((*ast.IndexExpr)(nil)).Elem()
	decs["Inspect"] = ast.Inspect
	decs["InterfaceType"] = reflect.TypeOf((*ast.InterfaceType)(nil)).Elem()
	decs["IsExported"] = ast.IsExported
	decs["KeyValueExpr"] = reflect.TypeOf((*ast.KeyValueExpr)(nil)).Elem()
	decs["LabeledStmt"] = reflect.TypeOf((*ast.LabeledStmt)(nil)).Elem()
	decs["Lbl"] = ast.Lbl
	decs["MapType"] = reflect.TypeOf((*ast.MapType)(nil)).Elem()
	decs["MergeMode"] = reflect.TypeOf((*ast.MergeMode)(nil)).Elem()
	decs["MergePackageFiles"] = ast.MergePackageFiles
	decs["NewCommentMap"] = ast.NewCommentMap
	decs["NewIdent"] = ast.NewIdent
	decs["NewObj"] = ast.NewObj
	decs["NewPackage"] = ast.NewPackage
	decs["NewScope"] = ast.NewScope
	decs["Node"] = reflect.TypeOf((*ast.Node)(nil)).Elem()
	decs["NotNilFilter"] = ast.NotNilFilter
	decs["ObjKind"] = reflect.TypeOf((*ast.ObjKind)(nil)).Elem()
	decs["Object"] = reflect.TypeOf((*ast.Object)(nil)).Elem()
	decs["Package"] = reflect.TypeOf((*ast.Package)(nil)).Elem()
	decs["PackageExports"] = ast.PackageExports
	decs["ParenExpr"] = reflect.TypeOf((*ast.ParenExpr)(nil)).Elem()
	decs["Pkg"] = ast.Pkg
	decs["Print"] = ast.Print
	decs["RECV"] = ast.RECV
	decs["RangeStmt"] = reflect.TypeOf((*ast.RangeStmt)(nil)).Elem()
	decs["ReturnStmt"] = reflect.TypeOf((*ast.ReturnStmt)(nil)).Elem()
	decs["SEND"] = ast.SEND
	decs["Scope"] = reflect.TypeOf((*ast.Scope)(nil)).Elem()
	decs["SelectStmt"] = reflect.TypeOf((*ast.SelectStmt)(nil)).Elem()
	decs["SelectorExpr"] = reflect.TypeOf((*ast.SelectorExpr)(nil)).Elem()
	decs["SendStmt"] = reflect.TypeOf((*ast.SendStmt)(nil)).Elem()
	decs["SliceExpr"] = reflect.TypeOf((*ast.SliceExpr)(nil)).Elem()
	decs["SortImports"] = ast.SortImports
	decs["Spec"] = reflect.TypeOf((*ast.Spec)(nil)).Elem()
	decs["StarExpr"] = reflect.TypeOf((*ast.StarExpr)(nil)).Elem()
	decs["Stmt"] = reflect.TypeOf((*ast.Stmt)(nil)).Elem()
	decs["StructType"] = reflect.TypeOf((*ast.StructType)(nil)).Elem()
	decs["SwitchStmt"] = reflect.TypeOf((*ast.SwitchStmt)(nil)).Elem()
	decs["Typ"] = ast.Typ
	decs["TypeAssertExpr"] = reflect.TypeOf((*ast.TypeAssertExpr)(nil)).Elem()
	decs["TypeSpec"] = reflect.TypeOf((*ast.TypeSpec)(nil)).Elem()
	decs["TypeSwitchStmt"] = reflect.TypeOf((*ast.TypeSwitchStmt)(nil)).Elem()
	decs["UnaryExpr"] = reflect.TypeOf((*ast.UnaryExpr)(nil)).Elem()
	decs["ValueSpec"] = reflect.TypeOf((*ast.ValueSpec)(nil)).Elem()
	decs["Var"] = ast.Var
	decs["Visitor"] = reflect.TypeOf((*ast.Visitor)(nil)).Elem()
	decs["Walk"] = ast.Walk
	packages["go/ast"] = &MapPackage{
		PkgName: "ast",
		Declarations: decs,
	}
	// "go/build"
	decs = make(map[string]interface{}, 15)
	decs["AllowBinary"] = build.AllowBinary
	decs["ArchChar"] = build.ArchChar
	decs["Context"] = reflect.TypeOf((*build.Context)(nil)).Elem()
	decs["Default"] = &build.Default
	decs["FindOnly"] = build.FindOnly
	decs["IgnoreVendor"] = build.IgnoreVendor
	decs["Import"] = build.Import
	decs["ImportComment"] = build.ImportComment
	decs["ImportDir"] = build.ImportDir
	decs["ImportMode"] = reflect.TypeOf((*build.ImportMode)(nil)).Elem()
	decs["IsLocalImport"] = build.IsLocalImport
	decs["MultiplePackageError"] = reflect.TypeOf((*build.MultiplePackageError)(nil)).Elem()
	decs["NoGoError"] = reflect.TypeOf((*build.NoGoError)(nil)).Elem()
	decs["Package"] = reflect.TypeOf((*build.Package)(nil)).Elem()
	decs["ToolDir"] = &build.ToolDir
	packages["go/build"] = &MapPackage{
		PkgName: "build",
		Declarations: decs,
	}
	// "go/constant"
	decs = make(map[string]interface{}, 39)
	decs["BinaryOp"] = constant.BinaryOp
	decs["BitLen"] = constant.BitLen
	decs["Bool"] = constant.Bool
	decs["BoolVal"] = constant.BoolVal
	decs["Bytes"] = constant.Bytes
	decs["Compare"] = constant.Compare
	decs["Complex"] = constant.Complex
	decs["Denom"] = constant.Denom
	decs["Float"] = constant.Float
	decs["Float32Val"] = constant.Float32Val
	decs["Float64Val"] = constant.Float64Val
	decs["Imag"] = constant.Imag
	decs["Int"] = constant.Int
	decs["Int64Val"] = constant.Int64Val
	decs["Kind"] = reflect.TypeOf((*constant.Kind)(nil)).Elem()
	decs["Make"] = constant.Make
	decs["MakeBool"] = constant.MakeBool
	decs["MakeFloat64"] = constant.MakeFloat64
	decs["MakeFromBytes"] = constant.MakeFromBytes
	decs["MakeFromLiteral"] = constant.MakeFromLiteral
	decs["MakeImag"] = constant.MakeImag
	decs["MakeInt64"] = constant.MakeInt64
	decs["MakeString"] = constant.MakeString
	decs["MakeUint64"] = constant.MakeUint64
	decs["MakeUnknown"] = constant.MakeUnknown
	decs["Num"] = constant.Num
	decs["Real"] = constant.Real
	decs["Shift"] = constant.Shift
	decs["Sign"] = constant.Sign
	decs["String"] = constant.String
	decs["StringVal"] = constant.StringVal
	decs["ToComplex"] = constant.ToComplex
	decs["ToFloat"] = constant.ToFloat
	decs["ToInt"] = constant.ToInt
	decs["Uint64Val"] = constant.Uint64Val
	decs["UnaryOp"] = constant.UnaryOp
	decs["Unknown"] = constant.Unknown
	decs["Val"] = constant.Val
	decs["Value"] = reflect.TypeOf((*constant.Value)(nil)).Elem()
	packages["go/constant"] = &MapPackage{
		PkgName: "constant",
		Declarations: decs,
	}
	// "go/doc"
	decs = make(map[string]interface{}, 19)
	decs["AllDecls"] = doc.AllDecls
	decs["AllMethods"] = doc.AllMethods
	decs["Example"] = reflect.TypeOf((*doc.Example)(nil)).Elem()
	decs["Examples"] = doc.Examples
	decs["Filter"] = reflect.TypeOf((*doc.Filter)(nil)).Elem()
	decs["Func"] = reflect.TypeOf((*doc.Func)(nil)).Elem()
	decs["IllegalPrefixes"] = &doc.IllegalPrefixes
	decs["IsPredeclared"] = doc.IsPredeclared
	decs["Mode"] = reflect.TypeOf((*doc.Mode)(nil)).Elem()
	decs["New"] = doc.New
	decs["NewFromFiles"] = doc.NewFromFiles
	decs["Note"] = reflect.TypeOf((*doc.Note)(nil)).Elem()
	decs["Package"] = reflect.TypeOf((*doc.Package)(nil)).Elem()
	decs["PreserveAST"] = doc.PreserveAST
	decs["Synopsis"] = doc.Synopsis
	decs["ToHTML"] = doc.ToHTML
	decs["ToText"] = doc.ToText
	decs["Type"] = reflect.TypeOf((*doc.Type)(nil)).Elem()
	decs["Value"] = reflect.TypeOf((*doc.Value)(nil)).Elem()
	packages["go/doc"] = &MapPackage{
		PkgName: "doc",
		Declarations: decs,
	}
	// "go/format"
	decs = make(map[string]interface{}, 2)
	decs["Node"] = format.Node
	decs["Source"] = format.Source
	packages["go/format"] = &MapPackage{
		PkgName: "format",
		Declarations: decs,
	}
	// "go/importer"
	decs = make(map[string]interface{}, 4)
	decs["Default"] = importer.Default
	decs["For"] = importer.For
	decs["ForCompiler"] = importer.ForCompiler
	decs["Lookup"] = reflect.TypeOf((*importer.Lookup)(nil)).Elem()
	packages["go/importer"] = &MapPackage{
		PkgName: "importer",
		Declarations: decs,
	}
	// "go/parser"
	decs = make(map[string]interface{}, 12)
	decs["AllErrors"] = parser.AllErrors
	decs["DeclarationErrors"] = parser.DeclarationErrors
	decs["ImportsOnly"] = parser.ImportsOnly
	decs["Mode"] = reflect.TypeOf((*parser.Mode)(nil)).Elem()
	decs["PackageClauseOnly"] = parser.PackageClauseOnly
	decs["ParseComments"] = parser.ParseComments
	decs["ParseDir"] = parser.ParseDir
	decs["ParseExpr"] = parser.ParseExpr
	decs["ParseExprFrom"] = parser.ParseExprFrom
	decs["ParseFile"] = parser.ParseFile
	decs["SpuriousErrors"] = parser.SpuriousErrors
	decs["Trace"] = parser.Trace
	packages["go/parser"] = &MapPackage{
		PkgName: "parser",
		Declarations: decs,
	}
	// "go/printer"
	decs = make(map[string]interface{}, 8)
	decs["CommentedNode"] = reflect.TypeOf((*printer.CommentedNode)(nil)).Elem()
	decs["Config"] = reflect.TypeOf((*printer.Config)(nil)).Elem()
	decs["Fprint"] = printer.Fprint
	decs["Mode"] = reflect.TypeOf((*printer.Mode)(nil)).Elem()
	decs["RawFormat"] = printer.RawFormat
	decs["SourcePos"] = printer.SourcePos
	decs["TabIndent"] = printer.TabIndent
	decs["UseSpaces"] = printer.UseSpaces
	packages["go/printer"] = &MapPackage{
		PkgName: "printer",
		Declarations: decs,
	}
	// "go/scanner"
	decs = make(map[string]interface{}, 7)
	decs["Error"] = reflect.TypeOf((*scanner.Error)(nil)).Elem()
	decs["ErrorHandler"] = reflect.TypeOf((*scanner.ErrorHandler)(nil)).Elem()
	decs["ErrorList"] = reflect.TypeOf((*scanner.ErrorList)(nil)).Elem()
	decs["Mode"] = reflect.TypeOf((*scanner.Mode)(nil)).Elem()
	decs["PrintError"] = scanner.PrintError
	decs["ScanComments"] = scanner.ScanComments
	decs["Scanner"] = reflect.TypeOf((*scanner.Scanner)(nil)).Elem()
	packages["go/scanner"] = &MapPackage{
		PkgName: "scanner",
		Declarations: decs,
	}
	// "go/token"
	decs = make(map[string]interface{}, 95)
	decs["ADD"] = token.ADD
	decs["ADD_ASSIGN"] = token.ADD_ASSIGN
	decs["AND"] = token.AND
	decs["AND_ASSIGN"] = token.AND_ASSIGN
	decs["AND_NOT"] = token.AND_NOT
	decs["AND_NOT_ASSIGN"] = token.AND_NOT_ASSIGN
	decs["ARROW"] = token.ARROW
	decs["ASSIGN"] = token.ASSIGN
	decs["BREAK"] = token.BREAK
	decs["CASE"] = token.CASE
	decs["CHAN"] = token.CHAN
	decs["CHAR"] = token.CHAR
	decs["COLON"] = token.COLON
	decs["COMMA"] = token.COMMA
	decs["COMMENT"] = token.COMMENT
	decs["CONST"] = token.CONST
	decs["CONTINUE"] = token.CONTINUE
	decs["DEC"] = token.DEC
	decs["DEFAULT"] = token.DEFAULT
	decs["DEFER"] = token.DEFER
	decs["DEFINE"] = token.DEFINE
	decs["ELLIPSIS"] = token.ELLIPSIS
	decs["ELSE"] = token.ELSE
	decs["EOF"] = token.EOF
	decs["EQL"] = token.EQL
	decs["FALLTHROUGH"] = token.FALLTHROUGH
	decs["FLOAT"] = token.FLOAT
	decs["FOR"] = token.FOR
	decs["FUNC"] = token.FUNC
	decs["File"] = reflect.TypeOf((*token.File)(nil)).Elem()
	decs["FileSet"] = reflect.TypeOf((*token.FileSet)(nil)).Elem()
	decs["GEQ"] = token.GEQ
	decs["GO"] = token.GO
	decs["GOTO"] = token.GOTO
	decs["GTR"] = token.GTR
	decs["HighestPrec"] = UntypedNumericConst("7")
	decs["IDENT"] = token.IDENT
	decs["IF"] = token.IF
	decs["ILLEGAL"] = token.ILLEGAL
	decs["IMAG"] = token.IMAG
	decs["IMPORT"] = token.IMPORT
	decs["INC"] = token.INC
	decs["INT"] = token.INT
	decs["INTERFACE"] = token.INTERFACE
	decs["IsExported"] = token.IsExported
	decs["IsIdentifier"] = token.IsIdentifier
	decs["IsKeyword"] = token.IsKeyword
	decs["LAND"] = token.LAND
	decs["LBRACE"] = token.LBRACE
	decs["LBRACK"] = token.LBRACK
	decs["LEQ"] = token.LEQ
	decs["LOR"] = token.LOR
	decs["LPAREN"] = token.LPAREN
	decs["LSS"] = token.LSS
	decs["Lookup"] = token.Lookup
	decs["LowestPrec"] = UntypedNumericConst("0")
	decs["MAP"] = token.MAP
	decs["MUL"] = token.MUL
	decs["MUL_ASSIGN"] = token.MUL_ASSIGN
	decs["NEQ"] = token.NEQ
	decs["NOT"] = token.NOT
	decs["NewFileSet"] = token.NewFileSet
	decs["NoPos"] = token.NoPos
	decs["OR"] = token.OR
	decs["OR_ASSIGN"] = token.OR_ASSIGN
	decs["PACKAGE"] = token.PACKAGE
	decs["PERIOD"] = token.PERIOD
	decs["Pos"] = reflect.TypeOf((*token.Pos)(nil)).Elem()
	decs["Position"] = reflect.TypeOf((*token.Position)(nil)).Elem()
	decs["QUO"] = token.QUO
	decs["QUO_ASSIGN"] = token.QUO_ASSIGN
	decs["RANGE"] = token.RANGE
	decs["RBRACE"] = token.RBRACE
	decs["RBRACK"] = token.RBRACK
	decs["REM"] = token.REM
	decs["REM_ASSIGN"] = token.REM_ASSIGN
	decs["RETURN"] = token.RETURN
	decs["RPAREN"] = token.RPAREN
	decs["SELECT"] = token.SELECT
	decs["SEMICOLON"] = token.SEMICOLON
	decs["SHL"] = token.SHL
	decs["SHL_ASSIGN"] = token.SHL_ASSIGN
	decs["SHR"] = token.SHR
	decs["SHR_ASSIGN"] = token.SHR_ASSIGN
	decs["STRING"] = token.STRING
	decs["STRUCT"] = token.STRUCT
	decs["SUB"] = token.SUB
	decs["SUB_ASSIGN"] = token.SUB_ASSIGN
	decs["SWITCH"] = token.SWITCH
	decs["TYPE"] = token.TYPE
	decs["Token"] = reflect.TypeOf((*token.Token)(nil)).Elem()
	decs["UnaryPrec"] = UntypedNumericConst("6")
	decs["VAR"] = token.VAR
	decs["XOR"] = token.XOR
	decs["XOR_ASSIGN"] = token.XOR_ASSIGN
	packages["go/token"] = &MapPackage{
		PkgName: "token",
		Declarations: decs,
	}
	// "go/types"
	decs = make(map[string]interface{}, 135)
	decs["Array"] = reflect.TypeOf((*types.Array)(nil)).Elem()
	decs["AssertableTo"] = types.AssertableTo
	decs["AssignableTo"] = types.AssignableTo
	decs["Basic"] = reflect.TypeOf((*types.Basic)(nil)).Elem()
	decs["BasicInfo"] = reflect.TypeOf((*types.BasicInfo)(nil)).Elem()
	decs["BasicKind"] = reflect.TypeOf((*types.BasicKind)(nil)).Elem()
	decs["Bool"] = types.Bool
	decs["Builtin"] = reflect.TypeOf((*types.Builtin)(nil)).Elem()
	decs["Byte"] = types.Byte
	decs["Chan"] = reflect.TypeOf((*types.Chan)(nil)).Elem()
	decs["ChanDir"] = reflect.TypeOf((*types.ChanDir)(nil)).Elem()
	decs["CheckExpr"] = types.CheckExpr
	decs["Checker"] = reflect.TypeOf((*types.Checker)(nil)).Elem()
	decs["Comparable"] = types.Comparable
	decs["Complex128"] = types.Complex128
	decs["Complex64"] = types.Complex64
	decs["Config"] = reflect.TypeOf((*types.Config)(nil)).Elem()
	decs["Const"] = reflect.TypeOf((*types.Const)(nil)).Elem()
	decs["ConvertibleTo"] = types.ConvertibleTo
	decs["DefPredeclaredTestFuncs"] = types.DefPredeclaredTestFuncs
	decs["Default"] = types.Default
	decs["Error"] = reflect.TypeOf((*types.Error)(nil)).Elem()
	decs["Eval"] = types.Eval
	decs["ExprString"] = types.ExprString
	decs["FieldVal"] = types.FieldVal
	decs["Float32"] = types.Float32
	decs["Float64"] = types.Float64
	decs["Func"] = reflect.TypeOf((*types.Func)(nil)).Elem()
	decs["Id"] = types.Id
	decs["Identical"] = types.Identical
	decs["IdenticalIgnoreTags"] = types.IdenticalIgnoreTags
	decs["Implements"] = types.Implements
	decs["ImportMode"] = reflect.TypeOf((*types.ImportMode)(nil)).Elem()
	decs["Importer"] = reflect.TypeOf((*types.Importer)(nil)).Elem()
	decs["ImporterFrom"] = reflect.TypeOf((*types.ImporterFrom)(nil)).Elem()
	decs["Info"] = reflect.TypeOf((*types.Info)(nil)).Elem()
	decs["Initializer"] = reflect.TypeOf((*types.Initializer)(nil)).Elem()
	decs["Int"] = types.Int
	decs["Int16"] = types.Int16
	decs["Int32"] = types.Int32
	decs["Int64"] = types.Int64
	decs["Int8"] = types.Int8
	decs["Interface"] = reflect.TypeOf((*types.Interface)(nil)).Elem()
	decs["Invalid"] = types.Invalid
	decs["IsBoolean"] = types.IsBoolean
	decs["IsComplex"] = types.IsComplex
	decs["IsConstType"] = types.IsConstType
	decs["IsFloat"] = types.IsFloat
	decs["IsInteger"] = types.IsInteger
	decs["IsInterface"] = types.IsInterface
	decs["IsNumeric"] = types.IsNumeric
	decs["IsOrdered"] = types.IsOrdered
	decs["IsString"] = types.IsString
	decs["IsUnsigned"] = types.IsUnsigned
	decs["IsUntyped"] = types.IsUntyped
	decs["Label"] = reflect.TypeOf((*types.Label)(nil)).Elem()
	decs["LookupFieldOrMethod"] = types.LookupFieldOrMethod
	decs["Map"] = reflect.TypeOf((*types.Map)(nil)).Elem()
	decs["MethodExpr"] = types.MethodExpr
	decs["MethodSet"] = reflect.TypeOf((*types.MethodSet)(nil)).Elem()
	decs["MethodVal"] = types.MethodVal
	decs["MissingMethod"] = types.MissingMethod
	decs["Named"] = reflect.TypeOf((*types.Named)(nil)).Elem()
	decs["NewArray"] = types.NewArray
	decs["NewChan"] = types.NewChan
	decs["NewChecker"] = types.NewChecker
	decs["NewConst"] = types.NewConst
	decs["NewField"] = types.NewField
	decs["NewFunc"] = types.NewFunc
	decs["NewInterface"] = types.NewInterface
	decs["NewInterfaceType"] = types.NewInterfaceType
	decs["NewLabel"] = types.NewLabel
	decs["NewMap"] = types.NewMap
	decs["NewMethodSet"] = types.NewMethodSet
	decs["NewNamed"] = types.NewNamed
	decs["NewPackage"] = types.NewPackage
	decs["NewParam"] = types.NewParam
	decs["NewPkgName"] = types.NewPkgName
	decs["NewPointer"] = types.NewPointer
	decs["NewScope"] = types.NewScope
	decs["NewSignature"] = types.NewSignature
	decs["NewSlice"] = types.NewSlice
	decs["NewStruct"] = types.NewStruct
	decs["NewTuple"] = types.NewTuple
	decs["NewTypeName"] = types.NewTypeName
	decs["NewVar"] = types.NewVar
	decs["Nil"] = reflect.TypeOf((*types.Nil)(nil)).Elem()
	decs["Object"] = reflect.TypeOf((*types.Object)(nil)).Elem()
	decs["ObjectString"] = types.ObjectString
	decs["Package"] = reflect.TypeOf((*types.Package)(nil)).Elem()
	decs["PkgName"] = reflect.TypeOf((*types.PkgName)(nil)).Elem()
	decs["Pointer"] = reflect.TypeOf((*types.Pointer)(nil)).Elem()
	decs["Qualifier"] = reflect.TypeOf((*types.Qualifier)(nil)).Elem()
	decs["RecvOnly"] = types.RecvOnly
	decs["RelativeTo"] = types.RelativeTo
	decs["Rune"] = types.Rune
	decs["Scope"] = reflect.TypeOf((*types.Scope)(nil)).Elem()
	decs["Selection"] = reflect.TypeOf((*types.Selection)(nil)).Elem()
	decs["SelectionKind"] = reflect.TypeOf((*types.SelectionKind)(nil)).Elem()
	decs["SelectionString"] = types.SelectionString
	decs["SendOnly"] = types.SendOnly
	decs["SendRecv"] = types.SendRecv
	decs["Signature"] = reflect.TypeOf((*types.Signature)(nil)).Elem()
	decs["Sizes"] = reflect.TypeOf((*types.Sizes)(nil)).Elem()
	decs["SizesFor"] = types.SizesFor
	decs["Slice"] = reflect.TypeOf((*types.Slice)(nil)).Elem()
	decs["StdSizes"] = reflect.TypeOf((*types.StdSizes)(nil)).Elem()
	decs["String"] = types.String
	decs["Struct"] = reflect.TypeOf((*types.Struct)(nil)).Elem()
	decs["Tuple"] = reflect.TypeOf((*types.Tuple)(nil)).Elem()
	decs["Typ"] = &types.Typ
	decs["Type"] = reflect.TypeOf((*types.Type)(nil)).Elem()
	decs["TypeAndValue"] = reflect.TypeOf((*types.TypeAndValue)(nil)).Elem()
	decs["TypeName"] = reflect.TypeOf((*types.TypeName)(nil)).Elem()
	decs["TypeString"] = types.TypeString
	decs["Uint"] = types.Uint
	decs["Uint16"] = types.Uint16
	decs["Uint32"] = types.Uint32
	decs["Uint64"] = types.Uint64
	decs["Uint8"] = types.Uint8
	decs["Uintptr"] = types.Uintptr
	decs["Universe"] = &types.Universe
	decs["Unsafe"] = &types.Unsafe
	decs["UnsafePointer"] = types.UnsafePointer
	decs["UntypedBool"] = types.UntypedBool
	decs["UntypedComplex"] = types.UntypedComplex
	decs["UntypedFloat"] = types.UntypedFloat
	decs["UntypedInt"] = types.UntypedInt
	decs["UntypedNil"] = types.UntypedNil
	decs["UntypedRune"] = types.UntypedRune
	decs["UntypedString"] = types.UntypedString
	decs["Var"] = reflect.TypeOf((*types.Var)(nil)).Elem()
	decs["WriteExpr"] = types.WriteExpr
	decs["WriteSignature"] = types.WriteSignature
	decs["WriteType"] = types.WriteType
	packages["go/types"] = &MapPackage{
		PkgName: "types",
		Declarations: decs,
	}
	// "hash"
	decs = make(map[string]interface{}, 3)
	decs["Hash"] = reflect.TypeOf((*hash.Hash)(nil)).Elem()
	decs["Hash32"] = reflect.TypeOf((*hash.Hash32)(nil)).Elem()
	decs["Hash64"] = reflect.TypeOf((*hash.Hash64)(nil)).Elem()
	packages["hash"] = &MapPackage{
		PkgName: "hash",
		Declarations: decs,
	}
	// "hash/adler32"
	decs = make(map[string]interface{}, 3)
	decs["Checksum"] = adler32.Checksum
	decs["New"] = adler32.New
	decs["Size"] = UntypedNumericConst("4")
	packages["hash/adler32"] = &MapPackage{
		PkgName: "adler32",
		Declarations: decs,
	}
	// "hash/crc32"
	decs = make(map[string]interface{}, 12)
	decs["Castagnoli"] = UntypedNumericConst("2197175160")
	decs["Checksum"] = crc32.Checksum
	decs["ChecksumIEEE"] = crc32.ChecksumIEEE
	decs["IEEE"] = UntypedNumericConst("3988292384")
	decs["IEEETable"] = &crc32.IEEETable
	decs["Koopman"] = UntypedNumericConst("3945912366")
	decs["MakeTable"] = crc32.MakeTable
	decs["New"] = crc32.New
	decs["NewIEEE"] = crc32.NewIEEE
	decs["Size"] = UntypedNumericConst("4")
	decs["Table"] = reflect.TypeOf((*crc32.Table)(nil)).Elem()
	decs["Update"] = crc32.Update
	packages["hash/crc32"] = &MapPackage{
		PkgName: "crc32",
		Declarations: decs,
	}
	// "hash/crc64"
	decs = make(map[string]interface{}, 8)
	decs["Checksum"] = crc64.Checksum
	decs["ECMA"] = UntypedNumericConst("14514072000185962306")
	decs["ISO"] = UntypedNumericConst("15564440312192434176")
	decs["MakeTable"] = crc64.MakeTable
	decs["New"] = crc64.New
	decs["Size"] = UntypedNumericConst("8")
	decs["Table"] = reflect.TypeOf((*crc64.Table)(nil)).Elem()
	decs["Update"] = crc64.Update
	packages["hash/crc64"] = &MapPackage{
		PkgName: "crc64",
		Declarations: decs,
	}
	// "hash/fnv"
	decs = make(map[string]interface{}, 6)
	decs["New128"] = fnv.New128
	decs["New128a"] = fnv.New128a
	decs["New32"] = fnv.New32
	decs["New32a"] = fnv.New32a
	decs["New64"] = fnv.New64
	decs["New64a"] = fnv.New64a
	packages["hash/fnv"] = &MapPackage{
		PkgName: "fnv",
		Declarations: decs,
	}
	// "hash/maphash"
	decs = make(map[string]interface{}, 3)
	decs["Hash"] = reflect.TypeOf((*maphash.Hash)(nil)).Elem()
	decs["MakeSeed"] = maphash.MakeSeed
	decs["Seed"] = reflect.TypeOf((*maphash.Seed)(nil)).Elem()
	packages["hash/maphash"] = &MapPackage{
		PkgName: "maphash",
		Declarations: decs,
	}
	// "html"
	decs = make(map[string]interface{}, 2)
	decs["EscapeString"] = html.EscapeString
	decs["UnescapeString"] = html.UnescapeString
	packages["html"] = &MapPackage{
		PkgName: "html",
		Declarations: decs,
	}
	// "html/template"
	decs = make(map[string]interface{}, 36)
	decs["CSS"] = reflect.TypeOf((*template.CSS)(nil)).Elem()
	decs["ErrAmbigContext"] = template.ErrAmbigContext
	decs["ErrBadHTML"] = template.ErrBadHTML
	decs["ErrBranchEnd"] = template.ErrBranchEnd
	decs["ErrEndContext"] = template.ErrEndContext
	decs["ErrNoSuchTemplate"] = template.ErrNoSuchTemplate
	decs["ErrOutputContext"] = template.ErrOutputContext
	decs["ErrPartialCharset"] = template.ErrPartialCharset
	decs["ErrPartialEscape"] = template.ErrPartialEscape
	decs["ErrPredefinedEscaper"] = template.ErrPredefinedEscaper
	decs["ErrRangeLoopReentry"] = template.ErrRangeLoopReentry
	decs["ErrSlashAmbig"] = template.ErrSlashAmbig
	decs["Error"] = reflect.TypeOf((*template.Error)(nil)).Elem()
	decs["ErrorCode"] = reflect.TypeOf((*template.ErrorCode)(nil)).Elem()
	decs["FuncMap"] = reflect.TypeOf((*template.FuncMap)(nil)).Elem()
	decs["HTML"] = reflect.TypeOf((*template.HTML)(nil)).Elem()
	decs["HTMLAttr"] = reflect.TypeOf((*template.HTMLAttr)(nil)).Elem()
	decs["HTMLEscape"] = template.HTMLEscape
	decs["HTMLEscapeString"] = template.HTMLEscapeString
	decs["HTMLEscaper"] = template.HTMLEscaper
	decs["IsTrue"] = template.IsTrue
	decs["JS"] = reflect.TypeOf((*template.JS)(nil)).Elem()
	decs["JSEscape"] = template.JSEscape
	decs["JSEscapeString"] = template.JSEscapeString
	decs["JSEscaper"] = template.JSEscaper
	decs["JSStr"] = reflect.TypeOf((*template.JSStr)(nil)).Elem()
	decs["Must"] = template.Must
	decs["New"] = template.New
	decs["OK"] = template.OK
	decs["ParseFS"] = template.ParseFS
	decs["ParseFiles"] = template.ParseFiles
	decs["ParseGlob"] = template.ParseGlob
	decs["Srcset"] = reflect.TypeOf((*template.Srcset)(nil)).Elem()
	decs["Template"] = reflect.TypeOf((*template.Template)(nil)).Elem()
	decs["URL"] = reflect.TypeOf((*template.URL)(nil)).Elem()
	decs["URLQueryEscaper"] = template.URLQueryEscaper
	packages["html/template"] = &MapPackage{
		PkgName: "template",
		Declarations: decs,
	}
	// "image"
	decs = make(map[string]interface{}, 50)
	decs["Alpha"] = reflect.TypeOf((*image.Alpha)(nil)).Elem()
	decs["Alpha16"] = reflect.TypeOf((*image.Alpha16)(nil)).Elem()
	decs["Black"] = &image.Black
	decs["CMYK"] = reflect.TypeOf((*image.CMYK)(nil)).Elem()
	decs["Config"] = reflect.TypeOf((*image.Config)(nil)).Elem()
	decs["Decode"] = image.Decode
	decs["DecodeConfig"] = image.DecodeConfig
	decs["ErrFormat"] = &image.ErrFormat
	decs["Gray"] = reflect.TypeOf((*image.Gray)(nil)).Elem()
	decs["Gray16"] = reflect.TypeOf((*image.Gray16)(nil)).Elem()
	decs["Image"] = reflect.TypeOf((*image.Image)(nil)).Elem()
	decs["NRGBA"] = reflect.TypeOf((*image.NRGBA)(nil)).Elem()
	decs["NRGBA64"] = reflect.TypeOf((*image.NRGBA64)(nil)).Elem()
	decs["NYCbCrA"] = reflect.TypeOf((*image.NYCbCrA)(nil)).Elem()
	decs["NewAlpha"] = image.NewAlpha
	decs["NewAlpha16"] = image.NewAlpha16
	decs["NewCMYK"] = image.NewCMYK
	decs["NewGray"] = image.NewGray
	decs["NewGray16"] = image.NewGray16
	decs["NewNRGBA"] = image.NewNRGBA
	decs["NewNRGBA64"] = image.NewNRGBA64
	decs["NewNYCbCrA"] = image.NewNYCbCrA
	decs["NewPaletted"] = image.NewPaletted
	decs["NewRGBA"] = image.NewRGBA
	decs["NewRGBA64"] = image.NewRGBA64
	decs["NewUniform"] = image.NewUniform
	decs["NewYCbCr"] = image.NewYCbCr
	decs["Opaque"] = &image.Opaque
	decs["Paletted"] = reflect.TypeOf((*image.Paletted)(nil)).Elem()
	decs["PalettedImage"] = reflect.TypeOf((*image.PalettedImage)(nil)).Elem()
	decs["Point"] = reflect.TypeOf((*image.Point)(nil)).Elem()
	decs["Pt"] = image.Pt
	decs["RGBA"] = reflect.TypeOf((*image.RGBA)(nil)).Elem()
	decs["RGBA64"] = reflect.TypeOf((*image.RGBA64)(nil)).Elem()
	decs["Rect"] = image.Rect
	decs["Rectangle"] = reflect.TypeOf((*image.Rectangle)(nil)).Elem()
	decs["RegisterFormat"] = image.RegisterFormat
	decs["Transparent"] = &image.Transparent
	decs["Uniform"] = reflect.TypeOf((*image.Uniform)(nil)).Elem()
	decs["White"] = &image.White
	decs["YCbCr"] = reflect.TypeOf((*image.YCbCr)(nil)).Elem()
	decs["YCbCrSubsampleRatio"] = reflect.TypeOf((*image.YCbCrSubsampleRatio)(nil)).Elem()
	decs["YCbCrSubsampleRatio410"] = image.YCbCrSubsampleRatio410
	decs["YCbCrSubsampleRatio411"] = image.YCbCrSubsampleRatio411
	decs["YCbCrSubsampleRatio420"] = image.YCbCrSubsampleRatio420
	decs["YCbCrSubsampleRatio422"] = image.YCbCrSubsampleRatio422
	decs["YCbCrSubsampleRatio440"] = image.YCbCrSubsampleRatio440
	decs["YCbCrSubsampleRatio444"] = image.YCbCrSubsampleRatio444
	decs["ZP"] = &image.ZP
	decs["ZR"] = &image.ZR
	packages["image"] = &MapPackage{
		PkgName: "image",
		Declarations: decs,
	}
	// "image/color"
	decs = make(map[string]interface{}, 34)
	decs["Alpha"] = reflect.TypeOf((*color.Alpha)(nil)).Elem()
	decs["Alpha16"] = reflect.TypeOf((*color.Alpha16)(nil)).Elem()
	decs["Alpha16Model"] = &color.Alpha16Model
	decs["AlphaModel"] = &color.AlphaModel
	decs["Black"] = &color.Black
	decs["CMYK"] = reflect.TypeOf((*color.CMYK)(nil)).Elem()
	decs["CMYKModel"] = &color.CMYKModel
	decs["CMYKToRGB"] = color.CMYKToRGB
	decs["Color"] = reflect.TypeOf((*color.Color)(nil)).Elem()
	decs["Gray"] = reflect.TypeOf((*color.Gray)(nil)).Elem()
	decs["Gray16"] = reflect.TypeOf((*color.Gray16)(nil)).Elem()
	decs["Gray16Model"] = &color.Gray16Model
	decs["GrayModel"] = &color.GrayModel
	decs["Model"] = reflect.TypeOf((*color.Model)(nil)).Elem()
	decs["ModelFunc"] = color.ModelFunc
	decs["NRGBA"] = reflect.TypeOf((*color.NRGBA)(nil)).Elem()
	decs["NRGBA64"] = reflect.TypeOf((*color.NRGBA64)(nil)).Elem()
	decs["NRGBA64Model"] = &color.NRGBA64Model
	decs["NRGBAModel"] = &color.NRGBAModel
	decs["NYCbCrA"] = reflect.TypeOf((*color.NYCbCrA)(nil)).Elem()
	decs["NYCbCrAModel"] = &color.NYCbCrAModel
	decs["Opaque"] = &color.Opaque
	decs["Palette"] = reflect.TypeOf((*color.Palette)(nil)).Elem()
	decs["RGBA"] = reflect.TypeOf((*color.RGBA)(nil)).Elem()
	decs["RGBA64"] = reflect.TypeOf((*color.RGBA64)(nil)).Elem()
	decs["RGBA64Model"] = &color.RGBA64Model
	decs["RGBAModel"] = &color.RGBAModel
	decs["RGBToCMYK"] = color.RGBToCMYK
	decs["RGBToYCbCr"] = color.RGBToYCbCr
	decs["Transparent"] = &color.Transparent
	decs["White"] = &color.White
	decs["YCbCr"] = reflect.TypeOf((*color.YCbCr)(nil)).Elem()
	decs["YCbCrModel"] = &color.YCbCrModel
	decs["YCbCrToRGB"] = color.YCbCrToRGB
	packages["image/color"] = &MapPackage{
		PkgName: "color",
		Declarations: decs,
	}
	// "image/color/palette"
	decs = make(map[string]interface{}, 2)
	decs["Plan9"] = &palette.Plan9
	decs["WebSafe"] = &palette.WebSafe
	packages["image/color/palette"] = &MapPackage{
		PkgName: "palette",
		Declarations: decs,
	}
	// "image/draw"
	decs = make(map[string]interface{}, 9)
	decs["Draw"] = draw.Draw
	decs["DrawMask"] = draw.DrawMask
	decs["Drawer"] = reflect.TypeOf((*draw.Drawer)(nil)).Elem()
	decs["FloydSteinberg"] = &draw.FloydSteinberg
	decs["Image"] = reflect.TypeOf((*draw.Image)(nil)).Elem()
	decs["Op"] = reflect.TypeOf((*draw.Op)(nil)).Elem()
	decs["Over"] = draw.Over
	decs["Quantizer"] = reflect.TypeOf((*draw.Quantizer)(nil)).Elem()
	decs["Src"] = draw.Src
	packages["image/draw"] = &MapPackage{
		PkgName: "draw",
		Declarations: decs,
	}
	// "image/gif"
	decs = make(map[string]interface{}, 10)
	decs["Decode"] = gif.Decode
	decs["DecodeAll"] = gif.DecodeAll
	decs["DecodeConfig"] = gif.DecodeConfig
	decs["DisposalBackground"] = UntypedNumericConst("2")
	decs["DisposalNone"] = UntypedNumericConst("1")
	decs["DisposalPrevious"] = UntypedNumericConst("3")
	decs["Encode"] = gif.Encode
	decs["EncodeAll"] = gif.EncodeAll
	decs["GIF"] = reflect.TypeOf((*gif.GIF)(nil)).Elem()
	decs["Options"] = reflect.TypeOf((*gif.Options)(nil)).Elem()
	packages["image/gif"] = &MapPackage{
		PkgName: "gif",
		Declarations: decs,
	}
	// "image/jpeg"
	decs = make(map[string]interface{}, 8)
	decs["Decode"] = jpeg.Decode
	decs["DecodeConfig"] = jpeg.DecodeConfig
	decs["DefaultQuality"] = UntypedNumericConst("75")
	decs["Encode"] = jpeg.Encode
	decs["FormatError"] = reflect.TypeOf((*jpeg.FormatError)(nil)).Elem()
	decs["Options"] = reflect.TypeOf((*jpeg.Options)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*jpeg.Reader)(nil)).Elem()
	decs["UnsupportedError"] = reflect.TypeOf((*jpeg.UnsupportedError)(nil)).Elem()
	packages["image/jpeg"] = &MapPackage{
		PkgName: "jpeg",
		Declarations: decs,
	}
	// "image/png"
	decs = make(map[string]interface{}, 13)
	decs["BestCompression"] = png.BestCompression
	decs["BestSpeed"] = png.BestSpeed
	decs["CompressionLevel"] = reflect.TypeOf((*png.CompressionLevel)(nil)).Elem()
	decs["Decode"] = png.Decode
	decs["DecodeConfig"] = png.DecodeConfig
	decs["DefaultCompression"] = png.DefaultCompression
	decs["Encode"] = png.Encode
	decs["Encoder"] = reflect.TypeOf((*png.Encoder)(nil)).Elem()
	decs["EncoderBuffer"] = reflect.TypeOf((*png.EncoderBuffer)(nil)).Elem()
	decs["EncoderBufferPool"] = reflect.TypeOf((*png.EncoderBufferPool)(nil)).Elem()
	decs["FormatError"] = reflect.TypeOf((*png.FormatError)(nil)).Elem()
	decs["NoCompression"] = png.NoCompression
	decs["UnsupportedError"] = reflect.TypeOf((*png.UnsupportedError)(nil)).Elem()
	packages["image/png"] = &MapPackage{
		PkgName: "png",
		Declarations: decs,
	}
	// "index/suffixarray"
	decs = make(map[string]interface{}, 2)
	decs["Index"] = reflect.TypeOf((*suffixarray.Index)(nil)).Elem()
	decs["New"] = suffixarray.New
	packages["index/suffixarray"] = &MapPackage{
		PkgName: "suffixarray",
		Declarations: decs,
	}
	// "io"
	decs = make(map[string]interface{}, 50)
	decs["ByteReader"] = reflect.TypeOf((*io.ByteReader)(nil)).Elem()
	decs["ByteScanner"] = reflect.TypeOf((*io.ByteScanner)(nil)).Elem()
	decs["ByteWriter"] = reflect.TypeOf((*io.ByteWriter)(nil)).Elem()
	decs["Closer"] = reflect.TypeOf((*io.Closer)(nil)).Elem()
	decs["Copy"] = io.Copy
	decs["CopyBuffer"] = io.CopyBuffer
	decs["CopyN"] = io.CopyN
	decs["Discard"] = &io.Discard
	decs["EOF"] = &io.EOF
	decs["ErrClosedPipe"] = &io.ErrClosedPipe
	decs["ErrNoProgress"] = &io.ErrNoProgress
	decs["ErrShortBuffer"] = &io.ErrShortBuffer
	decs["ErrShortWrite"] = &io.ErrShortWrite
	decs["ErrUnexpectedEOF"] = &io.ErrUnexpectedEOF
	decs["LimitReader"] = io.LimitReader
	decs["LimitedReader"] = reflect.TypeOf((*io.LimitedReader)(nil)).Elem()
	decs["MultiReader"] = io.MultiReader
	decs["MultiWriter"] = io.MultiWriter
	decs["NewSectionReader"] = io.NewSectionReader
	decs["NopCloser"] = io.NopCloser
	decs["Pipe"] = io.Pipe
	decs["PipeReader"] = reflect.TypeOf((*io.PipeReader)(nil)).Elem()
	decs["PipeWriter"] = reflect.TypeOf((*io.PipeWriter)(nil)).Elem()
	decs["ReadAll"] = io.ReadAll
	decs["ReadAtLeast"] = io.ReadAtLeast
	decs["ReadCloser"] = reflect.TypeOf((*io.ReadCloser)(nil)).Elem()
	decs["ReadFull"] = io.ReadFull
	decs["ReadSeekCloser"] = reflect.TypeOf((*io.ReadSeekCloser)(nil)).Elem()
	decs["ReadSeeker"] = reflect.TypeOf((*io.ReadSeeker)(nil)).Elem()
	decs["ReadWriteCloser"] = reflect.TypeOf((*io.ReadWriteCloser)(nil)).Elem()
	decs["ReadWriteSeeker"] = reflect.TypeOf((*io.ReadWriteSeeker)(nil)).Elem()
	decs["ReadWriter"] = reflect.TypeOf((*io.ReadWriter)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*io.Reader)(nil)).Elem()
	decs["ReaderAt"] = reflect.TypeOf((*io.ReaderAt)(nil)).Elem()
	decs["ReaderFrom"] = reflect.TypeOf((*io.ReaderFrom)(nil)).Elem()
	decs["RuneReader"] = reflect.TypeOf((*io.RuneReader)(nil)).Elem()
	decs["RuneScanner"] = reflect.TypeOf((*io.RuneScanner)(nil)).Elem()
	decs["SectionReader"] = reflect.TypeOf((*io.SectionReader)(nil)).Elem()
	decs["SeekCurrent"] = UntypedNumericConst("1")
	decs["SeekEnd"] = UntypedNumericConst("2")
	decs["SeekStart"] = UntypedNumericConst("0")
	decs["Seeker"] = reflect.TypeOf((*io.Seeker)(nil)).Elem()
	decs["StringWriter"] = reflect.TypeOf((*io.StringWriter)(nil)).Elem()
	decs["TeeReader"] = io.TeeReader
	decs["WriteCloser"] = reflect.TypeOf((*io.WriteCloser)(nil)).Elem()
	decs["WriteSeeker"] = reflect.TypeOf((*io.WriteSeeker)(nil)).Elem()
	decs["WriteString"] = io.WriteString
	decs["Writer"] = reflect.TypeOf((*io.Writer)(nil)).Elem()
	decs["WriterAt"] = reflect.TypeOf((*io.WriterAt)(nil)).Elem()
	decs["WriterTo"] = reflect.TypeOf((*io.WriterTo)(nil)).Elem()
	packages["io"] = &MapPackage{
		PkgName: "io",
		Declarations: decs,
	}
	// "io/fs"
	decs = make(map[string]interface{}, 41)
	decs["DirEntry"] = reflect.TypeOf((*fs.DirEntry)(nil)).Elem()
	decs["ErrClosed"] = &fs.ErrClosed
	decs["ErrExist"] = &fs.ErrExist
	decs["ErrInvalid"] = &fs.ErrInvalid
	decs["ErrNotExist"] = &fs.ErrNotExist
	decs["ErrPermission"] = &fs.ErrPermission
	decs["FS"] = reflect.TypeOf((*fs.FS)(nil)).Elem()
	decs["File"] = reflect.TypeOf((*fs.File)(nil)).Elem()
	decs["FileInfo"] = reflect.TypeOf((*fs.FileInfo)(nil)).Elem()
	decs["FileMode"] = reflect.TypeOf((*fs.FileMode)(nil)).Elem()
	decs["Glob"] = fs.Glob
	decs["GlobFS"] = reflect.TypeOf((*fs.GlobFS)(nil)).Elem()
	decs["ModeAppend"] = fs.ModeAppend
	decs["ModeCharDevice"] = fs.ModeCharDevice
	decs["ModeDevice"] = fs.ModeDevice
	decs["ModeDir"] = fs.ModeDir
	decs["ModeExclusive"] = fs.ModeExclusive
	decs["ModeIrregular"] = fs.ModeIrregular
	decs["ModeNamedPipe"] = fs.ModeNamedPipe
	decs["ModePerm"] = fs.ModePerm
	decs["ModeSetgid"] = fs.ModeSetgid
	decs["ModeSetuid"] = fs.ModeSetuid
	decs["ModeSocket"] = fs.ModeSocket
	decs["ModeSticky"] = fs.ModeSticky
	decs["ModeSymlink"] = fs.ModeSymlink
	decs["ModeTemporary"] = fs.ModeTemporary
	decs["ModeType"] = fs.ModeType
	decs["PathError"] = reflect.TypeOf((*fs.PathError)(nil)).Elem()
	decs["ReadDir"] = fs.ReadDir
	decs["ReadDirFS"] = reflect.TypeOf((*fs.ReadDirFS)(nil)).Elem()
	decs["ReadDirFile"] = reflect.TypeOf((*fs.ReadDirFile)(nil)).Elem()
	decs["ReadFile"] = fs.ReadFile
	decs["ReadFileFS"] = reflect.TypeOf((*fs.ReadFileFS)(nil)).Elem()
	decs["SkipDir"] = &fs.SkipDir
	decs["Stat"] = fs.Stat
	decs["StatFS"] = reflect.TypeOf((*fs.StatFS)(nil)).Elem()
	decs["Sub"] = fs.Sub
	decs["SubFS"] = reflect.TypeOf((*fs.SubFS)(nil)).Elem()
	decs["ValidPath"] = fs.ValidPath
	decs["WalkDir"] = fs.WalkDir
	decs["WalkDirFunc"] = reflect.TypeOf((*fs.WalkDirFunc)(nil)).Elem()
	packages["io/fs"] = &MapPackage{
		PkgName: "fs",
		Declarations: decs,
	}
	// "io/ioutil"
	decs = make(map[string]interface{}, 8)
	decs["Discard"] = &ioutil.Discard
	decs["NopCloser"] = ioutil.NopCloser
	decs["ReadAll"] = ioutil.ReadAll
	decs["ReadDir"] = ioutil.ReadDir
	decs["ReadFile"] = ioutil.ReadFile
	decs["TempDir"] = ioutil.TempDir
	decs["TempFile"] = ioutil.TempFile
	decs["WriteFile"] = ioutil.WriteFile
	packages["io/ioutil"] = &MapPackage{
		PkgName: "ioutil",
		Declarations: decs,
	}
	// "log"
	decs = make(map[string]interface{}, 27)
	decs["Default"] = log.Default
	decs["Fatal"] = log.Fatal
	decs["Fatalf"] = log.Fatalf
	decs["Fatalln"] = log.Fatalln
	decs["Flags"] = log.Flags
	decs["LUTC"] = UntypedNumericConst("32")
	decs["Ldate"] = UntypedNumericConst("1")
	decs["Llongfile"] = UntypedNumericConst("8")
	decs["Lmicroseconds"] = UntypedNumericConst("4")
	decs["Lmsgprefix"] = UntypedNumericConst("64")
	decs["Logger"] = reflect.TypeOf((*log.Logger)(nil)).Elem()
	decs["Lshortfile"] = UntypedNumericConst("16")
	decs["LstdFlags"] = UntypedNumericConst("3")
	decs["Ltime"] = UntypedNumericConst("2")
	decs["New"] = log.New
	decs["Output"] = log.Output
	decs["Panic"] = log.Panic
	decs["Panicf"] = log.Panicf
	decs["Panicln"] = log.Panicln
	decs["Prefix"] = log.Prefix
	decs["Print"] = log.Print
	decs["Printf"] = log.Printf
	decs["Println"] = log.Println
	decs["SetFlags"] = log.SetFlags
	decs["SetOutput"] = log.SetOutput
	decs["SetPrefix"] = log.SetPrefix
	decs["Writer"] = log.Writer
	packages["log"] = &MapPackage{
		PkgName: "log",
		Declarations: decs,
	}
	// "log/syslog"
	decs = make(map[string]interface{}, 33)
	decs["Dial"] = syslog.Dial
	decs["LOG_ALERT"] = syslog.LOG_ALERT
	decs["LOG_AUTH"] = syslog.LOG_AUTH
	decs["LOG_AUTHPRIV"] = syslog.LOG_AUTHPRIV
	decs["LOG_CRIT"] = syslog.LOG_CRIT
	decs["LOG_CRON"] = syslog.LOG_CRON
	decs["LOG_DAEMON"] = syslog.LOG_DAEMON
	decs["LOG_DEBUG"] = syslog.LOG_DEBUG
	decs["LOG_EMERG"] = syslog.LOG_EMERG
	decs["LOG_ERR"] = syslog.LOG_ERR
	decs["LOG_FTP"] = syslog.LOG_FTP
	decs["LOG_INFO"] = syslog.LOG_INFO
	decs["LOG_KERN"] = syslog.LOG_KERN
	decs["LOG_LOCAL0"] = syslog.LOG_LOCAL0
	decs["LOG_LOCAL1"] = syslog.LOG_LOCAL1
	decs["LOG_LOCAL2"] = syslog.LOG_LOCAL2
	decs["LOG_LOCAL3"] = syslog.LOG_LOCAL3
	decs["LOG_LOCAL4"] = syslog.LOG_LOCAL4
	decs["LOG_LOCAL5"] = syslog.LOG_LOCAL5
	decs["LOG_LOCAL6"] = syslog.LOG_LOCAL6
	decs["LOG_LOCAL7"] = syslog.LOG_LOCAL7
	decs["LOG_LPR"] = syslog.LOG_LPR
	decs["LOG_MAIL"] = syslog.LOG_MAIL
	decs["LOG_NEWS"] = syslog.LOG_NEWS
	decs["LOG_NOTICE"] = syslog.LOG_NOTICE
	decs["LOG_SYSLOG"] = syslog.LOG_SYSLOG
	decs["LOG_USER"] = syslog.LOG_USER
	decs["LOG_UUCP"] = syslog.LOG_UUCP
	decs["LOG_WARNING"] = syslog.LOG_WARNING
	decs["New"] = syslog.New
	decs["NewLogger"] = syslog.NewLogger
	decs["Priority"] = reflect.TypeOf((*syslog.Priority)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*syslog.Writer)(nil)).Elem()
	packages["log/syslog"] = &MapPackage{
		PkgName: "syslog",
		Declarations: decs,
	}
	// "math"
	decs = make(map[string]interface{}, 94)
	decs["Abs"] = math.Abs
	decs["Acos"] = math.Acos
	decs["Acosh"] = math.Acosh
	decs["Asin"] = math.Asin
	decs["Asinh"] = math.Asinh
	decs["Atan"] = math.Atan
	decs["Atan2"] = math.Atan2
	decs["Atanh"] = math.Atanh
	decs["Cbrt"] = math.Cbrt
	decs["Ceil"] = math.Ceil
	decs["Copysign"] = math.Copysign
	decs["Cos"] = math.Cos
	decs["Cosh"] = math.Cosh
	decs["Dim"] = math.Dim
	decs["E"] = UntypedNumericConst("2.71828182845904523536028747135266249775724709369995957496696763")
	decs["Erf"] = math.Erf
	decs["Erfc"] = math.Erfc
	decs["Erfcinv"] = math.Erfcinv
	decs["Erfinv"] = math.Erfinv
	decs["Exp"] = math.Exp
	decs["Exp2"] = math.Exp2
	decs["Expm1"] = math.Expm1
	decs["FMA"] = math.FMA
	decs["Float32bits"] = math.Float32bits
	decs["Float32frombits"] = math.Float32frombits
	decs["Float64bits"] = math.Float64bits
	decs["Float64frombits"] = math.Float64frombits
	decs["Floor"] = math.Floor
	decs["Frexp"] = math.Frexp
	decs["Gamma"] = math.Gamma
	decs["Hypot"] = math.Hypot
	decs["Ilogb"] = math.Ilogb
	decs["Inf"] = math.Inf
	decs["IsInf"] = math.IsInf
	decs["IsNaN"] = math.IsNaN
	decs["J0"] = math.J0
	decs["J1"] = math.J1
	decs["Jn"] = math.Jn
	decs["Ldexp"] = math.Ldexp
	decs["Lgamma"] = math.Lgamma
	decs["Ln10"] = UntypedNumericConst("2.3025850929940456840179914546843642076011014886287729760333279")
	decs["Ln2"] = UntypedNumericConst("0.693147180559945309417232121458176568075500134360255254120680009")
	decs["Log"] = math.Log
	decs["Log10"] = math.Log10
	decs["Log10E"] = UntypedNumericConst("10000000000000000000000000000000000000000000000000000000000000/23025850929940456840179914546843642076011014886287729760333279")
	decs["Log1p"] = math.Log1p
	decs["Log2"] = math.Log2
	decs["Log2E"] = UntypedNumericConst("1000000000000000000000000000000000000000000000000000000000000000/693147180559945309417232121458176568075500134360255254120680009")
	decs["Logb"] = math.Logb
	decs["Max"] = math.Max
	decs["MaxFloat32"] = UntypedNumericConst("340282346638528859811704183484516925440.0")
	decs["MaxFloat64"] = UntypedNumericConst("179769313486231570814527423731704356798100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0")
	decs["MaxInt16"] = UntypedNumericConst("32767")
	decs["MaxInt32"] = UntypedNumericConst("2147483647")
	decs["MaxInt64"] = UntypedNumericConst("9223372036854775807")
	decs["MaxInt8"] = UntypedNumericConst("127")
	decs["MaxUint16"] = UntypedNumericConst("65535")
	decs["MaxUint32"] = UntypedNumericConst("4294967295")
	decs["MaxUint64"] = UntypedNumericConst("18446744073709551615")
	decs["MaxUint8"] = UntypedNumericConst("255")
	decs["Min"] = math.Min
	decs["MinInt16"] = UntypedNumericConst("-32768")
	decs["MinInt32"] = UntypedNumericConst("-2147483648")
	decs["MinInt64"] = UntypedNumericConst("-9223372036854775808")
	decs["MinInt8"] = UntypedNumericConst("-128")
	decs["Mod"] = math.Mod
	decs["Modf"] = math.Modf
	decs["NaN"] = math.NaN
	decs["Nextafter"] = math.Nextafter
	decs["Nextafter32"] = math.Nextafter32
	decs["Phi"] = UntypedNumericConst("1.61803398874989484820458683436563811772030917980576286213544862")
	decs["Pi"] = UntypedNumericConst("3.14159265358979323846264338327950288419716939937510582097494459")
	decs["Pow"] = math.Pow
	decs["Pow10"] = math.Pow10
	decs["Remainder"] = math.Remainder
	decs["Round"] = math.Round
	decs["RoundToEven"] = math.RoundToEven
	decs["Signbit"] = math.Signbit
	decs["Sin"] = math.Sin
	decs["Sincos"] = math.Sincos
	decs["Sinh"] = math.Sinh
	decs["SmallestNonzeroFloat32"] = UntypedNumericConst("1.40129846432481707092372958328991613128e-45")
	decs["SmallestNonzeroFloat64"] = UntypedNumericConst("4.940656458412465441765687928682213723651e-324")
	decs["Sqrt"] = math.Sqrt
	decs["Sqrt2"] = UntypedNumericConst("1.41421356237309504880168872420969807856967187537694807317667974")
	decs["SqrtE"] = UntypedNumericConst("1.64872127070012814684865078781416357165377610071014801157507931")
	decs["SqrtPhi"] = UntypedNumericConst("1.27201964951406896425242246173749149171560804184009624861664038")
	decs["SqrtPi"] = UntypedNumericConst("1.77245385090551602729816748334114518279754945612238712821380779")
	decs["Tan"] = math.Tan
	decs["Tanh"] = math.Tanh
	decs["Trunc"] = math.Trunc
	decs["Y0"] = math.Y0
	decs["Y1"] = math.Y1
	decs["Yn"] = math.Yn
	packages["math"] = &MapPackage{
		PkgName: "math",
		Declarations: decs,
	}
	// "math/big"
	decs = make(map[string]interface{}, 25)
	decs["Above"] = big.Above
	decs["Accuracy"] = reflect.TypeOf((*big.Accuracy)(nil)).Elem()
	decs["AwayFromZero"] = big.AwayFromZero
	decs["Below"] = big.Below
	decs["ErrNaN"] = reflect.TypeOf((*big.ErrNaN)(nil)).Elem()
	decs["Exact"] = big.Exact
	decs["Float"] = reflect.TypeOf((*big.Float)(nil)).Elem()
	decs["Int"] = reflect.TypeOf((*big.Int)(nil)).Elem()
	decs["Jacobi"] = big.Jacobi
	decs["MaxBase"] = UntypedNumericConst("62")
	decs["MaxExp"] = UntypedNumericConst("2147483647")
	decs["MaxPrec"] = UntypedNumericConst("4294967295")
	decs["MinExp"] = UntypedNumericConst("-2147483648")
	decs["NewFloat"] = big.NewFloat
	decs["NewInt"] = big.NewInt
	decs["NewRat"] = big.NewRat
	decs["ParseFloat"] = big.ParseFloat
	decs["Rat"] = reflect.TypeOf((*big.Rat)(nil)).Elem()
	decs["RoundingMode"] = reflect.TypeOf((*big.RoundingMode)(nil)).Elem()
	decs["ToNearestAway"] = big.ToNearestAway
	decs["ToNearestEven"] = big.ToNearestEven
	decs["ToNegativeInf"] = big.ToNegativeInf
	decs["ToPositiveInf"] = big.ToPositiveInf
	decs["ToZero"] = big.ToZero
	decs["Word"] = reflect.TypeOf((*big.Word)(nil)).Elem()
	packages["math/big"] = &MapPackage{
		PkgName: "big",
		Declarations: decs,
	}
	// "math/bits"
	decs = make(map[string]interface{}, 50)
	decs["Add"] = bits.Add
	decs["Add32"] = bits.Add32
	decs["Add64"] = bits.Add64
	decs["Div"] = bits.Div
	decs["Div32"] = bits.Div32
	decs["Div64"] = bits.Div64
	decs["LeadingZeros"] = bits.LeadingZeros
	decs["LeadingZeros16"] = bits.LeadingZeros16
	decs["LeadingZeros32"] = bits.LeadingZeros32
	decs["LeadingZeros64"] = bits.LeadingZeros64
	decs["LeadingZeros8"] = bits.LeadingZeros8
	decs["Len"] = bits.Len
	decs["Len16"] = bits.Len16
	decs["Len32"] = bits.Len32
	decs["Len64"] = bits.Len64
	decs["Len8"] = bits.Len8
	decs["Mul"] = bits.Mul
	decs["Mul32"] = bits.Mul32
	decs["Mul64"] = bits.Mul64
	decs["OnesCount"] = bits.OnesCount
	decs["OnesCount16"] = bits.OnesCount16
	decs["OnesCount32"] = bits.OnesCount32
	decs["OnesCount64"] = bits.OnesCount64
	decs["OnesCount8"] = bits.OnesCount8
	decs["Rem"] = bits.Rem
	decs["Rem32"] = bits.Rem32
	decs["Rem64"] = bits.Rem64
	decs["Reverse"] = bits.Reverse
	decs["Reverse16"] = bits.Reverse16
	decs["Reverse32"] = bits.Reverse32
	decs["Reverse64"] = bits.Reverse64
	decs["Reverse8"] = bits.Reverse8
	decs["ReverseBytes"] = bits.ReverseBytes
	decs["ReverseBytes16"] = bits.ReverseBytes16
	decs["ReverseBytes32"] = bits.ReverseBytes32
	decs["ReverseBytes64"] = bits.ReverseBytes64
	decs["RotateLeft"] = bits.RotateLeft
	decs["RotateLeft16"] = bits.RotateLeft16
	decs["RotateLeft32"] = bits.RotateLeft32
	decs["RotateLeft64"] = bits.RotateLeft64
	decs["RotateLeft8"] = bits.RotateLeft8
	decs["Sub"] = bits.Sub
	decs["Sub32"] = bits.Sub32
	decs["Sub64"] = bits.Sub64
	decs["TrailingZeros"] = bits.TrailingZeros
	decs["TrailingZeros16"] = bits.TrailingZeros16
	decs["TrailingZeros32"] = bits.TrailingZeros32
	decs["TrailingZeros64"] = bits.TrailingZeros64
	decs["TrailingZeros8"] = bits.TrailingZeros8
	decs["UintSize"] = UntypedNumericConst("64")
	packages["math/bits"] = &MapPackage{
		PkgName: "bits",
		Declarations: decs,
	}
	// "math/cmplx"
	decs = make(map[string]interface{}, 27)
	decs["Abs"] = cmplx.Abs
	decs["Acos"] = cmplx.Acos
	decs["Acosh"] = cmplx.Acosh
	decs["Asin"] = cmplx.Asin
	decs["Asinh"] = cmplx.Asinh
	decs["Atan"] = cmplx.Atan
	decs["Atanh"] = cmplx.Atanh
	decs["Conj"] = cmplx.Conj
	decs["Cos"] = cmplx.Cos
	decs["Cosh"] = cmplx.Cosh
	decs["Cot"] = cmplx.Cot
	decs["Exp"] = cmplx.Exp
	decs["Inf"] = cmplx.Inf
	decs["IsInf"] = cmplx.IsInf
	decs["IsNaN"] = cmplx.IsNaN
	decs["Log"] = cmplx.Log
	decs["Log10"] = cmplx.Log10
	decs["NaN"] = cmplx.NaN
	decs["Phase"] = cmplx.Phase
	decs["Polar"] = cmplx.Polar
	decs["Pow"] = cmplx.Pow
	decs["Rect"] = cmplx.Rect
	decs["Sin"] = cmplx.Sin
	decs["Sinh"] = cmplx.Sinh
	decs["Sqrt"] = cmplx.Sqrt
	decs["Tan"] = cmplx.Tan
	decs["Tanh"] = cmplx.Tanh
	packages["math/cmplx"] = &MapPackage{
		PkgName: "cmplx",
		Declarations: decs,
	}
	// "math/rand"
	decs = make(map[string]interface{}, 23)
	decs["ExpFloat64"] = rand_.ExpFloat64
	decs["Float32"] = rand_.Float32
	decs["Float64"] = rand_.Float64
	decs["Int"] = rand_.Int
	decs["Int31"] = rand_.Int31
	decs["Int31n"] = rand_.Int31n
	decs["Int63"] = rand_.Int63
	decs["Int63n"] = rand_.Int63n
	decs["Intn"] = rand_.Intn
	decs["New"] = rand_.New
	decs["NewSource"] = rand_.NewSource
	decs["NewZipf"] = rand_.NewZipf
	decs["NormFloat64"] = rand_.NormFloat64
	decs["Perm"] = rand_.Perm
	decs["Rand"] = reflect.TypeOf((*rand_.Rand)(nil)).Elem()
	decs["Read"] = rand_.Read
	decs["Seed"] = rand_.Seed
	decs["Shuffle"] = rand_.Shuffle
	decs["Source"] = reflect.TypeOf((*rand_.Source)(nil)).Elem()
	decs["Source64"] = reflect.TypeOf((*rand_.Source64)(nil)).Elem()
	decs["Uint32"] = rand_.Uint32
	decs["Uint64"] = rand_.Uint64
	decs["Zipf"] = reflect.TypeOf((*rand_.Zipf)(nil)).Elem()
	packages["math/rand"] = &MapPackage{
		PkgName: "rand",
		Declarations: decs,
	}
	// "mime"
	decs = make(map[string]interface{}, 10)
	decs["AddExtensionType"] = mime.AddExtensionType
	decs["BEncoding"] = mime.BEncoding
	decs["ErrInvalidMediaParameter"] = &mime.ErrInvalidMediaParameter
	decs["ExtensionsByType"] = mime.ExtensionsByType
	decs["FormatMediaType"] = mime.FormatMediaType
	decs["ParseMediaType"] = mime.ParseMediaType
	decs["QEncoding"] = mime.QEncoding
	decs["TypeByExtension"] = mime.TypeByExtension
	decs["WordDecoder"] = reflect.TypeOf((*mime.WordDecoder)(nil)).Elem()
	decs["WordEncoder"] = reflect.TypeOf((*mime.WordEncoder)(nil)).Elem()
	packages["mime"] = &MapPackage{
		PkgName: "mime",
		Declarations: decs,
	}
	// "mime/multipart"
	decs = make(map[string]interface{}, 9)
	decs["ErrMessageTooLarge"] = &multipart.ErrMessageTooLarge
	decs["File"] = reflect.TypeOf((*multipart.File)(nil)).Elem()
	decs["FileHeader"] = reflect.TypeOf((*multipart.FileHeader)(nil)).Elem()
	decs["Form"] = reflect.TypeOf((*multipart.Form)(nil)).Elem()
	decs["NewReader"] = multipart.NewReader
	decs["NewWriter"] = multipart.NewWriter
	decs["Part"] = reflect.TypeOf((*multipart.Part)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*multipart.Reader)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*multipart.Writer)(nil)).Elem()
	packages["mime/multipart"] = &MapPackage{
		PkgName: "multipart",
		Declarations: decs,
	}
	// "mime/quotedprintable"
	decs = make(map[string]interface{}, 4)
	decs["NewReader"] = quotedprintable.NewReader
	decs["NewWriter"] = quotedprintable.NewWriter
	decs["Reader"] = reflect.TypeOf((*quotedprintable.Reader)(nil)).Elem()
	decs["Writer"] = reflect.TypeOf((*quotedprintable.Writer)(nil)).Elem()
	packages["mime/quotedprintable"] = &MapPackage{
		PkgName: "quotedprintable",
		Declarations: decs,
	}
	// "net"
	decs = make(map[string]interface{}, 98)
	decs["Addr"] = reflect.TypeOf((*net.Addr)(nil)).Elem()
	decs["AddrError"] = reflect.TypeOf((*net.AddrError)(nil)).Elem()
	decs["Buffers"] = reflect.TypeOf((*net.Buffers)(nil)).Elem()
	decs["CIDRMask"] = net.CIDRMask
	decs["Conn"] = reflect.TypeOf((*net.Conn)(nil)).Elem()
	decs["DNSConfigError"] = reflect.TypeOf((*net.DNSConfigError)(nil)).Elem()
	decs["DNSError"] = reflect.TypeOf((*net.DNSError)(nil)).Elem()
	decs["DefaultResolver"] = &net.DefaultResolver
	decs["Dial"] = net.Dial
	decs["DialIP"] = net.DialIP
	decs["DialTCP"] = net.DialTCP
	decs["DialTimeout"] = net.DialTimeout
	decs["DialUDP"] = net.DialUDP
	decs["DialUnix"] = net.DialUnix
	decs["Dialer"] = reflect.TypeOf((*net.Dialer)(nil)).Elem()
	decs["ErrClosed"] = &net.ErrClosed
	decs["ErrWriteToConnected"] = &net.ErrWriteToConnected
	decs["Error"] = reflect.TypeOf((*net.Error)(nil)).Elem()
	decs["FileConn"] = net.FileConn
	decs["FileListener"] = net.FileListener
	decs["FilePacketConn"] = net.FilePacketConn
	decs["FlagBroadcast"] = net.FlagBroadcast
	decs["FlagLoopback"] = net.FlagLoopback
	decs["FlagMulticast"] = net.FlagMulticast
	decs["FlagPointToPoint"] = net.FlagPointToPoint
	decs["FlagUp"] = net.FlagUp
	decs["Flags"] = reflect.TypeOf((*net.Flags)(nil)).Elem()
	decs["HardwareAddr"] = reflect.TypeOf((*net.HardwareAddr)(nil)).Elem()
	decs["IP"] = reflect.TypeOf((*net.IP)(nil)).Elem()
	decs["IPAddr"] = reflect.TypeOf((*net.IPAddr)(nil)).Elem()
	decs["IPConn"] = reflect.TypeOf((*net.IPConn)(nil)).Elem()
	decs["IPMask"] = reflect.TypeOf((*net.IPMask)(nil)).Elem()
	decs["IPNet"] = reflect.TypeOf((*net.IPNet)(nil)).Elem()
	decs["IPv4"] = net.IPv4
	decs["IPv4Mask"] = net.IPv4Mask
	decs["IPv4allrouter"] = &net.IPv4allrouter
	decs["IPv4allsys"] = &net.IPv4allsys
	decs["IPv4bcast"] = &net.IPv4bcast
	decs["IPv4len"] = UntypedNumericConst("4")
	decs["IPv4zero"] = &net.IPv4zero
	decs["IPv6interfacelocalallnodes"] = &net.IPv6interfacelocalallnodes
	decs["IPv6len"] = UntypedNumericConst("16")
	decs["IPv6linklocalallnodes"] = &net.IPv6linklocalallnodes
	decs["IPv6linklocalallrouters"] = &net.IPv6linklocalallrouters
	decs["IPv6loopback"] = &net.IPv6loopback
	decs["IPv6unspecified"] = &net.IPv6unspecified
	decs["IPv6zero"] = &net.IPv6zero
	decs["Interface"] = reflect.TypeOf((*net.Interface)(nil)).Elem()
	decs["InterfaceAddrs"] = net.InterfaceAddrs
	decs["InterfaceByIndex"] = net.InterfaceByIndex
	decs["InterfaceByName"] = net.InterfaceByName
	decs["Interfaces"] = net.Interfaces
	decs["InvalidAddrError"] = reflect.TypeOf((*net.InvalidAddrError)(nil)).Elem()
	decs["JoinHostPort"] = net.JoinHostPort
	decs["Listen"] = net.Listen
	decs["ListenConfig"] = reflect.TypeOf((*net.ListenConfig)(nil)).Elem()
	decs["ListenIP"] = net.ListenIP
	decs["ListenMulticastUDP"] = net.ListenMulticastUDP
	decs["ListenPacket"] = net.ListenPacket
	decs["ListenTCP"] = net.ListenTCP
	decs["ListenUDP"] = net.ListenUDP
	decs["ListenUnix"] = net.ListenUnix
	decs["ListenUnixgram"] = net.ListenUnixgram
	decs["Listener"] = reflect.TypeOf((*net.Listener)(nil)).Elem()
	decs["LookupAddr"] = net.LookupAddr
	decs["LookupCNAME"] = net.LookupCNAME
	decs["LookupHost"] = net.LookupHost
	decs["LookupIP"] = net.LookupIP
	decs["LookupMX"] = net.LookupMX
	decs["LookupNS"] = net.LookupNS
	decs["LookupPort"] = net.LookupPort
	decs["LookupSRV"] = net.LookupSRV
	decs["LookupTXT"] = net.LookupTXT
	decs["MX"] = reflect.TypeOf((*net.MX)(nil)).Elem()
	decs["NS"] = reflect.TypeOf((*net.NS)(nil)).Elem()
	decs["OpError"] = reflect.TypeOf((*net.OpError)(nil)).Elem()
	decs["PacketConn"] = reflect.TypeOf((*net.PacketConn)(nil)).Elem()
	decs["ParseCIDR"] = net.ParseCIDR
	decs["ParseError"] = reflect.TypeOf((*net.ParseError)(nil)).Elem()
	decs["ParseIP"] = net.ParseIP
	decs["ParseMAC"] = net.ParseMAC
	decs["Pipe"] = net.Pipe
	decs["ResolveIPAddr"] = net.ResolveIPAddr
	decs["ResolveTCPAddr"] = net.ResolveTCPAddr
	decs["ResolveUDPAddr"] = net.ResolveUDPAddr
	decs["ResolveUnixAddr"] = net.ResolveUnixAddr
	decs["Resolver"] = reflect.TypeOf((*net.Resolver)(nil)).Elem()
	decs["SRV"] = reflect.TypeOf((*net.SRV)(nil)).Elem()
	decs["SplitHostPort"] = net.SplitHostPort
	decs["TCPAddr"] = reflect.TypeOf((*net.TCPAddr)(nil)).Elem()
	decs["TCPConn"] = reflect.TypeOf((*net.TCPConn)(nil)).Elem()
	decs["TCPListener"] = reflect.TypeOf((*net.TCPListener)(nil)).Elem()
	decs["UDPAddr"] = reflect.TypeOf((*net.UDPAddr)(nil)).Elem()
	decs["UDPConn"] = reflect.TypeOf((*net.UDPConn)(nil)).Elem()
	decs["UnixAddr"] = reflect.TypeOf((*net.UnixAddr)(nil)).Elem()
	decs["UnixConn"] = reflect.TypeOf((*net.UnixConn)(nil)).Elem()
	decs["UnixListener"] = reflect.TypeOf((*net.UnixListener)(nil)).Elem()
	decs["UnknownNetworkError"] = reflect.TypeOf((*net.UnknownNetworkError)(nil)).Elem()
	packages["net"] = &MapPackage{
		PkgName: "net",
		Declarations: decs,
	}
	// "net/http"
	decs = make(map[string]interface{}, 171)
	decs["CanonicalHeaderKey"] = http.CanonicalHeaderKey
	decs["Client"] = reflect.TypeOf((*http.Client)(nil)).Elem()
	decs["CloseNotifier"] = reflect.TypeOf((*http.CloseNotifier)(nil)).Elem()
	decs["ConnState"] = reflect.TypeOf((*http.ConnState)(nil)).Elem()
	decs["Cookie"] = reflect.TypeOf((*http.Cookie)(nil)).Elem()
	decs["CookieJar"] = reflect.TypeOf((*http.CookieJar)(nil)).Elem()
	decs["DefaultClient"] = &http.DefaultClient
	decs["DefaultMaxHeaderBytes"] = UntypedNumericConst("1048576")
	decs["DefaultMaxIdleConnsPerHost"] = UntypedNumericConst("2")
	decs["DefaultServeMux"] = &http.DefaultServeMux
	decs["DefaultTransport"] = &http.DefaultTransport
	decs["DetectContentType"] = http.DetectContentType
	decs["Dir"] = reflect.TypeOf((*http.Dir)(nil)).Elem()
	decs["ErrAbortHandler"] = &http.ErrAbortHandler
	decs["ErrBodyNotAllowed"] = &http.ErrBodyNotAllowed
	decs["ErrBodyReadAfterClose"] = &http.ErrBodyReadAfterClose
	decs["ErrContentLength"] = &http.ErrContentLength
	decs["ErrHandlerTimeout"] = &http.ErrHandlerTimeout
	decs["ErrHeaderTooLong"] = &http.ErrHeaderTooLong
	decs["ErrHijacked"] = &http.ErrHijacked
	decs["ErrLineTooLong"] = &http.ErrLineTooLong
	decs["ErrMissingBoundary"] = &http.ErrMissingBoundary
	decs["ErrMissingContentLength"] = &http.ErrMissingContentLength
	decs["ErrMissingFile"] = &http.ErrMissingFile
	decs["ErrNoCookie"] = &http.ErrNoCookie
	decs["ErrNoLocation"] = &http.ErrNoLocation
	decs["ErrNotMultipart"] = &http.ErrNotMultipart
	decs["ErrNotSupported"] = &http.ErrNotSupported
	decs["ErrServerClosed"] = &http.ErrServerClosed
	decs["ErrShortBody"] = &http.ErrShortBody
	decs["ErrSkipAltProtocol"] = &http.ErrSkipAltProtocol
	decs["ErrUnexpectedTrailer"] = &http.ErrUnexpectedTrailer
	decs["ErrUseLastResponse"] = &http.ErrUseLastResponse
	decs["ErrWriteAfterFlush"] = &http.ErrWriteAfterFlush
	decs["Error"] = http.Error
	decs["FS"] = http.FS
	decs["File"] = reflect.TypeOf((*http.File)(nil)).Elem()
	decs["FileServer"] = http.FileServer
	decs["FileSystem"] = reflect.TypeOf((*http.FileSystem)(nil)).Elem()
	decs["Flusher"] = reflect.TypeOf((*http.Flusher)(nil)).Elem()
	decs["Get"] = http.Get
	decs["Handle"] = http.Handle
	decs["HandleFunc"] = http.HandleFunc
	decs["Handler"] = reflect.TypeOf((*http.Handler)(nil)).Elem()
	decs["HandlerFunc"] = reflect.TypeOf((*http.HandlerFunc)(nil)).Elem()
	decs["Head"] = http.Head
	decs["Header"] = reflect.TypeOf((*http.Header)(nil)).Elem()
	decs["Hijacker"] = reflect.TypeOf((*http.Hijacker)(nil)).Elem()
	decs["ListenAndServe"] = http.ListenAndServe
	decs["ListenAndServeTLS"] = http.ListenAndServeTLS
	decs["LocalAddrContextKey"] = &http.LocalAddrContextKey
	decs["MaxBytesReader"] = http.MaxBytesReader
	decs["MethodConnect"] = UntypedStringConst("CONNECT")
	decs["MethodDelete"] = UntypedStringConst("DELETE")
	decs["MethodGet"] = UntypedStringConst("GET")
	decs["MethodHead"] = UntypedStringConst("HEAD")
	decs["MethodOptions"] = UntypedStringConst("OPTIONS")
	decs["MethodPatch"] = UntypedStringConst("PATCH")
	decs["MethodPost"] = UntypedStringConst("POST")
	decs["MethodPut"] = UntypedStringConst("PUT")
	decs["MethodTrace"] = UntypedStringConst("TRACE")
	decs["NewFileTransport"] = http.NewFileTransport
	decs["NewRequest"] = http.NewRequest
	decs["NewRequestWithContext"] = http.NewRequestWithContext
	decs["NewServeMux"] = http.NewServeMux
	decs["NoBody"] = &http.NoBody
	decs["NotFound"] = http.NotFound
	decs["NotFoundHandler"] = http.NotFoundHandler
	decs["ParseHTTPVersion"] = http.ParseHTTPVersion
	decs["ParseTime"] = http.ParseTime
	decs["Post"] = http.Post
	decs["PostForm"] = http.PostForm
	decs["ProtocolError"] = reflect.TypeOf((*http.ProtocolError)(nil)).Elem()
	decs["ProxyFromEnvironment"] = http.ProxyFromEnvironment
	decs["ProxyURL"] = http.ProxyURL
	decs["PushOptions"] = reflect.TypeOf((*http.PushOptions)(nil)).Elem()
	decs["Pusher"] = reflect.TypeOf((*http.Pusher)(nil)).Elem()
	decs["ReadRequest"] = http.ReadRequest
	decs["ReadResponse"] = http.ReadResponse
	decs["Redirect"] = http.Redirect
	decs["RedirectHandler"] = http.RedirectHandler
	decs["Request"] = reflect.TypeOf((*http.Request)(nil)).Elem()
	decs["Response"] = reflect.TypeOf((*http.Response)(nil)).Elem()
	decs["ResponseWriter"] = reflect.TypeOf((*http.ResponseWriter)(nil)).Elem()
	decs["RoundTripper"] = reflect.TypeOf((*http.RoundTripper)(nil)).Elem()
	decs["SameSite"] = reflect.TypeOf((*http.SameSite)(nil)).Elem()
	decs["SameSiteDefaultMode"] = http.SameSiteDefaultMode
	decs["SameSiteLaxMode"] = http.SameSiteLaxMode
	decs["SameSiteNoneMode"] = http.SameSiteNoneMode
	decs["SameSiteStrictMode"] = http.SameSiteStrictMode
	decs["Serve"] = http.Serve
	decs["ServeContent"] = http.ServeContent
	decs["ServeFile"] = http.ServeFile
	decs["ServeMux"] = reflect.TypeOf((*http.ServeMux)(nil)).Elem()
	decs["ServeTLS"] = http.ServeTLS
	decs["Server"] = reflect.TypeOf((*http.Server)(nil)).Elem()
	decs["ServerContextKey"] = &http.ServerContextKey
	decs["SetCookie"] = http.SetCookie
	decs["StateActive"] = http.StateActive
	decs["StateClosed"] = http.StateClosed
	decs["StateHijacked"] = http.StateHijacked
	decs["StateIdle"] = http.StateIdle
	decs["StateNew"] = http.StateNew
	decs["StatusAccepted"] = UntypedNumericConst("202")
	decs["StatusAlreadyReported"] = UntypedNumericConst("208")
	decs["StatusBadGateway"] = UntypedNumericConst("502")
	decs["StatusBadRequest"] = UntypedNumericConst("400")
	decs["StatusConflict"] = UntypedNumericConst("409")
	decs["StatusContinue"] = UntypedNumericConst("100")
	decs["StatusCreated"] = UntypedNumericConst("201")
	decs["StatusEarlyHints"] = UntypedNumericConst("103")
	decs["StatusExpectationFailed"] = UntypedNumericConst("417")
	decs["StatusFailedDependency"] = UntypedNumericConst("424")
	decs["StatusForbidden"] = UntypedNumericConst("403")
	decs["StatusFound"] = UntypedNumericConst("302")
	decs["StatusGatewayTimeout"] = UntypedNumericConst("504")
	decs["StatusGone"] = UntypedNumericConst("410")
	decs["StatusHTTPVersionNotSupported"] = UntypedNumericConst("505")
	decs["StatusIMUsed"] = UntypedNumericConst("226")
	decs["StatusInsufficientStorage"] = UntypedNumericConst("507")
	decs["StatusInternalServerError"] = UntypedNumericConst("500")
	decs["StatusLengthRequired"] = UntypedNumericConst("411")
	decs["StatusLocked"] = UntypedNumericConst("423")
	decs["StatusLoopDetected"] = UntypedNumericConst("508")
	decs["StatusMethodNotAllowed"] = UntypedNumericConst("405")
	decs["StatusMisdirectedRequest"] = UntypedNumericConst("421")
	decs["StatusMovedPermanently"] = UntypedNumericConst("301")
	decs["StatusMultiStatus"] = UntypedNumericConst("207")
	decs["StatusMultipleChoices"] = UntypedNumericConst("300")
	decs["StatusNetworkAuthenticationRequired"] = UntypedNumericConst("511")
	decs["StatusNoContent"] = UntypedNumericConst("204")
	decs["StatusNonAuthoritativeInfo"] = UntypedNumericConst("203")
	decs["StatusNotAcceptable"] = UntypedNumericConst("406")
	decs["StatusNotExtended"] = UntypedNumericConst("510")
	decs["StatusNotFound"] = UntypedNumericConst("404")
	decs["StatusNotImplemented"] = UntypedNumericConst("501")
	decs["StatusNotModified"] = UntypedNumericConst("304")
	decs["StatusOK"] = UntypedNumericConst("200")
	decs["StatusPartialContent"] = UntypedNumericConst("206")
	decs["StatusPaymentRequired"] = UntypedNumericConst("402")
	decs["StatusPermanentRedirect"] = UntypedNumericConst("308")
	decs["StatusPreconditionFailed"] = UntypedNumericConst("412")
	decs["StatusPreconditionRequired"] = UntypedNumericConst("428")
	decs["StatusProcessing"] = UntypedNumericConst("102")
	decs["StatusProxyAuthRequired"] = UntypedNumericConst("407")
	decs["StatusRequestEntityTooLarge"] = UntypedNumericConst("413")
	decs["StatusRequestHeaderFieldsTooLarge"] = UntypedNumericConst("431")
	decs["StatusRequestTimeout"] = UntypedNumericConst("408")
	decs["StatusRequestURITooLong"] = UntypedNumericConst("414")
	decs["StatusRequestedRangeNotSatisfiable"] = UntypedNumericConst("416")
	decs["StatusResetContent"] = UntypedNumericConst("205")
	decs["StatusSeeOther"] = UntypedNumericConst("303")
	decs["StatusServiceUnavailable"] = UntypedNumericConst("503")
	decs["StatusSwitchingProtocols"] = UntypedNumericConst("101")
	decs["StatusTeapot"] = UntypedNumericConst("418")
	decs["StatusTemporaryRedirect"] = UntypedNumericConst("307")
	decs["StatusText"] = http.StatusText
	decs["StatusTooEarly"] = UntypedNumericConst("425")
	decs["StatusTooManyRequests"] = UntypedNumericConst("429")
	decs["StatusUnauthorized"] = UntypedNumericConst("401")
	decs["StatusUnavailableForLegalReasons"] = UntypedNumericConst("451")
	decs["StatusUnprocessableEntity"] = UntypedNumericConst("422")
	decs["StatusUnsupportedMediaType"] = UntypedNumericConst("415")
	decs["StatusUpgradeRequired"] = UntypedNumericConst("426")
	decs["StatusUseProxy"] = UntypedNumericConst("305")
	decs["StatusVariantAlsoNegotiates"] = UntypedNumericConst("506")
	decs["StripPrefix"] = http.StripPrefix
	decs["TimeFormat"] = UntypedStringConst("Mon, 02 Jan 2006 15:04:05 GMT")
	decs["TimeoutHandler"] = http.TimeoutHandler
	decs["TrailerPrefix"] = UntypedStringConst("Trailer:")
	decs["Transport"] = reflect.TypeOf((*http.Transport)(nil)).Elem()
	packages["net/http"] = &MapPackage{
		PkgName: "http",
		Declarations: decs,
	}
	// "net/http/cgi"
	decs = make(map[string]interface{}, 4)
	decs["Handler"] = reflect.TypeOf((*cgi.Handler)(nil)).Elem()
	decs["Request"] = cgi.Request
	decs["RequestFromMap"] = cgi.RequestFromMap
	decs["Serve"] = cgi.Serve
	packages["net/http/cgi"] = &MapPackage{
		PkgName: "cgi",
		Declarations: decs,
	}
	// "net/http/cookiejar"
	decs = make(map[string]interface{}, 4)
	decs["Jar"] = reflect.TypeOf((*cookiejar.Jar)(nil)).Elem()
	decs["New"] = cookiejar.New
	decs["Options"] = reflect.TypeOf((*cookiejar.Options)(nil)).Elem()
	decs["PublicSuffixList"] = reflect.TypeOf((*cookiejar.PublicSuffixList)(nil)).Elem()
	packages["net/http/cookiejar"] = &MapPackage{
		PkgName: "cookiejar",
		Declarations: decs,
	}
	// "net/http/fcgi"
	decs = make(map[string]interface{}, 4)
	decs["ErrConnClosed"] = &fcgi.ErrConnClosed
	decs["ErrRequestAborted"] = &fcgi.ErrRequestAborted
	decs["ProcessEnv"] = fcgi.ProcessEnv
	decs["Serve"] = fcgi.Serve
	packages["net/http/fcgi"] = &MapPackage{
		PkgName: "fcgi",
		Declarations: decs,
	}
	// "net/http/httptest"
	decs = make(map[string]interface{}, 8)
	decs["DefaultRemoteAddr"] = UntypedStringConst("1.2.3.4")
	decs["NewRecorder"] = httptest.NewRecorder
	decs["NewRequest"] = httptest.NewRequest
	decs["NewServer"] = httptest.NewServer
	decs["NewTLSServer"] = httptest.NewTLSServer
	decs["NewUnstartedServer"] = httptest.NewUnstartedServer
	decs["ResponseRecorder"] = reflect.TypeOf((*httptest.ResponseRecorder)(nil)).Elem()
	decs["Server"] = reflect.TypeOf((*httptest.Server)(nil)).Elem()
	packages["net/http/httptest"] = &MapPackage{
		PkgName: "httptest",
		Declarations: decs,
	}
	// "net/http/httptrace"
	decs = make(map[string]interface{}, 7)
	decs["ClientTrace"] = reflect.TypeOf((*httptrace.ClientTrace)(nil)).Elem()
	decs["ContextClientTrace"] = httptrace.ContextClientTrace
	decs["DNSDoneInfo"] = reflect.TypeOf((*httptrace.DNSDoneInfo)(nil)).Elem()
	decs["DNSStartInfo"] = reflect.TypeOf((*httptrace.DNSStartInfo)(nil)).Elem()
	decs["GotConnInfo"] = reflect.TypeOf((*httptrace.GotConnInfo)(nil)).Elem()
	decs["WithClientTrace"] = httptrace.WithClientTrace
	decs["WroteRequestInfo"] = reflect.TypeOf((*httptrace.WroteRequestInfo)(nil)).Elem()
	packages["net/http/httptrace"] = &MapPackage{
		PkgName: "httptrace",
		Declarations: decs,
	}
	// "net/http/httputil"
	decs = make(map[string]interface{}, 17)
	decs["BufferPool"] = reflect.TypeOf((*httputil.BufferPool)(nil)).Elem()
	decs["ClientConn"] = reflect.TypeOf((*httputil.ClientConn)(nil)).Elem()
	decs["DumpRequest"] = httputil.DumpRequest
	decs["DumpRequestOut"] = httputil.DumpRequestOut
	decs["DumpResponse"] = httputil.DumpResponse
	decs["ErrClosed"] = &httputil.ErrClosed
	decs["ErrLineTooLong"] = &httputil.ErrLineTooLong
	decs["ErrPersistEOF"] = &httputil.ErrPersistEOF
	decs["ErrPipeline"] = &httputil.ErrPipeline
	decs["NewChunkedReader"] = httputil.NewChunkedReader
	decs["NewChunkedWriter"] = httputil.NewChunkedWriter
	decs["NewClientConn"] = httputil.NewClientConn
	decs["NewProxyClientConn"] = httputil.NewProxyClientConn
	decs["NewServerConn"] = httputil.NewServerConn
	decs["NewSingleHostReverseProxy"] = httputil.NewSingleHostReverseProxy
	decs["ReverseProxy"] = reflect.TypeOf((*httputil.ReverseProxy)(nil)).Elem()
	decs["ServerConn"] = reflect.TypeOf((*httputil.ServerConn)(nil)).Elem()
	packages["net/http/httputil"] = &MapPackage{
		PkgName: "httputil",
		Declarations: decs,
	}
	// "net/http/pprof"
	decs = make(map[string]interface{}, 6)
	decs["Cmdline"] = pprof.Cmdline
	decs["Handler"] = pprof.Handler
	decs["Index"] = pprof.Index
	decs["Profile"] = pprof.Profile
	decs["Symbol"] = pprof.Symbol
	decs["Trace"] = pprof.Trace
	packages["net/http/pprof"] = &MapPackage{
		PkgName: "pprof",
		Declarations: decs,
	}
	// "net/mail"
	decs = make(map[string]interface{}, 9)
	decs["Address"] = reflect.TypeOf((*mail.Address)(nil)).Elem()
	decs["AddressParser"] = reflect.TypeOf((*mail.AddressParser)(nil)).Elem()
	decs["ErrHeaderNotPresent"] = &mail.ErrHeaderNotPresent
	decs["Header"] = reflect.TypeOf((*mail.Header)(nil)).Elem()
	decs["Message"] = reflect.TypeOf((*mail.Message)(nil)).Elem()
	decs["ParseAddress"] = mail.ParseAddress
	decs["ParseAddressList"] = mail.ParseAddressList
	decs["ParseDate"] = mail.ParseDate
	decs["ReadMessage"] = mail.ReadMessage
	packages["net/mail"] = &MapPackage{
		PkgName: "mail",
		Declarations: decs,
	}
	// "net/rpc"
	decs = make(map[string]interface{}, 25)
	decs["Accept"] = rpc.Accept
	decs["Call"] = reflect.TypeOf((*rpc.Call)(nil)).Elem()
	decs["Client"] = reflect.TypeOf((*rpc.Client)(nil)).Elem()
	decs["ClientCodec"] = reflect.TypeOf((*rpc.ClientCodec)(nil)).Elem()
	decs["DefaultDebugPath"] = UntypedStringConst("/debug/rpc")
	decs["DefaultRPCPath"] = UntypedStringConst("/_goRPC_")
	decs["DefaultServer"] = &rpc.DefaultServer
	decs["Dial"] = rpc.Dial
	decs["DialHTTP"] = rpc.DialHTTP
	decs["DialHTTPPath"] = rpc.DialHTTPPath
	decs["ErrShutdown"] = &rpc.ErrShutdown
	decs["HandleHTTP"] = rpc.HandleHTTP
	decs["NewClient"] = rpc.NewClient
	decs["NewClientWithCodec"] = rpc.NewClientWithCodec
	decs["NewServer"] = rpc.NewServer
	decs["Register"] = rpc.Register
	decs["RegisterName"] = rpc.RegisterName
	decs["Request"] = reflect.TypeOf((*rpc.Request)(nil)).Elem()
	decs["Response"] = reflect.TypeOf((*rpc.Response)(nil)).Elem()
	decs["ServeCodec"] = rpc.ServeCodec
	decs["ServeConn"] = rpc.ServeConn
	decs["ServeRequest"] = rpc.ServeRequest
	decs["Server"] = reflect.TypeOf((*rpc.Server)(nil)).Elem()
	decs["ServerCodec"] = reflect.TypeOf((*rpc.ServerCodec)(nil)).Elem()
	decs["ServerError"] = reflect.TypeOf((*rpc.ServerError)(nil)).Elem()
	packages["net/rpc"] = &MapPackage{
		PkgName: "rpc",
		Declarations: decs,
	}
	// "net/rpc/jsonrpc"
	decs = make(map[string]interface{}, 5)
	decs["Dial"] = jsonrpc.Dial
	decs["NewClient"] = jsonrpc.NewClient
	decs["NewClientCodec"] = jsonrpc.NewClientCodec
	decs["NewServerCodec"] = jsonrpc.NewServerCodec
	decs["ServeConn"] = jsonrpc.ServeConn
	packages["net/rpc/jsonrpc"] = &MapPackage{
		PkgName: "jsonrpc",
		Declarations: decs,
	}
	// "net/smtp"
	decs = make(map[string]interface{}, 8)
	decs["Auth"] = reflect.TypeOf((*smtp.Auth)(nil)).Elem()
	decs["CRAMMD5Auth"] = smtp.CRAMMD5Auth
	decs["Client"] = reflect.TypeOf((*smtp.Client)(nil)).Elem()
	decs["Dial"] = smtp.Dial
	decs["NewClient"] = smtp.NewClient
	decs["PlainAuth"] = smtp.PlainAuth
	decs["SendMail"] = smtp.SendMail
	decs["ServerInfo"] = reflect.TypeOf((*smtp.ServerInfo)(nil)).Elem()
	packages["net/smtp"] = &MapPackage{
		PkgName: "smtp",
		Declarations: decs,
	}
	// "net/textproto"
	decs = make(map[string]interface{}, 14)
	decs["CanonicalMIMEHeaderKey"] = textproto.CanonicalMIMEHeaderKey
	decs["Conn"] = reflect.TypeOf((*textproto.Conn)(nil)).Elem()
	decs["Dial"] = textproto.Dial
	decs["Error"] = reflect.TypeOf((*textproto.Error)(nil)).Elem()
	decs["MIMEHeader"] = reflect.TypeOf((*textproto.MIMEHeader)(nil)).Elem()
	decs["NewConn"] = textproto.NewConn
	decs["NewReader"] = textproto.NewReader
	decs["NewWriter"] = textproto.NewWriter
	decs["Pipeline"] = reflect.TypeOf((*textproto.Pipeline)(nil)).Elem()
	decs["ProtocolError"] = reflect.TypeOf((*textproto.ProtocolError)(nil)).Elem()
	decs["Reader"] = reflect.TypeOf((*textproto.Reader)(nil)).Elem()
	decs["TrimBytes"] = textproto.TrimBytes
	decs["TrimString"] = textproto.TrimString
	decs["Writer"] = reflect.TypeOf((*textproto.Writer)(nil)).Elem()
	packages["net/textproto"] = &MapPackage{
		PkgName: "textproto",
		Declarations: decs,
	}
	// "net/url"
	decs = make(map[string]interface{}, 15)
	decs["Error"] = reflect.TypeOf((*url.Error)(nil)).Elem()
	decs["EscapeError"] = reflect.TypeOf((*url.EscapeError)(nil)).Elem()
	decs["InvalidHostError"] = reflect.TypeOf((*url.InvalidHostError)(nil)).Elem()
	decs["Parse"] = url.Parse
	decs["ParseQuery"] = url.ParseQuery
	decs["ParseRequestURI"] = url.ParseRequestURI
	decs["PathEscape"] = url.PathEscape
	decs["PathUnescape"] = url.PathUnescape
	decs["QueryEscape"] = url.QueryEscape
	decs["QueryUnescape"] = url.QueryUnescape
	decs["URL"] = reflect.TypeOf((*url.URL)(nil)).Elem()
	decs["User"] = url.User
	decs["UserPassword"] = url.UserPassword
	decs["Userinfo"] = reflect.TypeOf((*url.Userinfo)(nil)).Elem()
	decs["Values"] = reflect.TypeOf((*url.Values)(nil)).Elem()
	packages["net/url"] = &MapPackage{
		PkgName: "url",
		Declarations: decs,
	}
	// "os"
	decs = make(map[string]interface{}, 114)
	decs["Args"] = &os.Args
	decs["Chdir"] = os.Chdir
	decs["Chmod"] = os.Chmod
	decs["Chown"] = os.Chown
	decs["Chtimes"] = os.Chtimes
	decs["Clearenv"] = os.Clearenv
	decs["Create"] = os.Create
	decs["CreateTemp"] = os.CreateTemp
	decs["DevNull"] = UntypedStringConst("/dev/null")
	decs["DirEntry"] = reflect.TypeOf((*os.DirEntry)(nil)).Elem()
	decs["DirFS"] = os.DirFS
	decs["Environ"] = os.Environ
	decs["ErrClosed"] = &os.ErrClosed
	decs["ErrDeadlineExceeded"] = &os.ErrDeadlineExceeded
	decs["ErrExist"] = &os.ErrExist
	decs["ErrInvalid"] = &os.ErrInvalid
	decs["ErrNoDeadline"] = &os.ErrNoDeadline
	decs["ErrNotExist"] = &os.ErrNotExist
	decs["ErrPermission"] = &os.ErrPermission
	decs["ErrProcessDone"] = &os.ErrProcessDone
	decs["Executable"] = os.Executable
	decs["Exit"] = os.Exit
	decs["Expand"] = os.Expand
	decs["ExpandEnv"] = os.ExpandEnv
	decs["File"] = reflect.TypeOf((*os.File)(nil)).Elem()
	decs["FileInfo"] = reflect.TypeOf((*os.FileInfo)(nil)).Elem()
	decs["FileMode"] = reflect.TypeOf((*os.FileMode)(nil)).Elem()
	decs["FindProcess"] = os.FindProcess
	decs["Getegid"] = os.Getegid
	decs["Getenv"] = os.Getenv
	decs["Geteuid"] = os.Geteuid
	decs["Getgid"] = os.Getgid
	decs["Getgroups"] = os.Getgroups
	decs["Getpagesize"] = os.Getpagesize
	decs["Getpid"] = os.Getpid
	decs["Getppid"] = os.Getppid
	decs["Getuid"] = os.Getuid
	decs["Getwd"] = os.Getwd
	decs["Hostname"] = os.Hostname
	decs["Interrupt"] = &os.Interrupt
	decs["IsExist"] = os.IsExist
	decs["IsNotExist"] = os.IsNotExist
	decs["IsPathSeparator"] = os.IsPathSeparator
	decs["IsPermission"] = os.IsPermission
	decs["IsTimeout"] = os.IsTimeout
	decs["Kill"] = &os.Kill
	decs["Lchown"] = os.Lchown
	decs["Link"] = os.Link
	decs["LinkError"] = reflect.TypeOf((*os.LinkError)(nil)).Elem()
	decs["LookupEnv"] = os.LookupEnv
	decs["Lstat"] = os.Lstat
	decs["Mkdir"] = os.Mkdir
	decs["MkdirAll"] = os.MkdirAll
	decs["MkdirTemp"] = os.MkdirTemp
	decs["ModeAppend"] = os.ModeAppend
	decs["ModeCharDevice"] = os.ModeCharDevice
	decs["ModeDevice"] = os.ModeDevice
	decs["ModeDir"] = os.ModeDir
	decs["ModeExclusive"] = os.ModeExclusive
	decs["ModeIrregular"] = os.ModeIrregular
	decs["ModeNamedPipe"] = os.ModeNamedPipe
	decs["ModePerm"] = os.ModePerm
	decs["ModeSetgid"] = os.ModeSetgid
	decs["ModeSetuid"] = os.ModeSetuid
	decs["ModeSocket"] = os.ModeSocket
	decs["ModeSticky"] = os.ModeSticky
	decs["ModeSymlink"] = os.ModeSymlink
	decs["ModeTemporary"] = os.ModeTemporary
	decs["ModeType"] = os.ModeType
	decs["NewFile"] = os.NewFile
	decs["NewSyscallError"] = os.NewSyscallError
	decs["O_APPEND"] = os.O_APPEND
	decs["O_CREATE"] = os.O_CREATE
	decs["O_EXCL"] = os.O_EXCL
	decs["O_RDONLY"] = os.O_RDONLY
	decs["O_RDWR"] = os.O_RDWR
	decs["O_SYNC"] = os.O_SYNC
	decs["O_TRUNC"] = os.O_TRUNC
	decs["O_WRONLY"] = os.O_WRONLY
	decs["Open"] = os.Open
	decs["OpenFile"] = os.OpenFile
	decs["PathError"] = reflect.TypeOf((*os.PathError)(nil)).Elem()
	decs["PathListSeparator"] = UntypedNumericConst("58")
	decs["PathSeparator"] = UntypedNumericConst("47")
	decs["Pipe"] = os.Pipe
	decs["ProcAttr"] = reflect.TypeOf((*os.ProcAttr)(nil)).Elem()
	decs["Process"] = reflect.TypeOf((*os.Process)(nil)).Elem()
	decs["ProcessState"] = reflect.TypeOf((*os.ProcessState)(nil)).Elem()
	decs["ReadDir"] = os.ReadDir
	decs["ReadFile"] = os.ReadFile
	decs["Readlink"] = os.Readlink
	decs["Remove"] = os.Remove
	decs["RemoveAll"] = os.RemoveAll
	decs["Rename"] = os.Rename
	decs["SEEK_CUR"] = os.SEEK_CUR
	decs["SEEK_END"] = os.SEEK_END
	decs["SEEK_SET"] = os.SEEK_SET
	decs["SameFile"] = os.SameFile
	decs["Setenv"] = os.Setenv
	decs["Signal"] = reflect.TypeOf((*os.Signal)(nil)).Elem()
	decs["StartProcess"] = os.StartProcess
	decs["Stat"] = os.Stat
	decs["Stderr"] = &os.Stderr
	decs["Stdin"] = &os.Stdin
	decs["Stdout"] = &os.Stdout
	decs["Symlink"] = os.Symlink
	decs["SyscallError"] = reflect.TypeOf((*os.SyscallError)(nil)).Elem()
	decs["TempDir"] = os.TempDir
	decs["Truncate"] = os.Truncate
	decs["Unsetenv"] = os.Unsetenv
	decs["UserCacheDir"] = os.UserCacheDir
	decs["UserConfigDir"] = os.UserConfigDir
	decs["UserHomeDir"] = os.UserHomeDir
	decs["WriteFile"] = os.WriteFile
	packages["os"] = &MapPackage{
		PkgName: "os",
		Declarations: decs,
	}
	// "os/exec"
	decs = make(map[string]interface{}, 7)
	decs["Cmd"] = reflect.TypeOf((*exec.Cmd)(nil)).Elem()
	decs["Command"] = exec.Command
	decs["CommandContext"] = exec.CommandContext
	decs["ErrNotFound"] = &exec.ErrNotFound
	decs["Error"] = reflect.TypeOf((*exec.Error)(nil)).Elem()
	decs["ExitError"] = reflect.TypeOf((*exec.ExitError)(nil)).Elem()
	decs["LookPath"] = exec.LookPath
	packages["os/exec"] = &MapPackage{
		PkgName: "exec",
		Declarations: decs,
	}
	// "os/signal"
	decs = make(map[string]interface{}, 6)
	decs["Ignore"] = signal.Ignore
	decs["Ignored"] = signal.Ignored
	decs["Notify"] = signal.Notify
	decs["NotifyContext"] = signal.NotifyContext
	decs["Reset"] = signal.Reset
	decs["Stop"] = signal.Stop
	packages["os/signal"] = &MapPackage{
		PkgName: "signal",
		Declarations: decs,
	}
	// "os/user"
	decs = make(map[string]interface{}, 11)
	decs["Current"] = user.Current
	decs["Group"] = reflect.TypeOf((*user.Group)(nil)).Elem()
	decs["Lookup"] = user.Lookup
	decs["LookupGroup"] = user.LookupGroup
	decs["LookupGroupId"] = user.LookupGroupId
	decs["LookupId"] = user.LookupId
	decs["UnknownGroupError"] = reflect.TypeOf((*user.UnknownGroupError)(nil)).Elem()
	decs["UnknownGroupIdError"] = reflect.TypeOf((*user.UnknownGroupIdError)(nil)).Elem()
	decs["UnknownUserError"] = reflect.TypeOf((*user.UnknownUserError)(nil)).Elem()
	decs["UnknownUserIdError"] = reflect.TypeOf((*user.UnknownUserIdError)(nil)).Elem()
	decs["User"] = reflect.TypeOf((*user.User)(nil)).Elem()
	packages["os/user"] = &MapPackage{
		PkgName: "user",
		Declarations: decs,
	}
	// "path"
	decs = make(map[string]interface{}, 9)
	decs["Base"] = path.Base
	decs["Clean"] = path.Clean
	decs["Dir"] = path.Dir
	decs["ErrBadPattern"] = &path.ErrBadPattern
	decs["Ext"] = path.Ext
	decs["IsAbs"] = path.IsAbs
	decs["Join"] = path.Join
	decs["Match"] = path.Match
	decs["Split"] = path.Split
	packages["path"] = &MapPackage{
		PkgName: "path",
		Declarations: decs,
	}
	// "path/filepath"
	decs = make(map[string]interface{}, 24)
	decs["Abs"] = filepath.Abs
	decs["Base"] = filepath.Base
	decs["Clean"] = filepath.Clean
	decs["Dir"] = filepath.Dir
	decs["ErrBadPattern"] = &filepath.ErrBadPattern
	decs["EvalSymlinks"] = filepath.EvalSymlinks
	decs["Ext"] = filepath.Ext
	decs["FromSlash"] = filepath.FromSlash
	decs["Glob"] = filepath.Glob
	decs["HasPrefix"] = filepath.HasPrefix
	decs["IsAbs"] = filepath.IsAbs
	decs["Join"] = filepath.Join
	decs["ListSeparator"] = UntypedNumericConst("58")
	decs["Match"] = filepath.Match
	decs["Rel"] = filepath.Rel
	decs["Separator"] = UntypedNumericConst("47")
	decs["SkipDir"] = &filepath.SkipDir
	decs["Split"] = filepath.Split
	decs["SplitList"] = filepath.SplitList
	decs["ToSlash"] = filepath.ToSlash
	decs["VolumeName"] = filepath.VolumeName
	decs["Walk"] = filepath.Walk
	decs["WalkDir"] = filepath.WalkDir
	decs["WalkFunc"] = reflect.TypeOf((*filepath.WalkFunc)(nil)).Elem()
	packages["path/filepath"] = &MapPackage{
		PkgName: "filepath",
		Declarations: decs,
	}
	// "reflect"
	decs = make(map[string]interface{}, 70)
	decs["Append"] = reflect.Append
	decs["AppendSlice"] = reflect.AppendSlice
	decs["Array"] = reflect.Array
	decs["ArrayOf"] = reflect.ArrayOf
	decs["Bool"] = reflect.Bool
	decs["BothDir"] = reflect.BothDir
	decs["Chan"] = reflect.Chan
	decs["ChanDir"] = reflect.TypeOf((*reflect.ChanDir)(nil)).Elem()
	decs["ChanOf"] = reflect.ChanOf
	decs["Complex128"] = reflect.Complex128
	decs["Complex64"] = reflect.Complex64
	decs["Copy"] = reflect.Copy
	decs["DeepEqual"] = reflect.DeepEqual
	decs["Float32"] = reflect.Float32
	decs["Float64"] = reflect.Float64
	decs["Func"] = reflect.Func
	decs["FuncOf"] = reflect.FuncOf
	decs["Indirect"] = reflect.Indirect
	decs["Int"] = reflect.Int
	decs["Int16"] = reflect.Int16
	decs["Int32"] = reflect.Int32
	decs["Int64"] = reflect.Int64
	decs["Int8"] = reflect.Int8
	decs["Interface"] = reflect.Interface
	decs["Invalid"] = reflect.Invalid
	decs["Kind"] = reflect.TypeOf((*reflect.Kind)(nil)).Elem()
	decs["MakeChan"] = reflect.MakeChan
	decs["MakeFunc"] = reflect.MakeFunc
	decs["MakeMap"] = reflect.MakeMap
	decs["MakeMapWithSize"] = reflect.MakeMapWithSize
	decs["MakeSlice"] = reflect.MakeSlice
	decs["Map"] = reflect.Map
	decs["MapIter"] = reflect.TypeOf((*reflect.MapIter)(nil)).Elem()
	decs["MapOf"] = reflect.MapOf
	decs["Method"] = reflect.TypeOf((*reflect.Method)(nil)).Elem()
	decs["New"] = reflect.New
	decs["NewAt"] = reflect.NewAt
	decs["Ptr"] = reflect.Ptr
	decs["PtrTo"] = reflect.PtrTo
	decs["RecvDir"] = reflect.RecvDir
	decs["Select"] = reflect.Select
	decs["SelectCase"] = reflect.TypeOf((*reflect.SelectCase)(nil)).Elem()
	decs["SelectDefault"] = reflect.SelectDefault
	decs["SelectDir"] = reflect.TypeOf((*reflect.SelectDir)(nil)).Elem()
	decs["SelectRecv"] = reflect.SelectRecv
	decs["SelectSend"] = reflect.SelectSend
	decs["SendDir"] = reflect.SendDir
	decs["Slice"] = reflect.Slice
	decs["SliceHeader"] = reflect.TypeOf((*reflect.SliceHeader)(nil)).Elem()
	decs["SliceOf"] = reflect.SliceOf
	decs["String"] = reflect.String
	decs["StringHeader"] = reflect.TypeOf((*reflect.StringHeader)(nil)).Elem()
	decs["Struct"] = reflect.Struct
	decs["StructField"] = reflect.TypeOf((*reflect.StructField)(nil)).Elem()
	decs["StructOf"] = reflect.StructOf
	decs["StructTag"] = reflect.TypeOf((*reflect.StructTag)(nil)).Elem()
	decs["Swapper"] = reflect.Swapper
	decs["Type"] = reflect.TypeOf((*reflect.Type)(nil)).Elem()
	decs["TypeOf"] = reflect.TypeOf
	decs["Uint"] = reflect.Uint
	decs["Uint16"] = reflect.Uint16
	decs["Uint32"] = reflect.Uint32
	decs["Uint64"] = reflect.Uint64
	decs["Uint8"] = reflect.Uint8
	decs["Uintptr"] = reflect.Uintptr
	decs["UnsafePointer"] = reflect.UnsafePointer
	decs["Value"] = reflect.TypeOf((*reflect.Value)(nil)).Elem()
	decs["ValueError"] = reflect.TypeOf((*reflect.ValueError)(nil)).Elem()
	decs["ValueOf"] = reflect.ValueOf
	decs["Zero"] = reflect.Zero
	packages["reflect"] = &MapPackage{
		PkgName: "reflect",
		Declarations: decs,
	}
	// "regexp"
	decs = make(map[string]interface{}, 9)
	decs["Compile"] = regexp.Compile
	decs["CompilePOSIX"] = regexp.CompilePOSIX
	decs["Match"] = regexp.Match
	decs["MatchReader"] = regexp.MatchReader
	decs["MatchString"] = regexp.MatchString
	decs["MustCompile"] = regexp.MustCompile
	decs["MustCompilePOSIX"] = regexp.MustCompilePOSIX
	decs["QuoteMeta"] = regexp.QuoteMeta
	decs["Regexp"] = reflect.TypeOf((*regexp.Regexp)(nil)).Elem()
	packages["regexp"] = &MapPackage{
		PkgName: "regexp",
		Declarations: decs,
	}
	// "regexp/syntax"
	decs = make(map[string]interface{}, 76)
	decs["ClassNL"] = syntax.ClassNL
	decs["Compile"] = syntax.Compile
	decs["DotNL"] = syntax.DotNL
	decs["EmptyBeginLine"] = syntax.EmptyBeginLine
	decs["EmptyBeginText"] = syntax.EmptyBeginText
	decs["EmptyEndLine"] = syntax.EmptyEndLine
	decs["EmptyEndText"] = syntax.EmptyEndText
	decs["EmptyNoWordBoundary"] = syntax.EmptyNoWordBoundary
	decs["EmptyOp"] = reflect.TypeOf((*syntax.EmptyOp)(nil)).Elem()
	decs["EmptyOpContext"] = syntax.EmptyOpContext
	decs["EmptyWordBoundary"] = syntax.EmptyWordBoundary
	decs["ErrInternalError"] = syntax.ErrInternalError
	decs["ErrInvalidCharClass"] = syntax.ErrInvalidCharClass
	decs["ErrInvalidCharRange"] = syntax.ErrInvalidCharRange
	decs["ErrInvalidEscape"] = syntax.ErrInvalidEscape
	decs["ErrInvalidNamedCapture"] = syntax.ErrInvalidNamedCapture
	decs["ErrInvalidPerlOp"] = syntax.ErrInvalidPerlOp
	decs["ErrInvalidRepeatOp"] = syntax.ErrInvalidRepeatOp
	decs["ErrInvalidRepeatSize"] = syntax.ErrInvalidRepeatSize
	decs["ErrInvalidUTF8"] = syntax.ErrInvalidUTF8
	decs["ErrMissingBracket"] = syntax.ErrMissingBracket
	decs["ErrMissingParen"] = syntax.ErrMissingParen
	decs["ErrMissingRepeatArgument"] = syntax.ErrMissingRepeatArgument
	decs["ErrTrailingBackslash"] = syntax.ErrTrailingBackslash
	decs["ErrUnexpectedParen"] = syntax.ErrUnexpectedParen
	decs["Error"] = reflect.TypeOf((*syntax.Error)(nil)).Elem()
	decs["ErrorCode"] = reflect.TypeOf((*syntax.ErrorCode)(nil)).Elem()
	decs["Flags"] = reflect.TypeOf((*syntax.Flags)(nil)).Elem()
	decs["FoldCase"] = syntax.FoldCase
	decs["Inst"] = reflect.TypeOf((*syntax.Inst)(nil)).Elem()
	decs["InstAlt"] = syntax.InstAlt
	decs["InstAltMatch"] = syntax.InstAltMatch
	decs["InstCapture"] = syntax.InstCapture
	decs["InstEmptyWidth"] = syntax.InstEmptyWidth
	decs["InstFail"] = syntax.InstFail
	decs["InstMatch"] = syntax.InstMatch
	decs["InstNop"] = syntax.InstNop
	decs["InstOp"] = reflect.TypeOf((*syntax.InstOp)(nil)).Elem()
	decs["InstRune"] = syntax.InstRune
	decs["InstRune1"] = syntax.InstRune1
	decs["InstRuneAny"] = syntax.InstRuneAny
	decs["InstRuneAnyNotNL"] = syntax.InstRuneAnyNotNL
	decs["IsWordChar"] = syntax.IsWordChar
	decs["Literal"] = syntax.Literal
	decs["MatchNL"] = syntax.MatchNL
	decs["NonGreedy"] = syntax.NonGreedy
	decs["OneLine"] = syntax.OneLine
	decs["Op"] = reflect.TypeOf((*syntax.Op)(nil)).Elem()
	decs["OpAlternate"] = syntax.OpAlternate
	decs["OpAnyChar"] = syntax.OpAnyChar
	decs["OpAnyCharNotNL"] = syntax.OpAnyCharNotNL
	decs["OpBeginLine"] = syntax.OpBeginLine
	decs["OpBeginText"] = syntax.OpBeginText
	decs["OpCapture"] = syntax.OpCapture
	decs["OpCharClass"] = syntax.OpCharClass
	decs["OpConcat"] = syntax.OpConcat
	decs["OpEmptyMatch"] = syntax.OpEmptyMatch
	decs["OpEndLine"] = syntax.OpEndLine
	decs["OpEndText"] = syntax.OpEndText
	decs["OpLiteral"] = syntax.OpLiteral
	decs["OpNoMatch"] = syntax.OpNoMatch
	decs["OpNoWordBoundary"] = syntax.OpNoWordBoundary
	decs["OpPlus"] = syntax.OpPlus
	decs["OpQuest"] = syntax.OpQuest
	decs["OpRepeat"] = syntax.OpRepeat
	decs["OpStar"] = syntax.OpStar
	decs["OpWordBoundary"] = syntax.OpWordBoundary
	decs["POSIX"] = syntax.POSIX
	decs["Parse"] = syntax.Parse
	decs["Perl"] = syntax.Perl
	decs["PerlX"] = syntax.PerlX
	decs["Prog"] = reflect.TypeOf((*syntax.Prog)(nil)).Elem()
	decs["Regexp"] = reflect.TypeOf((*syntax.Regexp)(nil)).Elem()
	decs["Simple"] = syntax.Simple
	decs["UnicodeGroups"] = syntax.UnicodeGroups
	decs["WasDollar"] = syntax.WasDollar
	packages["regexp/syntax"] = &MapPackage{
		PkgName: "syntax",
		Declarations: decs,
	}
	// "runtime"
	decs = make(map[string]interface{}, 46)
	decs["BlockProfile"] = runtime.BlockProfile
	decs["BlockProfileRecord"] = reflect.TypeOf((*runtime.BlockProfileRecord)(nil)).Elem()
	decs["Breakpoint"] = runtime.Breakpoint
	decs["CPUProfile"] = runtime.CPUProfile
	decs["Caller"] = runtime.Caller
	decs["Callers"] = runtime.Callers
	decs["CallersFrames"] = runtime.CallersFrames
	decs["Compiler"] = UntypedStringConst("gc")
	decs["Error"] = reflect.TypeOf((*runtime.Error)(nil)).Elem()
	decs["Frame"] = reflect.TypeOf((*runtime.Frame)(nil)).Elem()
	decs["Frames"] = reflect.TypeOf((*runtime.Frames)(nil)).Elem()
	decs["Func"] = reflect.TypeOf((*runtime.Func)(nil)).Elem()
	decs["FuncForPC"] = runtime.FuncForPC
	decs["GC"] = runtime.GC
	decs["GOARCH"] = runtime.GOARCH
	decs["GOMAXPROCS"] = runtime.GOMAXPROCS
	decs["GOOS"] = runtime.GOOS
	decs["GOROOT"] = runtime.GOROOT
	decs["Goexit"] = runtime.Goexit
	decs["GoroutineProfile"] = runtime.GoroutineProfile
	decs["Gosched"] = runtime.Gosched
	decs["KeepAlive"] = runtime.KeepAlive
	decs["LockOSThread"] = runtime.LockOSThread
	decs["MemProfile"] = runtime.MemProfile
	decs["MemProfileRate"] = &runtime.MemProfileRate
	decs["MemProfileRecord"] = reflect.TypeOf((*runtime.MemProfileRecord)(nil)).Elem()
	decs["MemStats"] = reflect.TypeOf((*runtime.MemStats)(nil)).Elem()
	decs["MutexProfile"] = runtime.MutexProfile
	decs["NumCPU"] = runtime.NumCPU
	decs["NumCgoCall"] = runtime.NumCgoCall
	decs["NumGoroutine"] = runtime.NumGoroutine
	decs["ReadMemStats"] = runtime.ReadMemStats
	decs["ReadTrace"] = runtime.ReadTrace
	decs["SetBlockProfileRate"] = runtime.SetBlockProfileRate
	decs["SetCPUProfileRate"] = runtime.SetCPUProfileRate
	decs["SetCgoTraceback"] = runtime.SetCgoTraceback
	decs["SetFinalizer"] = runtime.SetFinalizer
	decs["SetMutexProfileFraction"] = runtime.SetMutexProfileFraction
	decs["Stack"] = runtime.Stack
	decs["StackRecord"] = reflect.TypeOf((*runtime.StackRecord)(nil)).Elem()
	decs["StartTrace"] = runtime.StartTrace
	decs["StopTrace"] = runtime.StopTrace
	decs["ThreadCreateProfile"] = runtime.ThreadCreateProfile
	decs["TypeAssertionError"] = reflect.TypeOf((*runtime.TypeAssertionError)(nil)).Elem()
	decs["UnlockOSThread"] = runtime.UnlockOSThread
	decs["Version"] = runtime.Version
	packages["runtime"] = &MapPackage{
		PkgName: "runtime",
		Declarations: decs,
	}
	// "runtime/debug"
	decs = make(map[string]interface{}, 14)
	decs["BuildInfo"] = reflect.TypeOf((*debug.BuildInfo)(nil)).Elem()
	decs["FreeOSMemory"] = debug.FreeOSMemory
	decs["GCStats"] = reflect.TypeOf((*debug.GCStats)(nil)).Elem()
	decs["Module"] = reflect.TypeOf((*debug.Module)(nil)).Elem()
	decs["PrintStack"] = debug.PrintStack
	decs["ReadBuildInfo"] = debug.ReadBuildInfo
	decs["ReadGCStats"] = debug.ReadGCStats
	decs["SetGCPercent"] = debug.SetGCPercent
	decs["SetMaxStack"] = debug.SetMaxStack
	decs["SetMaxThreads"] = debug.SetMaxThreads
	decs["SetPanicOnFault"] = debug.SetPanicOnFault
	decs["SetTraceback"] = debug.SetTraceback
	decs["Stack"] = debug.Stack
	decs["WriteHeapDump"] = debug.WriteHeapDump
	packages["runtime/debug"] = &MapPackage{
		PkgName: "debug",
		Declarations: decs,
	}
	// "runtime/metrics"
	decs = make(map[string]interface{}, 11)
	decs["All"] = metrics.All
	decs["Description"] = reflect.TypeOf((*metrics.Description)(nil)).Elem()
	decs["Float64Histogram"] = reflect.TypeOf((*metrics.Float64Histogram)(nil)).Elem()
	decs["KindBad"] = metrics.KindBad
	decs["KindFloat64"] = metrics.KindFloat64
	decs["KindFloat64Histogram"] = metrics.KindFloat64Histogram
	decs["KindUint64"] = metrics.KindUint64
	decs["Read"] = metrics.Read
	decs["Sample"] = reflect.TypeOf((*metrics.Sample)(nil)).Elem()
	decs["Value"] = reflect.TypeOf((*metrics.Value)(nil)).Elem()
	decs["ValueKind"] = reflect.TypeOf((*metrics.ValueKind)(nil)).Elem()
	packages["runtime/metrics"] = &MapPackage{
		PkgName: "metrics",
		Declarations: decs,
	}
	// "runtime/pprof"
	decs = make(map[string]interface{}, 14)
	decs["Do"] = pprof_.Do
	decs["ForLabels"] = pprof_.ForLabels
	decs["Label"] = pprof_.Label
	decs["LabelSet"] = reflect.TypeOf((*pprof_.LabelSet)(nil)).Elem()
	decs["Labels"] = pprof_.Labels
	decs["Lookup"] = pprof_.Lookup
	decs["NewProfile"] = pprof_.NewProfile
	decs["Profile"] = reflect.TypeOf((*pprof_.Profile)(nil)).Elem()
	decs["Profiles"] = pprof_.Profiles
	decs["SetGoroutineLabels"] = pprof_.SetGoroutineLabels
	decs["StartCPUProfile"] = pprof_.StartCPUProfile
	decs["StopCPUProfile"] = pprof_.StopCPUProfile
	decs["WithLabels"] = pprof_.WithLabels
	decs["WriteHeapProfile"] = pprof_.WriteHeapProfile
	packages["runtime/pprof"] = &MapPackage{
		PkgName: "pprof",
		Declarations: decs,
	}
	// "runtime/trace"
	decs = make(map[string]interface{}, 10)
	decs["IsEnabled"] = trace.IsEnabled
	decs["Log"] = trace.Log
	decs["Logf"] = trace.Logf
	decs["NewTask"] = trace.NewTask
	decs["Region"] = reflect.TypeOf((*trace.Region)(nil)).Elem()
	decs["Start"] = trace.Start
	decs["StartRegion"] = trace.StartRegion
	decs["Stop"] = trace.Stop
	decs["Task"] = reflect.TypeOf((*trace.Task)(nil)).Elem()
	decs["WithRegion"] = trace.WithRegion
	packages["runtime/trace"] = &MapPackage{
		PkgName: "trace",
		Declarations: decs,
	}
	// "sort"
	decs = make(map[string]interface{}, 21)
	decs["Float64Slice"] = reflect.TypeOf((*sort.Float64Slice)(nil)).Elem()
	decs["Float64s"] = sort.Float64s
	decs["Float64sAreSorted"] = sort.Float64sAreSorted
	decs["IntSlice"] = reflect.TypeOf((*sort.IntSlice)(nil)).Elem()
	decs["Interface"] = reflect.TypeOf((*sort.Interface)(nil)).Elem()
	decs["Ints"] = sort.Ints
	decs["IntsAreSorted"] = sort.IntsAreSorted
	decs["IsSorted"] = sort.IsSorted
	decs["Reverse"] = sort.Reverse
	decs["Search"] = sort.Search
	decs["SearchFloat64s"] = sort.SearchFloat64s
	decs["SearchInts"] = sort.SearchInts
	decs["SearchStrings"] = sort.SearchStrings
	decs["Slice"] = sort.Slice
	decs["SliceIsSorted"] = sort.SliceIsSorted
	decs["SliceStable"] = sort.SliceStable
	decs["Sort"] = sort.Sort
	decs["Stable"] = sort.Stable
	decs["StringSlice"] = reflect.TypeOf((*sort.StringSlice)(nil)).Elem()
	decs["Strings"] = sort.Strings
	decs["StringsAreSorted"] = sort.StringsAreSorted
	packages["sort"] = &MapPackage{
		PkgName: "sort",
		Declarations: decs,
	}
	// "strconv"
	decs = make(map[string]interface{}, 37)
	decs["AppendBool"] = strconv.AppendBool
	decs["AppendFloat"] = strconv.AppendFloat
	decs["AppendInt"] = strconv.AppendInt
	decs["AppendQuote"] = strconv.AppendQuote
	decs["AppendQuoteRune"] = strconv.AppendQuoteRune
	decs["AppendQuoteRuneToASCII"] = strconv.AppendQuoteRuneToASCII
	decs["AppendQuoteRuneToGraphic"] = strconv.AppendQuoteRuneToGraphic
	decs["AppendQuoteToASCII"] = strconv.AppendQuoteToASCII
	decs["AppendQuoteToGraphic"] = strconv.AppendQuoteToGraphic
	decs["AppendUint"] = strconv.AppendUint
	decs["Atoi"] = strconv.Atoi
	decs["CanBackquote"] = strconv.CanBackquote
	decs["ErrRange"] = &strconv.ErrRange
	decs["ErrSyntax"] = &strconv.ErrSyntax
	decs["FormatBool"] = strconv.FormatBool
	decs["FormatComplex"] = strconv.FormatComplex
	decs["FormatFloat"] = strconv.FormatFloat
	decs["FormatInt"] = strconv.FormatInt
	decs["FormatUint"] = strconv.FormatUint
	decs["IntSize"] = UntypedNumericConst("64")
	decs["IsGraphic"] = strconv.IsGraphic
	decs["IsPrint"] = strconv.IsPrint
	decs["Itoa"] = strconv.Itoa
	decs["NumError"] = reflect.TypeOf((*strconv.NumError)(nil)).Elem()
	decs["ParseBool"] = strconv.ParseBool
	decs["ParseComplex"] = strconv.ParseComplex
	decs["ParseFloat"] = strconv.ParseFloat
	decs["ParseInt"] = strconv.ParseInt
	decs["ParseUint"] = strconv.ParseUint
	decs["Quote"] = strconv.Quote
	decs["QuoteRune"] = strconv.QuoteRune
	decs["QuoteRuneToASCII"] = strconv.QuoteRuneToASCII
	decs["QuoteRuneToGraphic"] = strconv.QuoteRuneToGraphic
	decs["QuoteToASCII"] = strconv.QuoteToASCII
	decs["QuoteToGraphic"] = strconv.QuoteToGraphic
	decs["Unquote"] = strconv.Unquote
	decs["UnquoteChar"] = strconv.UnquoteChar
	packages["strconv"] = &MapPackage{
		PkgName: "strconv",
		Declarations: decs,
	}
	// "strings"
	decs = make(map[string]interface{}, 50)
	decs["Builder"] = reflect.TypeOf((*strings.Builder)(nil)).Elem()
	decs["Compare"] = strings.Compare
	decs["Contains"] = strings.Contains
	decs["ContainsAny"] = strings.ContainsAny
	decs["ContainsRune"] = strings.ContainsRune
	decs["Count"] = strings.Count
	decs["EqualFold"] = strings.EqualFold
	decs["Fields"] = strings.Fields
	decs["FieldsFunc"] = strings.FieldsFunc
	decs["HasPrefix"] = strings.HasPrefix
	decs["HasSuffix"] = strings.HasSuffix
	decs["Index"] = strings.Index
	decs["IndexAny"] = strings.IndexAny
	decs["IndexByte"] = strings.IndexByte
	decs["IndexFunc"] = strings.IndexFunc
	decs["IndexRune"] = strings.IndexRune
	decs["Join"] = strings.Join
	decs["LastIndex"] = strings.LastIndex
	decs["LastIndexAny"] = strings.LastIndexAny
	decs["LastIndexByte"] = strings.LastIndexByte
	decs["LastIndexFunc"] = strings.LastIndexFunc
	decs["Map"] = strings.Map
	decs["NewReader"] = strings.NewReader
	decs["NewReplacer"] = strings.NewReplacer
	decs["Reader"] = reflect.TypeOf((*strings.Reader)(nil)).Elem()
	decs["Repeat"] = strings.Repeat
	decs["Replace"] = strings.Replace
	decs["ReplaceAll"] = strings.ReplaceAll
	decs["Replacer"] = reflect.TypeOf((*strings.Replacer)(nil)).Elem()
	decs["Split"] = strings.Split
	decs["SplitAfter"] = strings.SplitAfter
	decs["SplitAfterN"] = strings.SplitAfterN
	decs["SplitN"] = strings.SplitN
	decs["Title"] = strings.Title
	decs["ToLower"] = strings.ToLower
	decs["ToLowerSpecial"] = strings.ToLowerSpecial
	decs["ToTitle"] = strings.ToTitle
	decs["ToTitleSpecial"] = strings.ToTitleSpecial
	decs["ToUpper"] = strings.ToUpper
	decs["ToUpperSpecial"] = strings.ToUpperSpecial
	decs["ToValidUTF8"] = strings.ToValidUTF8
	decs["Trim"] = strings.Trim
	decs["TrimFunc"] = strings.TrimFunc
	decs["TrimLeft"] = strings.TrimLeft
	decs["TrimLeftFunc"] = strings.TrimLeftFunc
	decs["TrimPrefix"] = strings.TrimPrefix
	decs["TrimRight"] = strings.TrimRight
	decs["TrimRightFunc"] = strings.TrimRightFunc
	decs["TrimSpace"] = strings.TrimSpace
	decs["TrimSuffix"] = strings.TrimSuffix
	packages["strings"] = &MapPackage{
		PkgName: "strings",
		Declarations: decs,
	}
	// "sync"
	decs = make(map[string]interface{}, 9)
	decs["Cond"] = reflect.TypeOf((*sync.Cond)(nil)).Elem()
	decs["Locker"] = reflect.TypeOf((*sync.Locker)(nil)).Elem()
	decs["Map"] = reflect.TypeOf((*sync.Map)(nil)).Elem()
	decs["Mutex"] = reflect.TypeOf((*sync.Mutex)(nil)).Elem()
	decs["NewCond"] = sync.NewCond
	decs["Once"] = reflect.TypeOf((*sync.Once)(nil)).Elem()
	decs["Pool"] = reflect.TypeOf((*sync.Pool)(nil)).Elem()
	decs["RWMutex"] = reflect.TypeOf((*sync.RWMutex)(nil)).Elem()
	decs["WaitGroup"] = reflect.TypeOf((*sync.WaitGroup)(nil)).Elem()
	packages["sync"] = &MapPackage{
		PkgName: "sync",
		Declarations: decs,
	}
	// "sync/atomic"
	decs = make(map[string]interface{}, 30)
	decs["AddInt32"] = atomic.AddInt32
	decs["AddInt64"] = atomic.AddInt64
	decs["AddUint32"] = atomic.AddUint32
	decs["AddUint64"] = atomic.AddUint64
	decs["AddUintptr"] = atomic.AddUintptr
	decs["CompareAndSwapInt32"] = atomic.CompareAndSwapInt32
	decs["CompareAndSwapInt64"] = atomic.CompareAndSwapInt64
	decs["CompareAndSwapPointer"] = atomic.CompareAndSwapPointer
	decs["CompareAndSwapUint32"] = atomic.CompareAndSwapUint32
	decs["CompareAndSwapUint64"] = atomic.CompareAndSwapUint64
	decs["CompareAndSwapUintptr"] = atomic.CompareAndSwapUintptr
	decs["LoadInt32"] = atomic.LoadInt32
	decs["LoadInt64"] = atomic.LoadInt64
	decs["LoadPointer"] = atomic.LoadPointer
	decs["LoadUint32"] = atomic.LoadUint32
	decs["LoadUint64"] = atomic.LoadUint64
	decs["LoadUintptr"] = atomic.LoadUintptr
	decs["StoreInt32"] = atomic.StoreInt32
	decs["StoreInt64"] = atomic.StoreInt64
	decs["StorePointer"] = atomic.StorePointer
	decs["StoreUint32"] = atomic.StoreUint32
	decs["StoreUint64"] = atomic.StoreUint64
	decs["StoreUintptr"] = atomic.StoreUintptr
	decs["SwapInt32"] = atomic.SwapInt32
	decs["SwapInt64"] = atomic.SwapInt64
	decs["SwapPointer"] = atomic.SwapPointer
	decs["SwapUint32"] = atomic.SwapUint32
	decs["SwapUint64"] = atomic.SwapUint64
	decs["SwapUintptr"] = atomic.SwapUintptr
	decs["Value"] = reflect.TypeOf((*atomic.Value)(nil)).Elem()
	packages["sync/atomic"] = &MapPackage{
		PkgName: "atomic",
		Declarations: decs,
	}
	// "text/scanner"
	decs = make(map[string]interface{}, 21)
	decs["Char"] = UntypedNumericConst("-5")
	decs["Comment"] = UntypedNumericConst("-8")
	decs["EOF"] = UntypedNumericConst("-1")
	decs["Float"] = UntypedNumericConst("-4")
	decs["GoTokens"] = UntypedNumericConst("1012")
	decs["GoWhitespace"] = UntypedNumericConst("4294977024")
	decs["Ident"] = UntypedNumericConst("-2")
	decs["Int"] = UntypedNumericConst("-3")
	decs["Position"] = reflect.TypeOf((*scanner_.Position)(nil)).Elem()
	decs["RawString"] = UntypedNumericConst("-7")
	decs["ScanChars"] = UntypedNumericConst("32")
	decs["ScanComments"] = UntypedNumericConst("256")
	decs["ScanFloats"] = UntypedNumericConst("16")
	decs["ScanIdents"] = UntypedNumericConst("4")
	decs["ScanInts"] = UntypedNumericConst("8")
	decs["ScanRawStrings"] = UntypedNumericConst("128")
	decs["ScanStrings"] = UntypedNumericConst("64")
	decs["Scanner"] = reflect.TypeOf((*scanner_.Scanner)(nil)).Elem()
	decs["SkipComments"] = UntypedNumericConst("512")
	decs["String"] = UntypedNumericConst("-6")
	decs["TokenString"] = scanner_.TokenString
	packages["text/scanner"] = &MapPackage{
		PkgName: "scanner",
		Declarations: decs,
	}
	// "text/tabwriter"
	decs = make(map[string]interface{}, 9)
	decs["AlignRight"] = tabwriter.AlignRight
	decs["Debug"] = tabwriter.Debug
	decs["DiscardEmptyColumns"] = tabwriter.DiscardEmptyColumns
	decs["Escape"] = UntypedNumericConst("255")
	decs["FilterHTML"] = tabwriter.FilterHTML
	decs["NewWriter"] = tabwriter.NewWriter
	decs["StripEscape"] = tabwriter.StripEscape
	decs["TabIndent"] = tabwriter.TabIndent
	decs["Writer"] = reflect.TypeOf((*tabwriter.Writer)(nil)).Elem()
	packages["text/tabwriter"] = &MapPackage{
		PkgName: "tabwriter",
		Declarations: decs,
	}
	// "text/template"
	decs = make(map[string]interface{}, 16)
	decs["ExecError"] = reflect.TypeOf((*template_.ExecError)(nil)).Elem()
	decs["FuncMap"] = reflect.TypeOf((*template_.FuncMap)(nil)).Elem()
	decs["HTMLEscape"] = template_.HTMLEscape
	decs["HTMLEscapeString"] = template_.HTMLEscapeString
	decs["HTMLEscaper"] = template_.HTMLEscaper
	decs["IsTrue"] = template_.IsTrue
	decs["JSEscape"] = template_.JSEscape
	decs["JSEscapeString"] = template_.JSEscapeString
	decs["JSEscaper"] = template_.JSEscaper
	decs["Must"] = template_.Must
	decs["New"] = template_.New
	decs["ParseFS"] = template_.ParseFS
	decs["ParseFiles"] = template_.ParseFiles
	decs["ParseGlob"] = template_.ParseGlob
	decs["Template"] = reflect.TypeOf((*template_.Template)(nil)).Elem()
	decs["URLQueryEscaper"] = template_.URLQueryEscaper
	packages["text/template"] = &MapPackage{
		PkgName: "template",
		Declarations: decs,
	}
	// "text/template/parse"
	decs = make(map[string]interface{}, 49)
	decs["ActionNode"] = reflect.TypeOf((*parse.ActionNode)(nil)).Elem()
	decs["BoolNode"] = reflect.TypeOf((*parse.BoolNode)(nil)).Elem()
	decs["BranchNode"] = reflect.TypeOf((*parse.BranchNode)(nil)).Elem()
	decs["ChainNode"] = reflect.TypeOf((*parse.ChainNode)(nil)).Elem()
	decs["CommandNode"] = reflect.TypeOf((*parse.CommandNode)(nil)).Elem()
	decs["CommentNode"] = reflect.TypeOf((*parse.CommentNode)(nil)).Elem()
	decs["DotNode"] = reflect.TypeOf((*parse.DotNode)(nil)).Elem()
	decs["FieldNode"] = reflect.TypeOf((*parse.FieldNode)(nil)).Elem()
	decs["IdentifierNode"] = reflect.TypeOf((*parse.IdentifierNode)(nil)).Elem()
	decs["IfNode"] = reflect.TypeOf((*parse.IfNode)(nil)).Elem()
	decs["IsEmptyTree"] = parse.IsEmptyTree
	decs["ListNode"] = reflect.TypeOf((*parse.ListNode)(nil)).Elem()
	decs["Mode"] = reflect.TypeOf((*parse.Mode)(nil)).Elem()
	decs["New"] = parse.New
	decs["NewIdentifier"] = parse.NewIdentifier
	decs["NilNode"] = reflect.TypeOf((*parse.NilNode)(nil)).Elem()
	decs["Node"] = reflect.TypeOf((*parse.Node)(nil)).Elem()
	decs["NodeAction"] = parse.NodeAction
	decs["NodeBool"] = parse.NodeBool
	decs["NodeChain"] = parse.NodeChain
	decs["NodeCommand"] = parse.NodeCommand
	decs["NodeComment"] = parse.NodeComment
	decs["NodeDot"] = parse.NodeDot
	decs["NodeField"] = parse.NodeField
	decs["NodeIdentifier"] = parse.NodeIdentifier
	decs["NodeIf"] = parse.NodeIf
	decs["NodeList"] = parse.NodeList
	decs["NodeNil"] = parse.NodeNil
	decs["NodeNumber"] = parse.NodeNumber
	decs["NodePipe"] = parse.NodePipe
	decs["NodeRange"] = parse.NodeRange
	decs["NodeString"] = parse.NodeString
	decs["NodeTemplate"] = parse.NodeTemplate
	decs["NodeText"] = parse.NodeText
	decs["NodeType"] = reflect.TypeOf((*parse.NodeType)(nil)).Elem()
	decs["NodeVariable"] = parse.NodeVariable
	decs["NodeWith"] = parse.NodeWith
	decs["NumberNode"] = reflect.TypeOf((*parse.NumberNode)(nil)).Elem()
	decs["Parse"] = parse.Parse
	decs["ParseComments"] = parse.ParseComments
	decs["PipeNode"] = reflect.TypeOf((*parse.PipeNode)(nil)).Elem()
	decs["Pos"] = reflect.TypeOf((*parse.Pos)(nil)).Elem()
	decs["RangeNode"] = reflect.TypeOf((*parse.RangeNode)(nil)).Elem()
	decs["StringNode"] = reflect.TypeOf((*parse.StringNode)(nil)).Elem()
	decs["TemplateNode"] = reflect.TypeOf((*parse.TemplateNode)(nil)).Elem()
	decs["TextNode"] = reflect.TypeOf((*parse.TextNode)(nil)).Elem()
	decs["Tree"] = reflect.TypeOf((*parse.Tree)(nil)).Elem()
	decs["VariableNode"] = reflect.TypeOf((*parse.VariableNode)(nil)).Elem()
	decs["WithNode"] = reflect.TypeOf((*parse.WithNode)(nil)).Elem()
	packages["text/template/parse"] = &MapPackage{
		PkgName: "parse",
		Declarations: decs,
	}
	// "time"
	decs = make(map[string]interface{}, 67)
	decs["ANSIC"] = UntypedStringConst("Mon Jan _2 15:04:05 2006")
	decs["After"] = time.After
	decs["AfterFunc"] = time.AfterFunc
	decs["April"] = time.April
	decs["August"] = time.August
	decs["Date"] = time.Date
	decs["December"] = time.December
	decs["Duration"] = reflect.TypeOf((*time.Duration)(nil)).Elem()
	decs["February"] = time.February
	decs["FixedZone"] = time.FixedZone
	decs["Friday"] = time.Friday
	decs["Hour"] = time.Hour
	decs["January"] = time.January
	decs["July"] = time.July
	decs["June"] = time.June
	decs["Kitchen"] = UntypedStringConst("3:04PM")
	decs["LoadLocation"] = time.LoadLocation
	decs["LoadLocationFromTZData"] = time.LoadLocationFromTZData
	decs["Local"] = &time.Local
	decs["Location"] = reflect.TypeOf((*time.Location)(nil)).Elem()
	decs["March"] = time.March
	decs["May"] = time.May
	decs["Microsecond"] = time.Microsecond
	decs["Millisecond"] = time.Millisecond
	decs["Minute"] = time.Minute
	decs["Monday"] = time.Monday
	decs["Month"] = reflect.TypeOf((*time.Month)(nil)).Elem()
	decs["Nanosecond"] = time.Nanosecond
	decs["NewTicker"] = time.NewTicker
	decs["NewTimer"] = time.NewTimer
	decs["November"] = time.November
	decs["Now"] = time.Now
	decs["October"] = time.October
	decs["Parse"] = time.Parse
	decs["ParseDuration"] = time.ParseDuration
	decs["ParseError"] = reflect.TypeOf((*time.ParseError)(nil)).Elem()
	decs["ParseInLocation"] = time.ParseInLocation
	decs["RFC1123"] = UntypedStringConst("Mon, 02 Jan 2006 15:04:05 MST")
	decs["RFC1123Z"] = UntypedStringConst("Mon, 02 Jan 2006 15:04:05 -0700")
	decs["RFC3339"] = UntypedStringConst("2006-01-02T15:04:05Z07:00")
	decs["RFC3339Nano"] = UntypedStringConst("2006-01-02T15:04:05.999999999Z07:00")
	decs["RFC822"] = UntypedStringConst("02 Jan 06 15:04 MST")
	decs["RFC822Z"] = UntypedStringConst("02 Jan 06 15:04 -0700")
	decs["RFC850"] = UntypedStringConst("Monday, 02-Jan-06 15:04:05 MST")
	decs["RubyDate"] = UntypedStringConst("Mon Jan 02 15:04:05 -0700 2006")
	decs["Saturday"] = time.Saturday
	decs["Second"] = time.Second
	decs["September"] = time.September
	decs["Since"] = time.Since
	decs["Sleep"] = time.Sleep
	decs["Stamp"] = UntypedStringConst("Jan _2 15:04:05")
	decs["StampMicro"] = UntypedStringConst("Jan _2 15:04:05.000000")
	decs["StampMilli"] = UntypedStringConst("Jan _2 15:04:05.000")
	decs["StampNano"] = UntypedStringConst("Jan _2 15:04:05.000000000")
	decs["Sunday"] = time.Sunday
	decs["Thursday"] = time.Thursday
	decs["Tick"] = time.Tick
	decs["Ticker"] = reflect.TypeOf((*time.Ticker)(nil)).Elem()
	decs["Time"] = reflect.TypeOf((*time.Time)(nil)).Elem()
	decs["Timer"] = reflect.TypeOf((*time.Timer)(nil)).Elem()
	decs["Tuesday"] = time.Tuesday
	decs["UTC"] = &time.UTC
	decs["Unix"] = time.Unix
	decs["UnixDate"] = UntypedStringConst("Mon Jan _2 15:04:05 MST 2006")
	decs["Until"] = time.Until
	decs["Wednesday"] = time.Wednesday
	decs["Weekday"] = reflect.TypeOf((*time.Weekday)(nil)).Elem()
	packages["time"] = &MapPackage{
		PkgName: "time",
		Declarations: decs,
	}
	// "unicode"
	decs = make(map[string]interface{}, 284)
	decs["ASCII_Hex_Digit"] = &unicode.ASCII_Hex_Digit
	decs["Adlam"] = &unicode.Adlam
	decs["Ahom"] = &unicode.Ahom
	decs["Anatolian_Hieroglyphs"] = &unicode.Anatolian_Hieroglyphs
	decs["Arabic"] = &unicode.Arabic
	decs["Armenian"] = &unicode.Armenian
	decs["Avestan"] = &unicode.Avestan
	decs["AzeriCase"] = &unicode.AzeriCase
	decs["Balinese"] = &unicode.Balinese
	decs["Bamum"] = &unicode.Bamum
	decs["Bassa_Vah"] = &unicode.Bassa_Vah
	decs["Batak"] = &unicode.Batak
	decs["Bengali"] = &unicode.Bengali
	decs["Bhaiksuki"] = &unicode.Bhaiksuki
	decs["Bidi_Control"] = &unicode.Bidi_Control
	decs["Bopomofo"] = &unicode.Bopomofo
	decs["Brahmi"] = &unicode.Brahmi
	decs["Braille"] = &unicode.Braille
	decs["Buginese"] = &unicode.Buginese
	decs["Buhid"] = &unicode.Buhid
	decs["C"] = &unicode.C
	decs["Canadian_Aboriginal"] = &unicode.Canadian_Aboriginal
	decs["Carian"] = &unicode.Carian
	decs["CaseRange"] = reflect.TypeOf((*unicode.CaseRange)(nil)).Elem()
	decs["CaseRanges"] = &unicode.CaseRanges
	decs["Categories"] = &unicode.Categories
	decs["Caucasian_Albanian"] = &unicode.Caucasian_Albanian
	decs["Cc"] = &unicode.Cc
	decs["Cf"] = &unicode.Cf
	decs["Chakma"] = &unicode.Chakma
	decs["Cham"] = &unicode.Cham
	decs["Cherokee"] = &unicode.Cherokee
	decs["Chorasmian"] = &unicode.Chorasmian
	decs["Co"] = &unicode.Co
	decs["Common"] = &unicode.Common
	decs["Coptic"] = &unicode.Coptic
	decs["Cs"] = &unicode.Cs
	decs["Cuneiform"] = &unicode.Cuneiform
	decs["Cypriot"] = &unicode.Cypriot
	decs["Cyrillic"] = &unicode.Cyrillic
	decs["Dash"] = &unicode.Dash
	decs["Deprecated"] = &unicode.Deprecated
	decs["Deseret"] = &unicode.Deseret
	decs["Devanagari"] = &unicode.Devanagari
	decs["Diacritic"] = &unicode.Diacritic
	decs["Digit"] = &unicode.Digit
	decs["Dives_Akuru"] = &unicode.Dives_Akuru
	decs["Dogra"] = &unicode.Dogra
	decs["Duployan"] = &unicode.Duployan
	decs["Egyptian_Hieroglyphs"] = &unicode.Egyptian_Hieroglyphs
	decs["Elbasan"] = &unicode.Elbasan
	decs["Elymaic"] = &unicode.Elymaic
	decs["Ethiopic"] = &unicode.Ethiopic
	decs["Extender"] = &unicode.Extender
	decs["FoldCategory"] = &unicode.FoldCategory
	decs["FoldScript"] = &unicode.FoldScript
	decs["Georgian"] = &unicode.Georgian
	decs["Glagolitic"] = &unicode.Glagolitic
	decs["Gothic"] = &unicode.Gothic
	decs["Grantha"] = &unicode.Grantha
	decs["GraphicRanges"] = &unicode.GraphicRanges
	decs["Greek"] = &unicode.Greek
	decs["Gujarati"] = &unicode.Gujarati
	decs["Gunjala_Gondi"] = &unicode.Gunjala_Gondi
	decs["Gurmukhi"] = &unicode.Gurmukhi
	decs["Han"] = &unicode.Han
	decs["Hangul"] = &unicode.Hangul
	decs["Hanifi_Rohingya"] = &unicode.Hanifi_Rohingya
	decs["Hanunoo"] = &unicode.Hanunoo
	decs["Hatran"] = &unicode.Hatran
	decs["Hebrew"] = &unicode.Hebrew
	decs["Hex_Digit"] = &unicode.Hex_Digit
	decs["Hiragana"] = &unicode.Hiragana
	decs["Hyphen"] = &unicode.Hyphen
	decs["IDS_Binary_Operator"] = &unicode.IDS_Binary_Operator
	decs["IDS_Trinary_Operator"] = &unicode.IDS_Trinary_Operator
	decs["Ideographic"] = &unicode.Ideographic
	decs["Imperial_Aramaic"] = &unicode.Imperial_Aramaic
	decs["In"] = unicode.In
	decs["Inherited"] = &unicode.Inherited
	decs["Inscriptional_Pahlavi"] = &unicode.Inscriptional_Pahlavi
	decs["Inscriptional_Parthian"] = &unicode.Inscriptional_Parthian
	decs["Is"] = unicode.Is
	decs["IsControl"] = unicode.IsControl
	decs["IsDigit"] = unicode.IsDigit
	decs["IsGraphic"] = unicode.IsGraphic
	decs["IsLetter"] = unicode.IsLetter
	decs["IsLower"] = unicode.IsLower
	decs["IsMark"] = unicode.IsMark
	decs["IsNumber"] = unicode.IsNumber
	decs["IsOneOf"] = unicode.IsOneOf
	decs["IsPrint"] = unicode.IsPrint
	decs["IsPunct"] = unicode.IsPunct
	decs["IsSpace"] = unicode.IsSpace
	decs["IsSymbol"] = unicode.IsSymbol
	decs["IsTitle"] = unicode.IsTitle
	decs["IsUpper"] = unicode.IsUpper
	decs["Javanese"] = &unicode.Javanese
	decs["Join_Control"] = &unicode.Join_Control
	decs["Kaithi"] = &unicode.Kaithi
	decs["Kannada"] = &unicode.Kannada
	decs["Katakana"] = &unicode.Katakana
	decs["Kayah_Li"] = &unicode.Kayah_Li
	decs["Kharoshthi"] = &unicode.Kharoshthi
	decs["Khitan_Small_Script"] = &unicode.Khitan_Small_Script
	decs["Khmer"] = &unicode.Khmer
	decs["Khojki"] = &unicode.Khojki
	decs["Khudawadi"] = &unicode.Khudawadi
	decs["L"] = &unicode.L
	decs["Lao"] = &unicode.Lao
	decs["Latin"] = &unicode.Latin
	decs["Lepcha"] = &unicode.Lepcha
	decs["Letter"] = &unicode.Letter
	decs["Limbu"] = &unicode.Limbu
	decs["Linear_A"] = &unicode.Linear_A
	decs["Linear_B"] = &unicode.Linear_B
	decs["Lisu"] = &unicode.Lisu
	decs["Ll"] = &unicode.Ll
	decs["Lm"] = &unicode.Lm
	decs["Lo"] = &unicode.Lo
	decs["Logical_Order_Exception"] = &unicode.Logical_Order_Exception
	decs["Lower"] = &unicode.Lower
	decs["LowerCase"] = UntypedNumericConst("1")
	decs["Lt"] = &unicode.Lt
	decs["Lu"] = &unicode.Lu
	decs["Lycian"] = &unicode.Lycian
	decs["Lydian"] = &unicode.Lydian
	decs["M"] = &unicode.M
	decs["Mahajani"] = &unicode.Mahajani
	decs["Makasar"] = &unicode.Makasar
	decs["Malayalam"] = &unicode.Malayalam
	decs["Mandaic"] = &unicode.Mandaic
	decs["Manichaean"] = &unicode.Manichaean
	decs["Marchen"] = &unicode.Marchen
	decs["Mark"] = &unicode.Mark
	decs["Masaram_Gondi"] = &unicode.Masaram_Gondi
	decs["MaxASCII"] = UntypedNumericConst("127")
	decs["MaxCase"] = UntypedNumericConst("3")
	decs["MaxLatin1"] = UntypedNumericConst("255")
	decs["MaxRune"] = UntypedNumericConst("1114111")
	decs["Mc"] = &unicode.Mc
	decs["Me"] = &unicode.Me
	decs["Medefaidrin"] = &unicode.Medefaidrin
	decs["Meetei_Mayek"] = &unicode.Meetei_Mayek
	decs["Mende_Kikakui"] = &unicode.Mende_Kikakui
	decs["Meroitic_Cursive"] = &unicode.Meroitic_Cursive
	decs["Meroitic_Hieroglyphs"] = &unicode.Meroitic_Hieroglyphs
	decs["Miao"] = &unicode.Miao
	decs["Mn"] = &unicode.Mn
	decs["Modi"] = &unicode.Modi
	decs["Mongolian"] = &unicode.Mongolian
	decs["Mro"] = &unicode.Mro
	decs["Multani"] = &unicode.Multani
	decs["Myanmar"] = &unicode.Myanmar
	decs["N"] = &unicode.N
	decs["Nabataean"] = &unicode.Nabataean
	decs["Nandinagari"] = &unicode.Nandinagari
	decs["Nd"] = &unicode.Nd
	decs["New_Tai_Lue"] = &unicode.New_Tai_Lue
	decs["Newa"] = &unicode.Newa
	decs["Nko"] = &unicode.Nko
	decs["Nl"] = &unicode.Nl
	decs["No"] = &unicode.No
	decs["Noncharacter_Code_Point"] = &unicode.Noncharacter_Code_Point
	decs["Number"] = &unicode.Number
	decs["Nushu"] = &unicode.Nushu
	decs["Nyiakeng_Puachue_Hmong"] = &unicode.Nyiakeng_Puachue_Hmong
	decs["Ogham"] = &unicode.Ogham
	decs["Ol_Chiki"] = &unicode.Ol_Chiki
	decs["Old_Hungarian"] = &unicode.Old_Hungarian
	decs["Old_Italic"] = &unicode.Old_Italic
	decs["Old_North_Arabian"] = &unicode.Old_North_Arabian
	decs["Old_Permic"] = &unicode.Old_Permic
	decs["Old_Persian"] = &unicode.Old_Persian
	decs["Old_Sogdian"] = &unicode.Old_Sogdian
	decs["Old_South_Arabian"] = &unicode.Old_South_Arabian
	decs["Old_Turkic"] = &unicode.Old_Turkic
	decs["Oriya"] = &unicode.Oriya
	decs["Osage"] = &unicode.Osage
	decs["Osmanya"] = &unicode.Osmanya
	decs["Other"] = &unicode.Other
	decs["Other_Alphabetic"] = &unicode.Other_Alphabetic
	decs["Other_Default_Ignorable_Code_Point"] = &unicode.Other_Default_Ignorable_Code_Point
	decs["Other_Grapheme_Extend"] = &unicode.Other_Grapheme_Extend
	decs["Other_ID_Continue"] = &unicode.Other_ID_Continue
	decs["Other_ID_Start"] = &unicode.Other_ID_Start
	decs["Other_Lowercase"] = &unicode.Other_Lowercase
	decs["Other_Math"] = &unicode.Other_Math
	decs["Other_Uppercase"] = &unicode.Other_Uppercase
	decs["P"] = &unicode.P
	decs["Pahawh_Hmong"] = &unicode.Pahawh_Hmong
	decs["Palmyrene"] = &unicode.Palmyrene
	decs["Pattern_Syntax"] = &unicode.Pattern_Syntax
	decs["Pattern_White_Space"] = &unicode.Pattern_White_Space
	decs["Pau_Cin_Hau"] = &unicode.Pau_Cin_Hau
	decs["Pc"] = &unicode.Pc
	decs["Pd"] = &unicode.Pd
	decs["Pe"] = &unicode.Pe
	decs["Pf"] = &unicode.Pf
	decs["Phags_Pa"] = &unicode.Phags_Pa
	decs["Phoenician"] = &unicode.Phoenician
	decs["Pi"] = &unicode.Pi
	decs["Po"] = &unicode.Po
	decs["Prepended_Concatenation_Mark"] = &unicode.Prepended_Concatenation_Mark
	decs["PrintRanges"] = &unicode.PrintRanges
	decs["Properties"] = &unicode.Properties
	decs["Ps"] = &unicode.Ps
	decs["Psalter_Pahlavi"] = &unicode.Psalter_Pahlavi
	decs["Punct"] = &unicode.Punct
	decs["Quotation_Mark"] = &unicode.Quotation_Mark
	decs["Radical"] = &unicode.Radical
	decs["Range16"] = reflect.TypeOf((*unicode.Range16)(nil)).Elem()
	decs["Range32"] = reflect.TypeOf((*unicode.Range32)(nil)).Elem()
	decs["RangeTable"] = reflect.TypeOf((*unicode.RangeTable)(nil)).Elem()
	decs["Regional_Indicator"] = &unicode.Regional_Indicator
	decs["Rejang"] = &unicode.Rejang
	decs["ReplacementChar"] = UntypedNumericConst("65533")
	decs["Runic"] = &unicode.Runic
	decs["S"] = &unicode.S
	decs["STerm"] = &unicode.STerm
	decs["Samaritan"] = &unicode.Samaritan
	decs["Saurashtra"] = &unicode.Saurashtra
	decs["Sc"] = &unicode.Sc
	decs["Scripts"] = &unicode.Scripts
	decs["Sentence_Terminal"] = &unicode.Sentence_Terminal
	decs["Sharada"] = &unicode.Sharada
	decs["Shavian"] = &unicode.Shavian
	decs["Siddham"] = &unicode.Siddham
	decs["SignWriting"] = &unicode.SignWriting
	decs["SimpleFold"] = unicode.SimpleFold
	decs["Sinhala"] = &unicode.Sinhala
	decs["Sk"] = &unicode.Sk
	decs["Sm"] = &unicode.Sm
	decs["So"] = &unicode.So
	decs["Soft_Dotted"] = &unicode.Soft_Dotted
	decs["Sogdian"] = &unicode.Sogdian
	decs["Sora_Sompeng"] = &unicode.Sora_Sompeng
	decs["Soyombo"] = &unicode.Soyombo
	decs["Space"] = &unicode.Space
	decs["SpecialCase"] = reflect.TypeOf((*unicode.SpecialCase)(nil)).Elem()
	decs["Sundanese"] = &unicode.Sundanese
	decs["Syloti_Nagri"] = &unicode.Syloti_Nagri
	decs["Symbol"] = &unicode.Symbol
	decs["Syriac"] = &unicode.Syriac
	decs["Tagalog"] = &unicode.Tagalog
	decs["Tagbanwa"] = &unicode.Tagbanwa
	decs["Tai_Le"] = &unicode.Tai_Le
	decs["Tai_Tham"] = &unicode.Tai_Tham
	decs["Tai_Viet"] = &unicode.Tai_Viet
	decs["Takri"] = &unicode.Takri
	decs["Tamil"] = &unicode.Tamil
	decs["Tangut"] = &unicode.Tangut
	decs["Telugu"] = &unicode.Telugu
	decs["Terminal_Punctuation"] = &unicode.Terminal_Punctuation
	decs["Thaana"] = &unicode.Thaana
	decs["Thai"] = &unicode.Thai
	decs["Tibetan"] = &unicode.Tibetan
	decs["Tifinagh"] = &unicode.Tifinagh
	decs["Tirhuta"] = &unicode.Tirhuta
	decs["Title"] = &unicode.Title
	decs["TitleCase"] = UntypedNumericConst("2")
	decs["To"] = unicode.To
	decs["ToLower"] = unicode.ToLower
	decs["ToTitle"] = unicode.ToTitle
	decs["ToUpper"] = unicode.ToUpper
	decs["TurkishCase"] = &unicode.TurkishCase
	decs["Ugaritic"] = &unicode.Ugaritic
	decs["Unified_Ideograph"] = &unicode.Unified_Ideograph
	decs["Upper"] = &unicode.Upper
	decs["UpperCase"] = UntypedNumericConst("0")
	decs["UpperLower"] = UntypedNumericConst("1114112")
	decs["Vai"] = &unicode.Vai
	decs["Variation_Selector"] = &unicode.Variation_Selector
	decs["Version"] = UntypedStringConst("13.0.0")
	decs["Wancho"] = &unicode.Wancho
	decs["Warang_Citi"] = &unicode.Warang_Citi
	decs["White_Space"] = &unicode.White_Space
	decs["Yezidi"] = &unicode.Yezidi
	decs["Yi"] = &unicode.Yi
	decs["Z"] = &unicode.Z
	decs["Zanabazar_Square"] = &unicode.Zanabazar_Square
	decs["Zl"] = &unicode.Zl
	decs["Zp"] = &unicode.Zp
	decs["Zs"] = &unicode.Zs
	packages["unicode"] = &MapPackage{
		PkgName: "unicode",
		Declarations: decs,
	}
	// "unicode/utf16"
	decs = make(map[string]interface{}, 5)
	decs["Decode"] = utf16.Decode
	decs["DecodeRune"] = utf16.DecodeRune
	decs["Encode"] = utf16.Encode
	decs["EncodeRune"] = utf16.EncodeRune
	decs["IsSurrogate"] = utf16.IsSurrogate
	packages["unicode/utf16"] = &MapPackage{
		PkgName: "utf16",
		Declarations: decs,
	}
	// "unicode/utf8"
	decs = make(map[string]interface{}, 18)
	decs["DecodeLastRune"] = utf8.DecodeLastRune
	decs["DecodeLastRuneInString"] = utf8.DecodeLastRuneInString
	decs["DecodeRune"] = utf8.DecodeRune
	decs["DecodeRuneInString"] = utf8.DecodeRuneInString
	decs["EncodeRune"] = utf8.EncodeRune
	decs["FullRune"] = utf8.FullRune
	decs["FullRuneInString"] = utf8.FullRuneInString
	decs["MaxRune"] = UntypedNumericConst("1114111")
	decs["RuneCount"] = utf8.RuneCount
	decs["RuneCountInString"] = utf8.RuneCountInString
	decs["RuneError"] = UntypedNumericConst("65533")
	decs["RuneLen"] = utf8.RuneLen
	decs["RuneSelf"] = UntypedNumericConst("128")
	decs["RuneStart"] = utf8.RuneStart
	decs["UTFMax"] = UntypedNumericConst("4")
	decs["Valid"] = utf8.Valid
	decs["ValidRune"] = utf8.ValidRune
	decs["ValidString"] = utf8.ValidString
	packages["unicode/utf8"] = &MapPackage{
		PkgName: "utf8",
		Declarations: decs,
	}
}
`)
	sources["parser.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"fmt"
	"io"
	"strings"
	"unicode/utf8"
)

type Command int

const (
	commandEmbed Command = iota
	commandGenerate
	commandInstall
)

// scriggofile represents the content of a Scriggofile.
type scriggofile struct {
	pkgName  string           // name of the package to be generated.
	variable string           // variable name for embedded packages.
	goos     []string         // target GOOSs.
	imports  []*importCommand // list of imports defined in file.
}

// importCommand represents an IMPORT command in a Scriggofile.
type importCommand struct {
	stdlib         bool
	path           string
	asPath         string // import asPath asPath in Scriggo.
	notCapitalized bool   // exported names must not be capitalized.
	including      []string
	excluding      []string
}

// parseScriggofile parses a Scriggofile and returns its commands.
func parseScriggofile(src io.Reader, goos string) (*scriggofile, error) {

	sf := scriggofile{
		pkgName:  "main",
		variable: "packages",
	}

	scanner := bufio.NewScanner(src)
	ln := 0

	for scanner.Scan() {

		line := scanner.Text()
		if ln == 0 {
			// Remove UTF-8 BOM.
			line = strings.TrimPrefix(line, "0xEF0xBB0xBF")
		}
		ln++
		if !utf8.ValidString(line) {
			return nil, fmt.Errorf("invalid UTF-8 character at line %d", ln)
		}

		line = strings.TrimSpace(line)
		if len(line) == 0 || line[0] == '#' {
			continue
		}
		tokens := strings.Fields(line)
		if len(tokens) == 0 {
			continue
		}

		switch strings.ToUpper(tokens[0]) {
		case "SET":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("expecting VARIABLE or PACKAGE after %s at line %d", tokens[0], ln)
			}
			switch strings.ToUpper(tokens[1]) {
			case "VARIABLE":
				if len(tokens) == 2 {
					return nil, fmt.Errorf("missing variable name at line %d", ln)
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("too many variable names at line %d", ln)
				}
				variable := string(tokens[2])
				err := checkIdentifierName(variable)
				if err != nil {
					return nil, err
				}
				sf.variable = variable
			case "PACKAGE":
				if len(tokens) == 2 {
					return nil, fmt.Errorf("missing package name at line %d", ln)
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("too many packages names at line %d", ln)
				}
				pkgName := string(tokens[2])
				err := checkIdentifierName(pkgName)
				if err != nil {
					return nil, err
				}
				sf.pkgName = pkgName
			default:
				return nil, fmt.Errorf("unexpected %s %s, expecteding %s VARIABLE or %s PACKAGE at line %d",
					tokens[0], tokens[1], tokens[0], tokens[0], ln)
			}
		case "GOOS":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("missing os after %s at line %d", tokens[0], ln)
			}
			if sf.goos == nil {
				sf.goos = make([]string, 0, len(tokens)-1)
			}
			for _, tok := range tokens[1:] {
				os := string(tok)
				err := checkGOOS(os)
				if err != nil {
					return nil, err
				}
				sf.goos = append(sf.goos, os)
			}
		case "IMPORT":
			if len(tokens) == 1 {
				return nil, fmt.Errorf("missing package path at line %d", ln)
			}
			path := string(tokens[1])
			if len(tokens) > 2 && strings.EqualFold(path, "STANDARD") && strings.EqualFold(tokens[2], "LIBRARY") {
				for _, imp := range sf.imports {
					if imp.stdlib {
						return nil, fmt.Errorf("command %s %s %s is repeated at line %d", tokens[0], tokens[1], tokens[2], ln)
					}
				}
				if len(tokens) > 3 {
					return nil, fmt.Errorf("unexpected %q after %s %s %s at line %d", tokens[3], tokens[0], tokens[1], tokens[2], ln)
				}
				sf.imports = append(sf.imports, &importCommand{stdlib: true})
				continue
			} else {
				err := checkPackagePath(path)
				if err != nil {
					return nil, err
				}
			}
			imp := importCommand{path: path}
			parsedAs := false
			tokens = tokens[2:]
			for len(tokens) > 0 {
				switch tok := strings.ToUpper(tokens[0]); tok {
				case "AS":
					if parsedAs {
						return nil, fmt.Errorf("repeated option %s at line %d", tok, ln)
					}
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing package path after AS at line %d", ln)
					}
					path := string(tokens[1])
					err := checkPackagePath(path)
					if err != nil {
						return nil, err
					}
					if hasStdlibPrefix(path) {
						return nil, fmt.Errorf("invalid path %q (prefix conflicts with Go standard library)", path)
					}
					imp.asPath = path
					parsedAs = true
					tokens = tokens[2:]
				case "INCLUDING":
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing names after INCLUDING at line %d", ln)
					}
					imp.including = make([]string, len(tokens)-1)
					for i, tok := range tokens[1:] {
						name := string(tok)
						err := checkExportedName(name)
						if err != nil {
							return nil, err
						}
						imp.including[i] = name
					}
					tokens = nil
				case "EXCLUDING":
					if len(tokens) == 1 {
						return nil, fmt.Errorf("missing names after EXCLUDING at line %d", ln)
					}
					imp.excluding = make([]string, len(tokens)-1)
					for i, tok := range tokens[1:] {
						name := string(tok)
						err := checkExportedName(name)
						if err != nil {
							return nil, err
						}
						imp.excluding[i] = name
					}
					tokens = nil
				case "NOT":
					if len(tokens) == 1 {
						if imp.asPath == "main" {
							return nil, fmt.Errorf("unexpected %s, expecting %s CAPITALIZED at line %d", tok, tok, ln)
						}
						return nil, fmt.Errorf("unexpected %s at line %d", tok, ln)
					}
					if strings.ToUpper(tokens[1]) != "CAPITALIZED" {
						if imp.asPath == "main" {
							return nil, fmt.Errorf("unexpected %s %s, expecting %s CAPITALIZED at line %d", tok, tokens[1], tok, ln)
						}
						return nil, fmt.Errorf("unexpected %s", tok)
					}
					if imp.asPath != "main" {
						return nil, fmt.Errorf("%s %s can appear only after 'AS main' at line %d", tok, tokens[1], ln)
					}
					imp.notCapitalized = true
					tokens = tokens[2:]
				default:
					return nil, fmt.Errorf("unexpected option %s for IMPORT at line %d", tok, ln)
				}
			}
			sf.imports = append(sf.imports, &imp)
		default:
			return nil, fmt.Errorf("unknown command %s at line %d", tokens[0], ln)
		}

	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	if len(sf.goos) > 0 {
		found := false
		for _, os := range sf.goos {
			if os == goos {
				found = true
				break
			}
		}
		if !found {
			return nil, fmt.Errorf("GOOS %s not supported in Scriggofile", goos)
		}
	}

	return &sf, nil
}
`)
	sources["run.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/open2b/scriggo"
	"github.com/open2b/scriggo/runtime"
	"github.com/open2b/scriggo/scripts"
)

const usage = "usage: %s [-S] filename\n"

var packages scriggo.Packages

func run() {

	var asm = flag.Bool("S", false, "print assembly listing")

	flag.Parse()

	var args = flag.Args()

	if len(args) != 1 {
		_, _ = fmt.Fprintf(os.Stderr, usage, os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}

	file := args[0]
	ext := filepath.Ext(file)
	if ext != ".go" && ext != ".ggo" {
		fmt.Printf("%s: extension must be \".go\" for programs and \".ggo\" for scripts\n", file)
		os.Exit(1)
	}

	absFile, err := filepath.Abs(file)
	if err != nil {
		fmt.Printf("%s: %s\n", file, err)
		os.Exit(1)
	}

	main, err := ioutil.ReadFile(absFile)
	if err != nil {
		panic(err)
	}

	if ext == ".go" {

		program, err := scriggo.Build(bytes.NewReader(main), &scriggo.BuildOptions{Packages: packages})
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
		if *asm {
			asm, _ := program.Disassemble("main")
			_, err := os.Stdout.Write(asm)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
		} else {
			code, err := program.Run(nil)
			if err != nil {
				if p, ok := err.(*runtime.Panic); ok {
					panic(p)
				}
				if err == context.DeadlineExceeded {
					err = errors.New("process took too long")
				}
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
			os.Exit(code)
		}

	} else {

		script, err := scripts.Build(bytes.NewReader(main), &scripts.BuildOptions{Packages: packages})
		if err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
			os.Exit(2)
		}
		if *asm {
			asm := script.Disassemble()
			_, err := os.Stdout.Write(asm)
			if err != nil {
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
		} else {
			code, err := script.Run(nil, nil)
			if err != nil {
				if p, ok := err.(*runtime.Panic); ok {
					panic(p)
				}
				if err == context.DeadlineExceeded {
					err = errors.New("process took too long")
				}
				_, _ = fmt.Fprintf(os.Stderr, "scriggo: %s\n", err)
				os.Exit(2)
			}
			os.Exit(code)
		}

	}

	os.Exit(0)
}
`)
	sources["serve.go"] = []byte(`// Copyright (c) 2020 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path"
	"reflect"
	"strings"
	"sync"
	"time"

	"github.com/open2b/scriggo"
	"github.com/open2b/scriggo/templates"
	"github.com/open2b/scriggo/templates/builtin"

	"github.com/fsnotify/fsnotify"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/renderer/html"
)

// serve runs a web server and serves the template rooted at the current
// directory. metrics reports whether print the metrics. If asm is -1 or
// greater, serve prints the assembly code of the served file and the value of
// asm determines the maximum length, in runes, of disassembled Text
// instructions
//
//   asm > 0: at most asm runes; leading and trailing white space are removed
//   asm == 0: no text
//   asm == -1: all text
//
func serve(asm int, metrics bool) error {

	fsys, err := newTemplateFS(".")
	if err != nil {
		return err
	}
	defer fsys.Close()

	md := goldmark.New(
		goldmark.WithRendererOptions(html.WithUnsafe()),
		goldmark.WithParserOptions(parser.WithAutoHeadingID()))

	srv := &server{
		fsys:   fsys,
		static: http.FileServer(http.Dir(".")),
		buildOptions: &templates.BuildOptions{
			Globals: globals,
			MarkdownConverter: func(src []byte, out io.Writer) error {
				return md.Convert(src, out)
			},
		},
		templates: map[string]*templates.Template{},
		asm:       asm,
	}
	if metrics {
		srv.metrics.active = true
		srv.metrics.header = true
	}
	go func() {
		for {
			select {
			case name := <-fsys.Changed:
				delete(srv.templates, name)
			case err := <-fsys.Errors:
				srv.logf("%v", err)
			}
		}
	}()

	s := &http.Server{
		Addr:           ":8080",
		Handler:        srv,
		ReadTimeout:    10 * time.Second,
		WriteTimeout:   10 * time.Second,
		MaxHeaderBytes: 1 << 20,
	}

	fmt.Fprintln(os.Stderr, "Web server is available at http://localhost:8080/")
	fmt.Fprintf(os.Stderr, "Press Ctrl+C to stop\n\n")

	return s.ListenAndServe()
}

type server struct {
	fsys         *templateFS
	static       http.Handler
	buildOptions *templates.BuildOptions
	runOptions   *templates.RunOptions
	asm          int

	sync.Mutex
	templates map[string]*templates.Template
	metrics   struct {
		active bool
		header bool
	}
}

func (srv *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {

	name := r.URL.Path[1:]
	if name == "" || strings.HasSuffix(name, "/") {
		name += "index"
	}

	if ext := path.Ext(name); ext == "" {
		fi, err := srv.fsys.Open(name + ".html")
		if err == nil {
			name += ".html"
			_ = fi.Close()
		} else {
			if !errors.Is(err, os.ErrNotExist) {
				http.Error(w, "Internal Server Error", 500)
				return
			}
			fi, err = srv.fsys.Open(name + ".md")
			if err != nil {
				if errors.Is(err, os.ErrNotExist) {
					http.NotFound(w, r)
				} else {
					http.Error(w, "Internal Server Error", 500)
				}
				return
			}
			name += ".md"
			_ = fi.Close()
		}
	} else if ext != ".html" && ext != ".md" {
		srv.static.ServeHTTP(w, r)
		return
	}

	var err error
	var buildTime time.Duration
	srv.Lock()
	template, ok := srv.templates[name]
	srv.Unlock()
	start := time.Now()
	if !ok {
		template, err = templates.Build(srv.fsys, name, srv.buildOptions)
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				http.NotFound(w, r)
				return
			}
			if err, ok := err.(scriggo.CompilerError); ok {
				w.Header().Set("Content-Type", "text/plain; charset=utf-8")
				w.WriteHeader(500)
				fmt.Fprintf(w, "%s", err)
				return
			}
			http.Error(w, "Internal Server Error", 500)
			srv.logf("%s", err)
			return
		}
		buildTime = time.Since(start)
		srv.Lock()
		srv.templates[name] = template
		srv.Unlock()
		start = time.Now()
	}
	b := bytes.Buffer{}
	vars := map[string]interface{}{"form": builtin.NewFormData(r, 10)}
	err = template.Run(&b, vars, srv.runOptions)
	if err != nil {
		switch err {
		case builtin.ErrBadRequest:
			http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
		case builtin.ErrRequestEntityTooLarge:
			http.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)
		default:
			http.Error(w, err.Error(), 500)
		}
		return
	}
	runTime := time.Since(start)

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	_, err = b.WriteTo(w)
	if err != nil {
		srv.logf("%s", err)
	}

	if srv.metrics.active {
		var header bool
		srv.Lock()
		header = srv.metrics.header
		srv.Unlock()
		if header {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "Build", "Run", "Total", "File")
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "-----", "---", "-----", "----")
			srv.Lock()
			srv.metrics.header = false
			srv.Unlock()
		}
		if buildTime == 0 {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", "-", runTime, buildTime+runTime, name)
		} else {
			fmt.Fprintf(os.Stderr, "     %12s  %12s  %12s  %s\n", buildTime, runTime, buildTime+runTime, name)
		}
	}

	if srv.asm >= -1 {
		asm := template.Disassemble(srv.asm)
		srv.logf("\n--- Assembler %s ---\n", name)
		_, _ = os.Stderr.Write(asm)
		srv.log("-----------------\n")
	}

	return
}

func (srv *server) log(a ...interface{}) {
	println()
	fmt.Fprint(os.Stderr, a...)
	println()
	srv.metrics.header = true
}

func (srv *server) logf(format string, a ...interface{}) {
	println()
	fmt.Fprintf(os.Stderr, format, a...)
	println()
	srv.metrics.header = true
}

// templateFS implements a file system that reads the files in a directory.
type templateFS struct {
	fsys    fs.FS
	watcher *fsnotify.Watcher
	watched map[string]bool
	Errors  chan error

	sync.Mutex
	Changed chan string
}

func newTemplateFS(root string) (*templateFS, error) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return nil, err
	}
	dir := &templateFS{
		fsys:    os.DirFS(root),
		watcher: watcher,
		watched: map[string]bool{},
		Changed: make(chan string),
	}
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}
				if event.Op&fsnotify.Write == fsnotify.Write {
					dir.Changed <- event.Name
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				dir.Errors <- err
			}
		}
	}()
	return dir, nil
}

func (t *templateFS) Open(name string) (fs.File, error) {
	err := t.watch(name)
	if err != nil {
		return nil, err
	}
	return t.fsys.Open(name)
}

func (t *templateFS) ReadFile(name string) ([]byte, error) {
	err := t.watch(name)
	if err != nil {
		return nil, err
	}
	return fs.ReadFile(t.fsys, name)
}

func (t *templateFS) Close() error {
	return t.watcher.Close()
}

func (t *templateFS) watch(name string) error {
	t.Lock()
	if !t.watched[name] {
		err := t.watcher.Add(name)
		if err != nil {
			t.Unlock()
			return err
		}
		t.watched[name] = true
	}
	t.Unlock()
	return nil
}

var globals = templates.Declarations{
	// crypto
	"hmacSHA1":   builtin.HmacSHA1,
	"hmacSHA256": builtin.HmacSHA256,
	"sha1":       builtin.Sha1,
	"sha256":     builtin.Sha256,

	// encoding
	"base64":            builtin.Base64,
	"hex":               builtin.Hex,
	"marshalJSON":       builtin.MarshalJSON,
	"marshalJSONIndent": builtin.MarshalJSONIndent,
	"md5":               builtin.Md5,
	"unmarshalJSON":     builtin.UnmarshalJSON,

	// html
	"htmlEscape": builtin.HtmlEscape,

	// math
	"abs": builtin.Abs,
	"max": builtin.Max,
	"min": builtin.Min,

	// net
	"File":        reflect.TypeOf((*builtin.File)(nil)).Elem(),
	"FormData":    reflect.TypeOf(builtin.FormData{}),
	"form":        (*builtin.FormData)(nil),
	"queryEscape": builtin.QueryEscape,

	// regexp
	"Regexp": reflect.TypeOf(builtin.Regexp{}),
	"regexp": builtin.RegExp,

	// sort
	"reverse": builtin.Reverse,
	"sort":    builtin.Sort,

	// strconv
	"formatFloat": builtin.FormatFloat,
	"formatInt":   builtin.FormatInt,
	"parseFloat":  builtin.ParseFloat,
	"parseInt":    builtin.ParseInt,

	// strings
	"abbreviate":    builtin.Abbreviate,
	"capitalize":    builtin.Capitalize,
	"capitalizeAll": builtin.CapitalizeAll,
	"hasPrefix":     builtin.HasPrefix,
	"hasSuffix":     builtin.HasSuffix,
	"index":         builtin.Index,
	"indexAny":      builtin.IndexAny,
	"join":          builtin.Join,
	"lastIndex":     builtin.LastIndex,
	"replace":       builtin.Replace,
	"replaceAll":    builtin.ReplaceAll,
	"runeCount":     builtin.RuneCount,
	"split":         builtin.Split,
	"splitAfter":    builtin.SplitAfter,
	"splitAfterN":   builtin.SplitAfterN,
	"splitN":        builtin.SplitN,
	"sprint":        builtin.Sprint,
	"sprintf":       builtin.Sprintf,
	"toKebab":       builtin.ToKebab,
	"toLower":       builtin.ToLower,
	"toUpper":       builtin.ToUpper,
	"trim":          builtin.Trim,
	"trimLeft":      builtin.TrimLeft,
	"trimPrefix":    builtin.TrimPrefix,
	"trimRight":     builtin.TrimRight,
	"trimSuffix":    builtin.TrimSuffix,

	// time
	"Duration":      reflect.TypeOf(builtin.Duration(0)),
	"Hour":          time.Hour,
	"Microsecond":   time.Microsecond,
	"Millisecond":   time.Millisecond,
	"Minute":        time.Minute,
	"Nanosecond":    time.Nanosecond,
	"Second":        time.Second,
	"Time":          reflect.TypeOf(builtin.Time{}),
	"date":          builtin.Date,
	"now":           builtin.Now,
	"parseDuration": builtin.ParseDuration,
	"parseTime":     builtin.ParseTime,
	"unixTime":      builtin.UnixTime,
}
`)
	sources["util.go"] = []byte(`// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type nopCloser struct {
	io.Writer
}

func (nopCloser) Close() error {
	return nil
}

func getOutputFlag(output string) (io.WriteCloser, error) {
	if output == "" {
		return nopCloser{os.Stdout}, nil
	}
	if output == os.DevNull {
		return nil, nil
	}
	dir, file := filepath.Split(output)
	if file == "" {
		exitError("%q cannot be a directory", output)
	}
	if dir != "" {
		err := os.MkdirAll(dir, 0777)
		if err != nil {
			return nil, err
		}
	}
	return os.OpenFile(output, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
}

// uncapitalize "uncapitalizes" n.
//
// 	Name        ->  name
//	DoubleWord  ->  doubleWord
//  AbC         ->  abC
//
func uncapitalize(n string) string {
	isUp := unicode.IsUpper
	toLow := unicode.ToLower
	if n == "" {
		return n
	}
	runes := []rune(n)
	if len(runes) == 1 {
		return string(toLow(runes[0]))
	}
	if !isUp(runes[0]) {
		return n
	}
	b := bytes.Buffer{}
	b.Grow(len(n))
	var i int
	b.WriteRune(toLow(runes[0]))
	for i = 1; i < len(runes)-1; i++ {
		if isUp(runes[i]) && isUp(runes[i+1]) {
			b.WriteRune(toLow(runes[i]))
		} else {
			break
		}
	}
	for ; i < len(runes)-1; i++ {
		b.WriteRune(runes[i])
	}
	if isUp(runes[i]) && isUp(runes[i-1]) {
		b.WriteRune(toLow(runes[i]))
	} else {
		b.WriteRune(runes[i])
	}
	return b.String()
}

var predeclaredIdentifier = []string{
	"bool", "byte", "complex64", "complex128", "error", "float32", "float64",
	"int", "int8", "int16", "int32", "int64", "rune", "string", "uint", "uint8",
	"uint16", "uint32", "uint64", "uintptr", "true", "false", "iota",
	"nil", "append", "cap", "close", "complex", "copy", "delete", "imag",
	"len", "make", "new", "panic", "print", "println", "real", "recover",
}

// isPredeclaredIdentifier reports whether name is a Go predeclared
// identifier.
func isPredeclaredIdentifier(name string) bool {
	for _, pred := range predeclaredIdentifier {
		if name == pred {
			return true
		}
	}
	return false
}

func txtToHelp(s string) {
	s = strings.TrimSpace(s)
	stderr(strings.Split(s, "\n")...)
}

var uniquePackageNameCache = map[string]string{}

var goKeywords = []string{
	"break", "case", "chan", "const", "continue", "default", "defer", "else",
	"fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map",
	"package", "range", "return", "struct", "select", "switch", "type", "var",
}

// isGoKeyword reports whether a string is a Go keyword.
func isGoKeyword(s string) bool {
	for _, k := range goKeywords {
		if s == k {
			return true
		}
	}
	return false
}

// uniquePackageName generates an unique package name for every package path.
func uniquePackageName(pkgPath string) string {

	pkgName := filepath.Base(pkgPath)
	done := false
	for !done {
		done = true
		cachePath, ok := uniquePackageNameCache[pkgName]
		if ok && cachePath != pkgPath {
			done = false
			pkgName += "_"
		}
	}
	if isGoKeyword(pkgName) {
		pkgName = "_" + pkgName + "_"
	}
	uniquePackageNameCache[pkgName] = pkgPath

	return pkgName
}

// goBaseVersion returns the go base version for v.
//
//		1.15.5 -> 1.15
//
func goBaseVersion(v string) string {
	// When updating, also update test/compare/run.go.
	if strings.HasPrefix(v, "devel ") {
		v = v[len("devel "):]
		if i := strings.Index(v, "-"); i >= 0 {
			v = v[:i]
		}
	}
	if i := strings.Index(v, "beta"); i >= 0 {
		v = v[:i]
	}
	if i := strings.Index(v, "rc"); i >= 0 {
		v = v[:i]
	}
	v = v[4:]
	f, err := strconv.ParseFloat(v, 32)
	if err != nil {
		panic(err)
	}
	f = math.Floor(f)
	next := int(f)
	return fmt.Sprintf("go1.%d", next)
}

// hasStdlibPrefix reports whether the prefix of path conflicts with the path of
// a package of the Go standard library.
func hasStdlibPrefix(path string) bool {
	stdlibPrefixes := []string{
		"archive", "bufio", "bytes", "compress", "container",
		"context", "crypto", "database", "debug", "embed", "encoding",
		"errors", "expvar", "flag", "fmt", "go", "hash", "html", "image",
		"index", "io", "log", "math", "mime", "net", "os",
		"path", "plugin", "reflect", "regexp", "runtime", "sort",
		"strconv", "strings", "sync", "syscall", "testing", "text",
		"time", "unicode", "unsafe",
	}
	first := strings.Split(path, "/")[0]
	for _, pref := range stdlibPrefixes {
		if pref == first {
			return true
		}
	}
	return false
}

// nextGoVersion returns the successive go version of v.
//
//		1.15.5 -> 1.16
//
func nextGoVersion(v string) string {
	v = goBaseVersion(v)[4:]
	f, err := strconv.ParseFloat(v, 32)
	if err != nil {
		panic(err)
	}
	f = math.Floor(f)
	next := int(f) + 1
	return fmt.Sprintf("go1.%d", next)
}

// checkIdentifierName checks that name is a valid not blank identifier name.
func checkIdentifierName(name string) error {
	if name == "_" {
		return fmt.Errorf("cannot use the blank identifier")
	}
	if isGoKeyword(name) {
		return fmt.Errorf("invalid variable name")
	}
	first := true
	for _, r := range name {
		if !unicode.IsLetter(r) && (first || !unicode.IsDigit(r)) {
			return fmt.Errorf("invalid identifier name")
		}
		first = false
	}
	return nil
}

// checkGOOS checks that os is a valid GOOS value.
func checkGOOS(os string) error {
	switch os {
	case "darwin", "dragonfly", "js", "linux", "android", "solaris",
		"freebsd", "nacl", "netbsd", "openbsd", "plan9", "windows", "aix":
		return nil
	}
	return fmt.Errorf("unkown os %q", os)
}

// checkPackagePath checks that a given package path is valid.
//
// This function must be in sync with the function validPackagePath in the
// file "scriggo/compiler/path".
func checkPackagePath(path string) error {
	if path == "main" {
		return nil
	}
	for _, r := range path {
		if !unicode.In(r, unicode.L, unicode.M, unicode.N, unicode.P, unicode.S) {
			return fmt.Errorf("invalid path path %q", path)
		}
		switch r {
		case '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', ':', ';', '<',
			'=', '>', '?', '[', '\\', ']', '^', '` + "`" + `', '{', '|', '}', '\uFFFD':
			return fmt.Errorf("invalid path path %q", path)
		}
	}
	if ss := strings.Split(path, "/"); len(ss) > 0 && ss[0] == "internal" {
		return fmt.Errorf("use of internal package %q not allowed", path)
	}
	if cleaned := cleanPath(path); path != cleaned {
		return fmt.Errorf("invalid path path %q", path)
	}
	return nil
}

// checkExportedName checks that name is a valid exported identifier name.
func checkExportedName(name string) error {
	err := checkIdentifierName(name)
	if err != nil {
		return err
	}
	if fc, _ := utf8.DecodeRuneInString(name); !unicode.Is(unicode.Lu, fc) {
		return fmt.Errorf("cannot refer to unexported name %s", name)
	}
	return nil
}

// cleanPath cleans a path and returns the path in its canonical form.
// path must be already a valid path.
//
// This function must be in sync with the function cleanPath in the file
// "scriggo/compiler/path".
func cleanPath(path string) string {
	if !strings.Contains(path, "..") {
		return path
	}
	var b = []byte(path)
	for i := 0; i < len(b); i++ {
		if b[i] == '/' {
			if b[i+1] == '.' && b[i+2] == '.' {
				s := bytes.LastIndexByte(b[:i], '/')
				b = append(b[:s+1], b[i+4:]...)
				i = s - 1
			}
		}
	}
	return string(b)
}
`)
}
