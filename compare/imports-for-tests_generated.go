// Code generated by scrigo-generate, based on file "imports-for-tests.go". DO NOT EDIT.

package main

import (
	bufio "bufio"
	bytes "bytes"
	sha1 "crypto/sha1"
	base64 "encoding/base64"
	fmt "fmt"
	ioutil "io/ioutil"
	math "math"
	rand "math/rand"
	net "net"
	url "net/url"
	os "os"
	"reflect"
	regexp "regexp"
	"scrigo/internal/compiler"
	sort "sort"
	strconv "strconv"
	strings "strings"
	time "time"
)

func init() {
	packages = map[string]*compiler.GoPackage{

		"bufio": &compiler.GoPackage{
			Name: "bufio",
			Declarations: map[string]interface{}{
				"ErrAdvanceTooFar":     &bufio.ErrAdvanceTooFar,
				"ErrBufferFull":        &bufio.ErrBufferFull,
				"ErrFinalToken":        &bufio.ErrFinalToken,
				"ErrInvalidUnreadByte": &bufio.ErrInvalidUnreadByte,
				"ErrInvalidUnreadRune": &bufio.ErrInvalidUnreadRune,
				"ErrNegativeAdvance":   &bufio.ErrNegativeAdvance,
				"ErrNegativeCount":     &bufio.ErrNegativeCount,
				"ErrTooLong":           &bufio.ErrTooLong,
				"NewReadWriter":        bufio.NewReadWriter,
				"NewReader":            bufio.NewReader,
				"NewReaderSize":        bufio.NewReaderSize,
				"NewScanner":           bufio.NewScanner,
				"NewWriter":            bufio.NewWriter,
				"NewWriterSize":        bufio.NewWriterSize,
				"ReadWriter":           reflect.TypeOf(new(bufio.ReadWriter)).Elem(),
				"Reader":               reflect.TypeOf(new(bufio.Reader)).Elem(),
				"ScanBytes":            bufio.ScanBytes,
				"ScanLines":            bufio.ScanLines,
				"ScanRunes":            bufio.ScanRunes,
				"ScanWords":            bufio.ScanWords,
				"Scanner":              reflect.TypeOf(new(bufio.Scanner)).Elem(),
				"SplitFunc":            reflect.TypeOf(new(bufio.SplitFunc)).Elem(),
				"Writer":               reflect.TypeOf(new(bufio.Writer)).Elem(),
			},
		},
		"bytes": &compiler.GoPackage{
			Name: "bytes",
			Declarations: map[string]interface{}{
				"Buffer":          reflect.TypeOf(new(bytes.Buffer)).Elem(),
				"Compare":         bytes.Compare,
				"Contains":        bytes.Contains,
				"ContainsAny":     bytes.ContainsAny,
				"ContainsRune":    bytes.ContainsRune,
				"Count":           bytes.Count,
				"Equal":           bytes.Equal,
				"EqualFold":       bytes.EqualFold,
				"ErrTooLarge":     &bytes.ErrTooLarge,
				"Fields":          bytes.Fields,
				"FieldsFunc":      bytes.FieldsFunc,
				"HasPrefix":       bytes.HasPrefix,
				"HasSuffix":       bytes.HasSuffix,
				"Index":           bytes.Index,
				"IndexAny":        bytes.IndexAny,
				"IndexByte":       bytes.IndexByte,
				"IndexFunc":       bytes.IndexFunc,
				"IndexRune":       bytes.IndexRune,
				"Join":            bytes.Join,
				"LastIndex":       bytes.LastIndex,
				"LastIndexAny":    bytes.LastIndexAny,
				"LastIndexByte":   bytes.LastIndexByte,
				"LastIndexFunc":   bytes.LastIndexFunc,
				"Map":             bytes.Map,
				"NewBuffer":       bytes.NewBuffer,
				"NewBufferString": bytes.NewBufferString,
				"NewReader":       bytes.NewReader,
				"Reader":          reflect.TypeOf(new(bytes.Reader)).Elem(),
				"Repeat":          bytes.Repeat,
				"Replace":         bytes.Replace,
				"ReplaceAll":      bytes.ReplaceAll,
				"Runes":           bytes.Runes,
				"Split":           bytes.Split,
				"SplitAfter":      bytes.SplitAfter,
				"SplitAfterN":     bytes.SplitAfterN,
				"SplitN":          bytes.SplitN,
				"Title":           bytes.Title,
				"ToLower":         bytes.ToLower,
				"ToLowerSpecial":  bytes.ToLowerSpecial,
				"ToTitle":         bytes.ToTitle,
				"ToTitleSpecial":  bytes.ToTitleSpecial,
				"ToUpper":         bytes.ToUpper,
				"ToUpperSpecial":  bytes.ToUpperSpecial,
				"Trim":            bytes.Trim,
				"TrimFunc":        bytes.TrimFunc,
				"TrimLeft":        bytes.TrimLeft,
				"TrimLeftFunc":    bytes.TrimLeftFunc,
				"TrimPrefix":      bytes.TrimPrefix,
				"TrimRight":       bytes.TrimRight,
				"TrimRightFunc":   bytes.TrimRightFunc,
				"TrimSpace":       bytes.TrimSpace,
				"TrimSuffix":      bytes.TrimSuffix,
			},
		},
		"crypto/sha1": &compiler.GoPackage{
			Name: "sha1",
			Declarations: map[string]interface{}{
				"New": sha1.New,
				"Sum": sha1.Sum,
			},
		},
		"encoding/base64": &compiler.GoPackage{
			Name: "base64",
			Declarations: map[string]interface{}{
				"CorruptInputError": reflect.TypeOf(new(base64.CorruptInputError)).Elem(),
				"Encoding":          reflect.TypeOf(new(base64.Encoding)).Elem(),
				"NewDecoder":        base64.NewDecoder,
				"NewEncoder":        base64.NewEncoder,
				"NewEncoding":       base64.NewEncoding,
				"RawStdEncoding":    &base64.RawStdEncoding,
				"RawURLEncoding":    &base64.RawURLEncoding,
				"StdEncoding":       &base64.StdEncoding,
				"URLEncoding":       &base64.URLEncoding,
			},
		},
		"fmt": &compiler.GoPackage{
			Name: "fmt",
			Declarations: map[string]interface{}{
				"Errorf":     fmt.Errorf,
				"Formatter":  reflect.TypeOf(new(fmt.Formatter)).Elem(),
				"Fprint":     fmt.Fprint,
				"Fprintf":    fmt.Fprintf,
				"Fprintln":   fmt.Fprintln,
				"Fscan":      fmt.Fscan,
				"Fscanf":     fmt.Fscanf,
				"Fscanln":    fmt.Fscanln,
				"GoStringer": reflect.TypeOf(new(fmt.GoStringer)).Elem(),
				"Print":      fmt.Print,
				"Printf":     fmt.Printf,
				"Println":    fmt.Println,
				"Scan":       fmt.Scan,
				"ScanState":  reflect.TypeOf(new(fmt.ScanState)).Elem(),
				"Scanf":      fmt.Scanf,
				"Scanln":     fmt.Scanln,
				"Scanner":    reflect.TypeOf(new(fmt.Scanner)).Elem(),
				"Sprint":     fmt.Sprint,
				"Sprintf":    fmt.Sprintf,
				"Sprintln":   fmt.Sprintln,
				"Sscan":      fmt.Sscan,
				"Sscanf":     fmt.Sscanf,
				"Sscanln":    fmt.Sscanln,
				"State":      reflect.TypeOf(new(fmt.State)).Elem(),
				"Stringer":   reflect.TypeOf(new(fmt.Stringer)).Elem(),
			},
		},
		"io/ioutil": &compiler.GoPackage{
			Name: "ioutil",
			Declarations: map[string]interface{}{
				"Discard":   &ioutil.Discard,
				"NopCloser": ioutil.NopCloser,
				"ReadAll":   ioutil.ReadAll,
				"ReadDir":   ioutil.ReadDir,
				"ReadFile":  ioutil.ReadFile,
				"TempDir":   ioutil.TempDir,
				"TempFile":  ioutil.TempFile,
				"WriteFile": ioutil.WriteFile,
			},
		},
		"math": &compiler.GoPackage{
			Name: "math",
			Declarations: map[string]interface{}{
				"Abs":             math.Abs,
				"Acos":            math.Acos,
				"Acosh":           math.Acosh,
				"Asin":            math.Asin,
				"Asinh":           math.Asinh,
				"Atan":            math.Atan,
				"Atan2":           math.Atan2,
				"Atanh":           math.Atanh,
				"Cbrt":            math.Cbrt,
				"Ceil":            math.Ceil,
				"Copysign":        math.Copysign,
				"Cos":             math.Cos,
				"Cosh":            math.Cosh,
				"Dim":             math.Dim,
				"Erf":             math.Erf,
				"Erfc":            math.Erfc,
				"Erfcinv":         math.Erfcinv,
				"Erfinv":          math.Erfinv,
				"Exp":             math.Exp,
				"Exp2":            math.Exp2,
				"Expm1":           math.Expm1,
				"Float32bits":     math.Float32bits,
				"Float32frombits": math.Float32frombits,
				"Float64bits":     math.Float64bits,
				"Float64frombits": math.Float64frombits,
				"Floor":           math.Floor,
				"Frexp":           math.Frexp,
				"Gamma":           math.Gamma,
				"Hypot":           math.Hypot,
				"Ilogb":           math.Ilogb,
				"Inf":             math.Inf,
				"IsInf":           math.IsInf,
				"IsNaN":           math.IsNaN,
				"J0":              math.J0,
				"J1":              math.J1,
				"Jn":              math.Jn,
				"Ldexp":           math.Ldexp,
				"Lgamma":          math.Lgamma,
				"Log":             math.Log,
				"Log10":           math.Log10,
				"Log1p":           math.Log1p,
				"Log2":            math.Log2,
				"Logb":            math.Logb,
				"Max":             math.Max,
				"Min":             math.Min,
				"Mod":             math.Mod,
				"Modf":            math.Modf,
				"NaN":             math.NaN,
				"Nextafter":       math.Nextafter,
				"Nextafter32":     math.Nextafter32,
				"Pow":             math.Pow,
				"Pow10":           math.Pow10,
				"Remainder":       math.Remainder,
				"Round":           math.Round,
				"RoundToEven":     math.RoundToEven,
				"Signbit":         math.Signbit,
				"Sin":             math.Sin,
				"Sincos":          math.Sincos,
				"Sinh":            math.Sinh,
				"Sqrt":            math.Sqrt,
				"Tan":             math.Tan,
				"Tanh":            math.Tanh,
				"Trunc":           math.Trunc,
				"Y0":              math.Y0,
				"Y1":              math.Y1,
				"Yn":              math.Yn,
			},
		},
		"math/rand": &compiler.GoPackage{
			Name: "rand",
			Declarations: map[string]interface{}{
				"ExpFloat64":  rand.ExpFloat64,
				"Float32":     rand.Float32,
				"Float64":     rand.Float64,
				"Int":         rand.Int,
				"Int31":       rand.Int31,
				"Int31n":      rand.Int31n,
				"Int63":       rand.Int63,
				"Int63n":      rand.Int63n,
				"Intn":        rand.Intn,
				"New":         rand.New,
				"NewSource":   rand.NewSource,
				"NewZipf":     rand.NewZipf,
				"NormFloat64": rand.NormFloat64,
				"Perm":        rand.Perm,
				"Rand":        reflect.TypeOf(new(rand.Rand)).Elem(),
				"Read":        rand.Read,
				"Seed":        rand.Seed,
				"Shuffle":     rand.Shuffle,
				"Source":      reflect.TypeOf(new(rand.Source)).Elem(),
				"Source64":    reflect.TypeOf(new(rand.Source64)).Elem(),
				"Uint32":      rand.Uint32,
				"Uint64":      rand.Uint64,
				"Zipf":        reflect.TypeOf(new(rand.Zipf)).Elem(),
			},
		},
		"net": &compiler.GoPackage{
			Name: "net",
			Declarations: map[string]interface{}{
				"Addr":                       reflect.TypeOf(new(net.Addr)).Elem(),
				"AddrError":                  reflect.TypeOf(new(net.AddrError)).Elem(),
				"Buffers":                    reflect.TypeOf(new(net.Buffers)).Elem(),
				"CIDRMask":                   net.CIDRMask,
				"Conn":                       reflect.TypeOf(new(net.Conn)).Elem(),
				"DNSConfigError":             reflect.TypeOf(new(net.DNSConfigError)).Elem(),
				"DNSError":                   reflect.TypeOf(new(net.DNSError)).Elem(),
				"DefaultResolver":            &net.DefaultResolver,
				"Dial":                       net.Dial,
				"DialIP":                     net.DialIP,
				"DialTCP":                    net.DialTCP,
				"DialTimeout":                net.DialTimeout,
				"DialUDP":                    net.DialUDP,
				"DialUnix":                   net.DialUnix,
				"Dialer":                     reflect.TypeOf(new(net.Dialer)).Elem(),
				"ErrWriteToConnected":        &net.ErrWriteToConnected,
				"Error":                      reflect.TypeOf(new(net.Error)).Elem(),
				"FileConn":                   net.FileConn,
				"FileListener":               net.FileListener,
				"FilePacketConn":             net.FilePacketConn,
				"Flags":                      reflect.TypeOf(new(net.Flags)).Elem(),
				"HardwareAddr":               reflect.TypeOf(new(net.HardwareAddr)).Elem(),
				"IP":                         reflect.TypeOf(new(net.IP)).Elem(),
				"IPAddr":                     reflect.TypeOf(new(net.IPAddr)).Elem(),
				"IPConn":                     reflect.TypeOf(new(net.IPConn)).Elem(),
				"IPMask":                     reflect.TypeOf(new(net.IPMask)).Elem(),
				"IPNet":                      reflect.TypeOf(new(net.IPNet)).Elem(),
				"IPv4":                       net.IPv4,
				"IPv4Mask":                   net.IPv4Mask,
				"IPv4allrouter":              &net.IPv4allrouter,
				"IPv4allsys":                 &net.IPv4allsys,
				"IPv4bcast":                  &net.IPv4bcast,
				"IPv4zero":                   &net.IPv4zero,
				"IPv6interfacelocalallnodes": &net.IPv6interfacelocalallnodes,
				"IPv6linklocalallnodes":      &net.IPv6linklocalallnodes,
				"IPv6linklocalallrouters":    &net.IPv6linklocalallrouters,
				"IPv6loopback":               &net.IPv6loopback,
				"IPv6unspecified":            &net.IPv6unspecified,
				"IPv6zero":                   &net.IPv6zero,
				"Interface":                  reflect.TypeOf(new(net.Interface)).Elem(),
				"InterfaceAddrs":             net.InterfaceAddrs,
				"InterfaceByIndex":           net.InterfaceByIndex,
				"InterfaceByName":            net.InterfaceByName,
				"Interfaces":                 net.Interfaces,
				"InvalidAddrError":           reflect.TypeOf(new(net.InvalidAddrError)).Elem(),
				"JoinHostPort":               net.JoinHostPort,
				"Listen":                     net.Listen,
				"ListenConfig":               reflect.TypeOf(new(net.ListenConfig)).Elem(),
				"ListenIP":                   net.ListenIP,
				"ListenMulticastUDP":         net.ListenMulticastUDP,
				"ListenPacket":               net.ListenPacket,
				"ListenTCP":                  net.ListenTCP,
				"ListenUDP":                  net.ListenUDP,
				"ListenUnix":                 net.ListenUnix,
				"ListenUnixgram":             net.ListenUnixgram,
				"Listener":                   reflect.TypeOf(new(net.Listener)).Elem(),
				"LookupAddr":                 net.LookupAddr,
				"LookupCNAME":                net.LookupCNAME,
				"LookupHost":                 net.LookupHost,
				"LookupIP":                   net.LookupIP,
				"LookupMX":                   net.LookupMX,
				"LookupNS":                   net.LookupNS,
				"LookupPort":                 net.LookupPort,
				"LookupSRV":                  net.LookupSRV,
				"LookupTXT":                  net.LookupTXT,
				"MX":                         reflect.TypeOf(new(net.MX)).Elem(),
				"NS":                         reflect.TypeOf(new(net.NS)).Elem(),
				"OpError":                    reflect.TypeOf(new(net.OpError)).Elem(),
				"PacketConn":                 reflect.TypeOf(new(net.PacketConn)).Elem(),
				"ParseCIDR":                  net.ParseCIDR,
				"ParseError":                 reflect.TypeOf(new(net.ParseError)).Elem(),
				"ParseIP":                    net.ParseIP,
				"ParseMAC":                   net.ParseMAC,
				"Pipe":                       net.Pipe,
				"ResolveIPAddr":              net.ResolveIPAddr,
				"ResolveTCPAddr":             net.ResolveTCPAddr,
				"ResolveUDPAddr":             net.ResolveUDPAddr,
				"ResolveUnixAddr":            net.ResolveUnixAddr,
				"Resolver":                   reflect.TypeOf(new(net.Resolver)).Elem(),
				"SRV":                        reflect.TypeOf(new(net.SRV)).Elem(),
				"SplitHostPort":              net.SplitHostPort,
				"TCPAddr":                    reflect.TypeOf(new(net.TCPAddr)).Elem(),
				"TCPConn":                    reflect.TypeOf(new(net.TCPConn)).Elem(),
				"TCPListener":                reflect.TypeOf(new(net.TCPListener)).Elem(),
				"UDPAddr":                    reflect.TypeOf(new(net.UDPAddr)).Elem(),
				"UDPConn":                    reflect.TypeOf(new(net.UDPConn)).Elem(),
				"UnixAddr":                   reflect.TypeOf(new(net.UnixAddr)).Elem(),
				"UnixConn":                   reflect.TypeOf(new(net.UnixConn)).Elem(),
				"UnixListener":               reflect.TypeOf(new(net.UnixListener)).Elem(),
				"UnknownNetworkError":        reflect.TypeOf(new(net.UnknownNetworkError)).Elem(),
			},
		},
		"net/url": &compiler.GoPackage{
			Name: "url",
			Declarations: map[string]interface{}{
				"Error":            reflect.TypeOf(new(url.Error)).Elem(),
				"EscapeError":      reflect.TypeOf(new(url.EscapeError)).Elem(),
				"InvalidHostError": reflect.TypeOf(new(url.InvalidHostError)).Elem(),
				"Parse":            url.Parse,
				"ParseQuery":       url.ParseQuery,
				"ParseRequestURI":  url.ParseRequestURI,
				"PathEscape":       url.PathEscape,
				"PathUnescape":     url.PathUnescape,
				"QueryEscape":      url.QueryEscape,
				"QueryUnescape":    url.QueryUnescape,
				"URL":              reflect.TypeOf(new(url.URL)).Elem(),
				"User":             url.User,
				"UserPassword":     url.UserPassword,
				"Userinfo":         reflect.TypeOf(new(url.Userinfo)).Elem(),
				"Values":           reflect.TypeOf(new(url.Values)).Elem(),
			},
		},
		"os": &compiler.GoPackage{
			Name: "os",
			Declarations: map[string]interface{}{
				"Chdir":           os.Chdir,
				"Chmod":           os.Chmod,
				"Chown":           os.Chown,
				"Chtimes":         os.Chtimes,
				"Clearenv":        os.Clearenv,
				"Create":          os.Create,
				"Environ":         os.Environ,
				"ErrClosed":       &os.ErrClosed,
				"ErrExist":        &os.ErrExist,
				"ErrInvalid":      &os.ErrInvalid,
				"ErrNoDeadline":   &os.ErrNoDeadline,
				"ErrNotExist":     &os.ErrNotExist,
				"ErrPermission":   &os.ErrPermission,
				"Executable":      os.Executable,
				"Exit":            os.Exit,
				"Expand":          os.Expand,
				"ExpandEnv":       os.ExpandEnv,
				"File":            reflect.TypeOf(new(os.File)).Elem(),
				"FileInfo":        reflect.TypeOf(new(os.FileInfo)).Elem(),
				"FileMode":        reflect.TypeOf(new(os.FileMode)).Elem(),
				"FindProcess":     os.FindProcess,
				"Getegid":         os.Getegid,
				"Getenv":          os.Getenv,
				"Geteuid":         os.Geteuid,
				"Getgid":          os.Getgid,
				"Getgroups":       os.Getgroups,
				"Getpagesize":     os.Getpagesize,
				"Getpid":          os.Getpid,
				"Getppid":         os.Getppid,
				"Getuid":          os.Getuid,
				"Getwd":           os.Getwd,
				"Hostname":        os.Hostname,
				"Interrupt":       &os.Interrupt,
				"IsExist":         os.IsExist,
				"IsNotExist":      os.IsNotExist,
				"IsPathSeparator": os.IsPathSeparator,
				"IsPermission":    os.IsPermission,
				"IsTimeout":       os.IsTimeout,
				"Kill":            &os.Kill,
				"Lchown":          os.Lchown,
				"Link":            os.Link,
				"LinkError":       reflect.TypeOf(new(os.LinkError)).Elem(),
				"LookupEnv":       os.LookupEnv,
				"Lstat":           os.Lstat,
				"Mkdir":           os.Mkdir,
				"MkdirAll":        os.MkdirAll,
				"NewFile":         os.NewFile,
				"NewSyscallError": os.NewSyscallError,
				"Open":            os.Open,
				"OpenFile":        os.OpenFile,
				"PathError":       reflect.TypeOf(new(os.PathError)).Elem(),
				"Pipe":            os.Pipe,
				"ProcAttr":        reflect.TypeOf(new(os.ProcAttr)).Elem(),
				"Process":         reflect.TypeOf(new(os.Process)).Elem(),
				"ProcessState":    reflect.TypeOf(new(os.ProcessState)).Elem(),
				"Readlink":        os.Readlink,
				"Remove":          os.Remove,
				"RemoveAll":       os.RemoveAll,
				"Rename":          os.Rename,
				"SameFile":        os.SameFile,
				"Setenv":          os.Setenv,
				"Signal":          reflect.TypeOf(new(os.Signal)).Elem(),
				"StartProcess":    os.StartProcess,
				"Stat":            os.Stat,
				"Stderr":          &os.Stderr,
				"Stdin":           &os.Stdin,
				"Stdout":          &os.Stdout,
				"Symlink":         os.Symlink,
				"SyscallError":    reflect.TypeOf(new(os.SyscallError)).Elem(),
				"TempDir":         os.TempDir,
				"Truncate":        os.Truncate,
				"Unsetenv":        os.Unsetenv,
				"UserCacheDir":    os.UserCacheDir,
				"UserHomeDir":     os.UserHomeDir,
			},
		},
		"regexp": &compiler.GoPackage{
			Name: "regexp",
			Declarations: map[string]interface{}{
				"Compile":          regexp.Compile,
				"CompilePOSIX":     regexp.CompilePOSIX,
				"Match":            regexp.Match,
				"MatchReader":      regexp.MatchReader,
				"MatchString":      regexp.MatchString,
				"MustCompile":      regexp.MustCompile,
				"MustCompilePOSIX": regexp.MustCompilePOSIX,
				"QuoteMeta":        regexp.QuoteMeta,
				"Regexp":           reflect.TypeOf(new(regexp.Regexp)).Elem(),
			},
		},
		"sort": &compiler.GoPackage{
			Name: "sort",
			Declarations: map[string]interface{}{
				"Float64Slice":      reflect.TypeOf(new(sort.Float64Slice)).Elem(),
				"Float64s":          sort.Float64s,
				"Float64sAreSorted": sort.Float64sAreSorted,
				"IntSlice":          reflect.TypeOf(new(sort.IntSlice)).Elem(),
				"Interface":         reflect.TypeOf(new(sort.Interface)).Elem(),
				"Ints":              sort.Ints,
				"IntsAreSorted":     sort.IntsAreSorted,
				"IsSorted":          sort.IsSorted,
				"Reverse":           sort.Reverse,
				"Search":            sort.Search,
				"SearchFloat64s":    sort.SearchFloat64s,
				"SearchInts":        sort.SearchInts,
				"SearchStrings":     sort.SearchStrings,
				"Slice":             sort.Slice,
				"SliceIsSorted":     sort.SliceIsSorted,
				"SliceStable":       sort.SliceStable,
				"Sort":              sort.Sort,
				"Stable":            sort.Stable,
				"StringSlice":       reflect.TypeOf(new(sort.StringSlice)).Elem(),
				"Strings":           sort.Strings,
				"StringsAreSorted":  sort.StringsAreSorted,
			},
		},
		"strconv": &compiler.GoPackage{
			Name: "strconv",
			Declarations: map[string]interface{}{
				"AppendBool":               strconv.AppendBool,
				"AppendFloat":              strconv.AppendFloat,
				"AppendInt":                strconv.AppendInt,
				"AppendQuote":              strconv.AppendQuote,
				"AppendQuoteRune":          strconv.AppendQuoteRune,
				"AppendQuoteRuneToASCII":   strconv.AppendQuoteRuneToASCII,
				"AppendQuoteRuneToGraphic": strconv.AppendQuoteRuneToGraphic,
				"AppendQuoteToASCII":       strconv.AppendQuoteToASCII,
				"AppendQuoteToGraphic":     strconv.AppendQuoteToGraphic,
				"AppendUint":               strconv.AppendUint,
				"Atoi":                     strconv.Atoi,
				"CanBackquote":             strconv.CanBackquote,
				"ErrRange":                 &strconv.ErrRange,
				"ErrSyntax":                &strconv.ErrSyntax,
				"FormatBool":               strconv.FormatBool,
				"FormatFloat":              strconv.FormatFloat,
				"FormatInt":                strconv.FormatInt,
				"FormatUint":               strconv.FormatUint,
				"IsGraphic":                strconv.IsGraphic,
				"IsPrint":                  strconv.IsPrint,
				"Itoa":                     strconv.Itoa,
				"NumError":                 reflect.TypeOf(new(strconv.NumError)).Elem(),
				"ParseBool":                strconv.ParseBool,
				"ParseFloat":               strconv.ParseFloat,
				"ParseInt":                 strconv.ParseInt,
				"ParseUint":                strconv.ParseUint,
				"Quote":                    strconv.Quote,
				"QuoteRune":                strconv.QuoteRune,
				"QuoteRuneToASCII":         strconv.QuoteRuneToASCII,
				"QuoteRuneToGraphic":       strconv.QuoteRuneToGraphic,
				"QuoteToASCII":             strconv.QuoteToASCII,
				"QuoteToGraphic":           strconv.QuoteToGraphic,
				"Unquote":                  strconv.Unquote,
				"UnquoteChar":              strconv.UnquoteChar,
			},
		},
		"strings": &compiler.GoPackage{
			Name: "strings",
			Declarations: map[string]interface{}{
				"Builder":        reflect.TypeOf(new(strings.Builder)).Elem(),
				"Compare":        strings.Compare,
				"Contains":       strings.Contains,
				"ContainsAny":    strings.ContainsAny,
				"ContainsRune":   strings.ContainsRune,
				"Count":          strings.Count,
				"EqualFold":      strings.EqualFold,
				"Fields":         strings.Fields,
				"FieldsFunc":     strings.FieldsFunc,
				"HasPrefix":      strings.HasPrefix,
				"HasSuffix":      strings.HasSuffix,
				"Index":          strings.Index,
				"IndexAny":       strings.IndexAny,
				"IndexByte":      strings.IndexByte,
				"IndexFunc":      strings.IndexFunc,
				"IndexRune":      strings.IndexRune,
				"Join":           strings.Join,
				"LastIndex":      strings.LastIndex,
				"LastIndexAny":   strings.LastIndexAny,
				"LastIndexByte":  strings.LastIndexByte,
				"LastIndexFunc":  strings.LastIndexFunc,
				"Map":            strings.Map,
				"NewReader":      strings.NewReader,
				"NewReplacer":    strings.NewReplacer,
				"Reader":         reflect.TypeOf(new(strings.Reader)).Elem(),
				"Repeat":         strings.Repeat,
				"Replace":        strings.Replace,
				"ReplaceAll":     strings.ReplaceAll,
				"Replacer":       reflect.TypeOf(new(strings.Replacer)).Elem(),
				"Split":          strings.Split,
				"SplitAfter":     strings.SplitAfter,
				"SplitAfterN":    strings.SplitAfterN,
				"SplitN":         strings.SplitN,
				"Title":          strings.Title,
				"ToLower":        strings.ToLower,
				"ToLowerSpecial": strings.ToLowerSpecial,
				"ToTitle":        strings.ToTitle,
				"ToTitleSpecial": strings.ToTitleSpecial,
				"ToUpper":        strings.ToUpper,
				"ToUpperSpecial": strings.ToUpperSpecial,
				"Trim":           strings.Trim,
				"TrimFunc":       strings.TrimFunc,
				"TrimLeft":       strings.TrimLeft,
				"TrimLeftFunc":   strings.TrimLeftFunc,
				"TrimPrefix":     strings.TrimPrefix,
				"TrimRight":      strings.TrimRight,
				"TrimRightFunc":  strings.TrimRightFunc,
				"TrimSpace":      strings.TrimSpace,
				"TrimSuffix":     strings.TrimSuffix,
			},
		},
		"time": &compiler.GoPackage{
			Name: "time",
			Declarations: map[string]interface{}{
				"After":                  time.After,
				"AfterFunc":              time.AfterFunc,
				"Date":                   time.Date,
				"Duration":               reflect.TypeOf(new(time.Duration)).Elem(),
				"FixedZone":              time.FixedZone,
				"LoadLocation":           time.LoadLocation,
				"LoadLocationFromTZData": time.LoadLocationFromTZData,
				"Local":                  &time.Local,
				"Location":               reflect.TypeOf(new(time.Location)).Elem(),
				"Month":                  reflect.TypeOf(new(time.Month)).Elem(),
				"NewTicker":              time.NewTicker,
				"NewTimer":               time.NewTimer,
				"Now":                    time.Now,
				"Parse":                  time.Parse,
				"ParseDuration":          time.ParseDuration,
				"ParseError":             reflect.TypeOf(new(time.ParseError)).Elem(),
				"ParseInLocation":        time.ParseInLocation,
				"Since":                  time.Since,
				"Sleep":                  time.Sleep,
				"Tick":                   time.Tick,
				"Ticker":                 reflect.TypeOf(new(time.Ticker)).Elem(),
				"Time":                   reflect.TypeOf(new(time.Time)).Elem(),
				"Timer":                  reflect.TypeOf(new(time.Timer)).Elem(),
				"UTC":                    &time.UTC,
				"Unix":                   time.Unix,
				"Until":                  time.Until,
				"Weekday":                reflect.TypeOf(new(time.Weekday)).Elem(),
			},
		},
	}
}
