package main

import (
	"fmt"
	"go/importer"
	"os"
	"runtime"
	"strings"
	"unicode"
)

func mapEntry(key, value string) string {
	return fmt.Sprintf("\t\"%s\": %s,\n", key, value)
}

func isExported(name string) bool {
	return unicode.Is(unicode.Lu, []rune(name)[0])
}

// needsToBeGenerated checks if pkg needs to be generated.
//
// TODO (Gianluca): since imports list can be created manually, this function
// should be obsolete?
func needsToBeGenerated(pkg string) bool {
	if strings.TrimSpace(pkg) == "" {
		return false
	}
	if pkg == "log/syslog" && runtime.GOOS == "windows" {
		return false
	}
	if pkg == "runtime/race" || pkg == "runtime" {
		return false
	}
	parts := strings.Split(pkg, "/")
	if len(parts) > 0 {
		switch parts[0] {
		case "database", "cmd", "builtin", "debug", "plugin", "testing", "reflect", "unsafe", "syscall":
			return false
		}
		if parts[len(parts)-1] == "cgo" {
			return false
		}
		for _, p := range parts {
			if p == "internal" {
				return false
			}
		}
	}
	return true
}

var generatedSkel = `[generatedWarning]

package main

import (
	[explicitImports]
)

import "scrigo"

func init() {
	[predefinedTypes]
	[customVariableName] = map[string]scrigo.Package{
		[pkgContent]
	}
}
`

func generateMultiplePackages(pkgs []string, sourceFile, customVariableName string) string {

	explicitImports := ""
	for _, p := range pkgs {
		explicitImports += strings.Replace(p, "/", "_", -1) + `"` + p + `"` + "\n"
	}

	predefinedTypes := map[string]string{}

	pkgContent := ""
	for _, p := range pkgs {
		if !needsToBeGenerated(p) {
			continue
		}
		out, predefTypes := generatePackage(p)
		for _, t := range predefTypes {
			switch t {
			case "intType":
				predefinedTypes["intType"] = "reflect.TypeOf(0)"
			case "stringType":
				predefinedTypes["stringType"] = "reflect.TypeOf(\"\")"
			default:
				panic(fmt.Errorf("unkown predefined type: %s", t))
			}
		}
		pkgContent += out
	}

	pt := ""
	for name, val := range predefinedTypes {
		pt += name + " := " + val + "\n"
	}

	r := strings.NewReplacer(
		"[generatedWarning]", "// Code generated by scrigo-generate, based on file \""+sourceFile+"\". DO NOT EDIT.",
		"[explicitImports]", explicitImports,
		"[customVariableName]", customVariableName,
		"[predefinedTypes]", pt,
		"[pkgContent]", pkgContent,
	)
	return r.Replace(generatedSkel)
}

func generatePackage(pkgPath string) (string, []string) {
	predefinedTypes := []string{}
	register := func(t string) {
		for _, pt := range predefinedTypes {
			if t == pt {
				return
			}
		}
		predefinedTypes = append(predefinedTypes, t)
	}
	pkg, err := importer.Default().Import(pkgPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "importer error: %s\n", err)
		return "", nil
	}
	pkgBase := strings.Replace(pkgPath, "/", "_", -1)
	var pkgContent string
	for _, name := range pkg.Scope().Names() {
		if !isExported(name) {
			continue
		}
		obj := pkg.Scope().Lookup(name)
		objSign := obj.String()
		objPath := pkgBase + "." + name
		switch {

		// It's a variable.
		case strings.HasPrefix(objSign, "var"):
			pkgContent += mapEntry(name, "&"+objPath)

		// It's a function.
		case strings.HasPrefix(objSign, "func"):
			pkgContent += mapEntry(name, objPath)

		// It's a type definition.
		case strings.HasPrefix(objSign, "type"):
			parts := strings.Fields(objSign)
			var value = "reflect.TypeOf(new(" + objPath + ")).Elem()"
			if len(parts) == 3 {
				typ := parts[2]
				switch typ {
				case "int", "string":
					value = typ + "Type"
					register(value)
				}
			}
			pkgContent += mapEntry(name, value)

		// It's a constant.
		case strings.HasPrefix(objSign, "const"):
			{
				// TODO (Gianluca): this manages the special case MaxUint64.
				// Find a better and general way to do this.
				if pkgPath == "math" && strings.Contains(objPath, "MaxUint64") {
					pkgContent += mapEntry(name, "scrigo.Constant(uint64(math.MaxUint64), nil)")
					continue
				}
				if pkgPath == "hash/crc64" {
					continue
				}
			}
			var t string
			if strings.HasPrefix(obj.Type().String(), "untyped ") {
				t = "nil"
			} else {
				// TODO (Gianluca): constant is untyped, so this should be the
				// type of the constant as specified in package source code.
				t = "nil"
			}
			v := fmt.Sprintf("scrigo.Constant(%s, %s)", objPath, t)
			pkgContent += mapEntry(name, v)

		// Unknown package element.
		default:
			fmt.Fprintf(os.Stderr, "unknown: %s (obj: %s)\n", name, obj.String())
		}
	}

	return "\n" + `"` + pkgPath + `": {` + "\n" + pkgContent + "},\n\n", predefinedTypes
}
