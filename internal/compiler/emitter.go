// Copyright (c) 2019 Open2b Software Snc. All rights reserved.
// https://www.open2b.com

// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compiler

import (
	"fmt"
	"math"
	"reflect"

	"scriggo/ast"
	"scriggo/vm"
)

// An emitter emits instructions for the VM.
type emitter struct {

	// Index in the Function VarRefs field for each predefined variable.
	// TODO(Gianluca): this is the new way of accessing predefined vars.
	// Incrementally integrate into Scriggo, then remove the other (unused)
	// fields.
	predefinedVarRefs map[*vm.Function]map[reflect.Value]int

	// fb is the current function builder.
	fb *functionBuilder

	// indirectVars contains a read-only map of identifier nodes which must be
	// declared as indirect. This map has been generated by the type checker and
	// it's not altered by the emitter.
	indirectVars map[*ast.Identifier]bool

	labels map[*vm.Function]map[string]uint32

	// pkg is the package that is currently being emitted.
	pkg *ast.Package

	// typeInfos maps nodes to their type info.
	// Should be accessed using method 'ti'.
	typeInfos map[ast.Node]*TypeInfo

	// Index in the Function VarRefs field for each closure variable.
	closureVarRefs map[*vm.Function]map[string]int
	options        EmitterOptions

	isTemplate   bool // Reports whether it's a template.
	templateRegs struct {
		gA, gB, gC, gD, gE, gF int8 // Reserved general registers.
		iA                     int8 // Reserved int register.
	}

	// Scriggo functions.
	functions   map[*ast.Package]map[string]*vm.Function
	funcIndexes map[*vm.Function]map[*vm.Function]int8

	// Scriggo variables.
	availableVarIndexes map[*ast.Package]map[string]int16

	// Predefined functions.
	predFunIndexes map[*vm.Function]map[reflect.Value]int8

	// Holds all Scriggo-defined and pre-predefined global variables.
	globals []Global

	// rangeLabels is a list of current active Ranges. First element is the
	// Range address, second refers to the first instruction outside Range's
	// body.
	rangeLabels [][2]uint32

	// breakable is true if emitting a "breakable" statement (except ForRange,
	// which implements his own "breaking" system).
	breakable bool

	// breakLabel, if not nil, is the label to which pre-stated "breaks" must
	// jump.
	breakLabel *uint32

	// inURL indicates if the emitter is currently inside an *ast.URL node.
	inURL bool
}

// ti returns the type info of node n.
func (em *emitter) ti(n ast.Node) *TypeInfo {
	if ti, ok := em.typeInfos[n]; ok {
		if ti.valueType != nil {
			ti.Type = ti.valueType
		}
		return ti
	}
	return nil
}

// newEmitter returns a new emitter with the given type infos, indirect
// variables and options.
func newEmitter(typeInfos map[ast.Node]*TypeInfo, indirectVars map[*ast.Identifier]bool, opts EmitterOptions) *emitter {
	return &emitter{
		funcIndexes:         map[*vm.Function]map[*vm.Function]int8{},
		functions:           map[*ast.Package]map[string]*vm.Function{},
		indirectVars:        indirectVars,
		labels:              make(map[*vm.Function]map[string]uint32),
		options:             opts,
		availableVarIndexes: map[*ast.Package]map[string]int16{},
		predFunIndexes:      map[*vm.Function]map[reflect.Value]int8{},
		typeInfos:           typeInfos,
		closureVarRefs:      map[*vm.Function]map[string]int{},
		predefinedVarRefs:   map[*vm.Function]map[reflect.Value]int{},
	}
}

// reserveTemplateRegisters reverses the register used for implement
// specific template functions.
func (em *emitter) reserveTemplateRegisters() {
	// Sync with:
	//
	// - case *ast.Show of emitter.emitNodes
	// - case *ast.Text of emitter.emitNodes
	// - EmitTemplate
	// - emitter.setClosureRefs
	//
	em.templateRegs.gA = em.fb.newRegister(reflect.Interface) // w io.Writer
	em.templateRegs.gB = em.fb.newRegister(reflect.Interface) // Write
	em.templateRegs.gC = em.fb.newRegister(reflect.Interface) // Render
	em.templateRegs.gD = em.fb.newRegister(reflect.Interface) // free.
	em.templateRegs.gE = em.fb.newRegister(reflect.Interface) // free.
	em.templateRegs.gF = em.fb.newRegister(reflect.Interface) // urlWriter
	em.templateRegs.iA = em.fb.newRegister(reflect.Int)       // free.
	em.fb.emitGetVar(0, em.templateRegs.gA)
	em.fb.emitGetVar(1, em.templateRegs.gB)
	em.fb.emitGetVar(2, em.templateRegs.gC)
	em.fb.emitGetVar(3, em.templateRegs.gF)
}

// emitPackage emits a package and returns the exported functions, the
// exported variables and the init functions.
func (em *emitter) emitPackage(pkg *ast.Package, extendingPage bool) (map[string]*vm.Function, map[string]int16, []*vm.Function) {

	if !extendingPage {
		em.pkg = pkg
		em.functions[em.pkg] = map[string]*vm.Function{}
	}
	if em.availableVarIndexes[em.pkg] == nil {
		em.availableVarIndexes[em.pkg] = map[string]int16{}
	}

	// TODO(Gianluca): if a package is imported more than once, its init
	// functions are called more than once: that is wrong.
	inits := []*vm.Function{} // List of all "init" functions in current package.

	// Emit the imports.
	for _, decl := range pkg.Declarations {
		if imp, ok := decl.(*ast.Import); ok {
			if imp.Tree == nil {
				// Nothing to do. Predefined variables, constants, types
				// and functions are added as information to the tree by
				// the type-checker.
			} else {
				backupPkg := em.pkg
				pkg := imp.Tree.Nodes[0].(*ast.Package)
				funcs, vars, pkgInits := em.emitPackage(pkg, false)
				em.pkg = backupPkg
				inits = append(inits, pkgInits...)
				var importName string
				if imp.Ident == nil {
					importName = pkg.Name
				} else {
					switch imp.Ident.Name {
					case "_":
						panic("TODO(Gianluca): not implemented")
					case ".":
						importName = ""
					default:
						importName = imp.Ident.Name
					}
				}
				for name, fn := range funcs {
					if importName == "" {
						em.functions[em.pkg][name] = fn
					} else {
						em.functions[em.pkg][importName+"."+name] = fn
					}
				}
				for name, v := range vars {
					if importName == "" {
						em.availableVarIndexes[em.pkg][name] = v
					} else {
						em.availableVarIndexes[em.pkg][importName+"."+name] = v
					}
				}
			}
		}
	}

	functions := map[string]*vm.Function{}

	initToBuild := len(inits) // Index of the next "init" function to build.
	if extendingPage {
		// If the page is extending another page, the function declarations
		// have already been added to the list of available functions, so they
		// can't be added twice.
	} else {
		// Store all function declarations in current package before building
		// their bodies: order of declaration doesn't matter at package level.
		for _, dec := range pkg.Declarations {
			if fun, ok := dec.(*ast.Func); ok {
				fn := newFunction("main", fun.Ident.Name, fun.Type.Reflect)
				if fun.Ident.Name == "init" {
					inits = append(inits, fn)
				} else {
					em.functions[em.pkg][fun.Ident.Name] = fn
					if isExported(fun.Ident.Name) {
						functions[fun.Ident.Name] = fn
					}
				}
			}
		}
	}

	vars := map[string]int16{}

	// Emit the package variables.
	var initVarsFn *vm.Function
	var initVarsFb *functionBuilder
	for _, dec := range pkg.Declarations {
		if n, ok := dec.(*ast.Var); ok {
			// If the package has some variable declarations, a special "init"
			// function must be created to initialize them. "$initvars" is
			// used because is not a valid Go identifier, so there's no risk
			// of collision with Scriggo defined functions.
			backupFb := em.fb
			if initVarsFn == nil {
				initVarsFn = newFunction("main", "$initvars", reflect.FuncOf(nil, nil, false))
				em.functions[em.pkg]["$initvars"] = initVarsFn
				initVarsFb = newBuilder(initVarsFn)
				initVarsFb.emitSetAlloc(em.options.MemoryLimit)
				initVarsFb.enterScope()
			}
			em.fb = initVarsFb
			addresses := make([]address, len(n.Lhs))
			pkgVarRegs := map[string]int8{}
			for i, v := range n.Lhs {
				if isBlankIdentifier(v) {
					addresses[i] = em.newAddress(addressBlank, reflect.Type(nil), 0, 0)
				} else {
					staticType := em.ti(v).Type
					varr := em.fb.newRegister(staticType.Kind())
					em.fb.bindVarReg(v.Name, varr)
					addresses[i] = em.newAddress(addressRegister, staticType, varr, 0)
					// Store the variable register. It will be used later to store
					// initialized value inside the proper global index.
					pkgVarRegs[v.Name] = varr
					em.globals = append(em.globals, Global{Pkg: "main", Name: v.Name, Type: staticType})
					em.availableVarIndexes[em.pkg][v.Name] = int16(len(em.globals) - 1)
					vars[v.Name] = int16(len(em.globals) - 1)
				}
			}
			em.assign(addresses, n.Rhs)
			for name, reg := range pkgVarRegs {
				index := em.availableVarIndexes[em.pkg][name]
				em.fb.emitSetVar(false, reg, int(index))
			}
			em.fb = backupFb
		}
	}

	// Emit the function declarations.
	for _, dec := range pkg.Declarations {
		if n, ok := dec.(*ast.Func); ok {
			var fn *vm.Function
			if n.Ident.Name == "init" {
				fn = inits[initToBuild]
				initToBuild++
			} else {
				fn = em.functions[em.pkg][n.Ident.Name]
			}
			em.fb = newBuilder(fn)
			em.fb.emitSetAlloc(em.options.MemoryLimit)
			em.fb.enterScope()
			// If it is the "main" function, variable initialization functions
			// must be called before everything else inside main's body.
			if n.Ident.Name == "main" {
				// First: initialize the package variables.
				if initVarsFn != nil {
					iv := em.functions[em.pkg]["$initvars"]
					index := em.fb.addFunction(iv)
					em.fb.emitCall(int8(index), vm.StackShift{}, 0)
				}
				// Second: call all init functions, in order.
				for _, initFunc := range inits {
					index := em.fb.addFunction(initFunc)
					em.fb.emitCall(int8(index), vm.StackShift{}, 0)
				}
			}
			em.prepareFunctionBodyParameters(n)
			em.emitNodes(n.Body.Nodes)
			em.fb.end()
			em.fb.exitScope()
		}
	}

	if initVarsFn != nil {
		initVarsFb.exitScope()
		initVarsFb.emitReturn()
		initVarsFb.end()
	}

	// If this package is imported, initFuncs must contain initVarsFn, that is
	// processed as a common "init" function.
	if initVarsFn != nil {
		inits = append(inits, initVarsFn)
	}

	return functions, vars, inits

}

// callOptions holds informations about a function call.
type callOptions struct {
	predefined    bool
	receiverAsArg bool
	callHasDots   bool
}

// prepareCallParameters prepares the input and the output parameters for a
// function call.

// Returns the index (and their respective type) of the registers that will hold
// the function return parameters.
//
// Note that while prepareCallParameters is called before calling the function,
// prepareFunctionBodyParameters is called before emitting its body.
func (em *emitter) prepareCallParameters(fnTyp reflect.Type, args []ast.Expression, opts callOptions) ([]int8, []reflect.Type) {
	numOut := fnTyp.NumOut()
	numIn := fnTyp.NumIn()
	regs := make([]int8, numOut)
	types := make([]reflect.Type, numOut)
	for i := 0; i < numOut; i++ {
		t := fnTyp.Out(i)
		regs[i] = em.fb.newRegister(t.Kind())
		types[i] = t
	}
	if opts.receiverAsArg {
		reg := em.fb.newRegister(em.ti(args[0]).Type.Kind())
		em.fb.enterStack()
		em.emitExprR(args[0], em.ti(args[0]).Type, reg)
		em.fb.exitStack()
		args = args[1:]
	}
	if fnTyp.IsVariadic() {
		// f(g()) where f is variadic.
		if fnTyp.NumIn() == 1 && len(args) == 1 {
			if g, ok := args[0].(*ast.Call); ok {
				if numOut, ok := em.numOut(g); ok && numOut > 1 {
					if opts.predefined {
						argRegs, argTypes := em.emitCallNode(g, false, false)
						for i := range argRegs {
							dstType := fnTyp.In(0).Elem()
							reg := em.fb.newRegister(dstType.Kind())
							em.changeRegister(false, argRegs[i], reg, argTypes[i], dstType)
						}
						return regs, types
					}
					// f(g()) where g returns more than 1 argument, f is variadic and not predefined.
					slice := em.fb.newRegister(reflect.Slice)
					em.fb.enterStack()
					em.fb.emitMakeSlice(true, true, fnTyp.In(numIn-1), int8(numOut), int8(numOut), slice)
					argRegs, _ := em.emitCallNode(g, false, false)
					for i := range argRegs {
						index := em.fb.newRegister(reflect.Int)
						em.changeRegister(true, int8(i), index, intType, intType)
						em.fb.emitSetSlice(false, slice, argRegs[i], index)
					}
					em.fb.exitStack()
					return []int8{slice}, []reflect.Type{fnTyp.In(numIn - 1)}
				}
			}
		}
		for i := 0; i < numIn-1; i++ {
			t := fnTyp.In(i)
			reg := em.fb.newRegister(t.Kind())
			em.fb.enterStack()
			em.emitExprR(args[i], t, reg)
			em.fb.exitStack()
		}
		if opts.callHasDots {
			sliceArg := args[len(args)-1]
			sliceArgType := fnTyp.In(fnTyp.NumIn() - 1)
			reg := em.fb.newRegister(sliceArgType.Kind())
			em.fb.enterStack()
			em.emitExprR(sliceArg, sliceArgType, reg)
			em.fb.exitStack()
			return regs, types
		}
		if varArgs := len(args) - (numIn - 1); varArgs == 0 {
			slice := em.fb.newRegister(reflect.Slice)
			em.fb.emitMakeSlice(true, true, fnTyp.In(numIn-1), 0, 0, slice)
			return regs, types
		}
		if varArgs := len(args) - (numIn - 1); varArgs > 0 {
			t := fnTyp.In(numIn - 1).Elem()
			if opts.predefined {
				for i := 0; i < varArgs; i++ {
					reg := em.fb.newRegister(t.Kind())
					em.fb.enterStack()
					em.emitExprR(args[i+numIn-1], t, reg)
					em.fb.exitStack()
				}
			} else {
				slice := em.fb.newRegister(reflect.Slice)
				em.fb.emitMakeSlice(true, true, fnTyp.In(numIn-1), int8(varArgs), int8(varArgs), slice)
				for i := 0; i < varArgs; i++ {
					tmp := em.fb.newRegister(t.Kind())
					em.fb.enterStack()
					em.emitExprR(args[i+numIn-1], t, tmp)
					em.fb.exitStack()
					index := em.fb.newRegister(reflect.Int)
					em.fb.emitMove(true, int8(i), index, reflect.Int)
					em.fb.emitSetSlice(false, slice, tmp, index)
				}
			}
		}
	} else { // No-variadic function.
		if numIn > 1 && len(args) == 1 { // f(g()), where f takes more than 1 argument.
			regs, types := em.emitCallNode(args[0].(*ast.Call), false, false)
			for i := range regs {
				dstType := fnTyp.In(i)
				reg := em.fb.newRegister(dstType.Kind())
				em.changeRegister(false, regs[i], reg, types[i], dstType)
			}
		} else {
			for i := 0; i < numIn; i++ {
				t := fnTyp.In(i)
				reg := em.fb.newRegister(t.Kind())
				em.fb.enterStack()
				em.emitExprR(args[i], t, reg)
				em.fb.exitStack()
			}
		}
	}
	return regs, types
}

// prepareFunctionBodyParameters prepares fun's parameters (in and out) before
// emitting its body.
//
// While prepareCallParameters is called before calling the function,
// prepareFunctionBodyParameters is called before emitting its body.
func (em *emitter) prepareFunctionBodyParameters(fn *ast.Func) {

	// Reserve space for the return parameters.
	fillParametersTypes(fn.Type.Result)
	for _, res := range fn.Type.Result {
		resType := em.ti(res.Type).Type
		kind := resType.Kind()
		ret := em.fb.newRegister(kind)
		if res.Ident != nil {
			em.fb.bindVarReg(res.Ident.Name, ret)
		}
	}
	// Bind the function argument names to pre-allocated registers.
	fillParametersTypes(fn.Type.Parameters)
	for i, par := range fn.Type.Parameters {
		parType := em.ti(par.Type).Type
		kind := parType.Kind()
		if fn.Type.IsVariadic && i == len(fn.Type.Parameters)-1 {
			kind = reflect.Slice
		}
		arg := em.fb.newRegister(kind)
		if par.Ident != nil {
			em.fb.bindVarReg(par.Ident.Name, arg)
		}
	}

	if em.isTemplate {
		em.reserveTemplateRegisters()
	}

	return
}

// emitCallNode emits instructions for a function call node. It returns the
// registers and the reflect types of the returned values.
// goStmt indicates if the call node belongs to a 'go statement', while
// deferStmt reports whether it must be deferred.
func (em *emitter) emitCallNode(call *ast.Call, goStmt bool, deferStmt bool) ([]int8, []reflect.Type) {

	funTi := em.ti(call.Func)

	// Method call on a interface value.
	if funTi.MethodType == MethodCallInterface {
		rcvrExpr := call.Func.(*ast.Selector).Expr
		rcvrType := em.ti(rcvrExpr).Type
		rcvr := em.emitExpr(rcvrExpr, rcvrType)
		// MethodValue reads receiver from general.
		if kindToType(rcvrType.Kind()) != vm.TypeGeneral {
			// TODO(Gianluca): put rcvr in general
			panic("not implemented")
		}
		method := em.fb.newRegister(reflect.Func)
		name := call.Func.(*ast.Selector).Ident
		em.fb.emitMethodValue(name, rcvr, method)
		call.Args = append([]ast.Expression{rcvrExpr}, call.Args...)
		stackShift := em.fb.currentStackShift()
		opts := callOptions{
			predefined:    true,
			receiverAsArg: true,
			callHasDots:   call.IsVariadic,
		}
		regs, types := em.prepareCallParameters(funTi.Type, call.Args, opts)
		// TODO(Gianluca): handle variadic method calls.
		if goStmt {
			em.fb.emitGo()
		}
		if deferStmt {
			panic("TODO: not implemented") // TODO(Gianluca): to implement.
		}
		em.fb.emitCallIndirect(method, 0, stackShift)
		return regs, types
	}

	// Predefined function (identifiers, selectors etc...).
	if funTi.IsPredefined() {
		if funTi.MethodType == MethodCallConcrete {
			rcv := call.Func.(*ast.Selector).Expr // TODO(Gianluca): is this correct?
			call.Args = append([]ast.Expression{rcv}, call.Args...)
		}
		stackShift := em.fb.currentStackShift()
		opts := callOptions{
			predefined:    true,
			receiverAsArg: funTi.MethodType == MethodCallConcrete,
			callHasDots:   call.IsVariadic,
		}
		regs, types := em.prepareCallParameters(funTi.Type, call.Args, opts)
		var name string
		switch f := call.Func.(type) {
		case *ast.Identifier:
			name = f.Name
		case *ast.Selector:
			name = f.Ident
		}
		index := em.predFuncIndex(funTi.value.(reflect.Value), funTi.PredefPackageName, name)
		if goStmt {
			em.fb.emitGo()
		}
		numVar := vm.NoVariadicArgs
		if funTi.Type.IsVariadic() && !call.IsVariadic {
			numArgs := len(call.Args)
			if len(call.Args) == 1 {
				if callArg, ok := call.Args[0].(*ast.Call); ok {
					if numOut, ok := em.numOut(callArg); ok {
						numArgs = numOut
					}
				}
			}
			numVar = numArgs - (funTi.Type.NumIn() - 1)
		}
		if deferStmt {
			args := em.fb.currentStackShift()
			reg := em.fb.newRegister(reflect.Func)
			em.fb.emitGetFunc(true, index, reg)
			em.fb.emitDefer(reg, int8(numVar), stackShift, args)
			return regs, types
		}
		em.fb.emitCallPredefined(index, int8(numVar), stackShift)
		return regs, types
	}

	// Scriggo-defined function (identifier).
	if ident, ok := call.Func.(*ast.Identifier); ok && !em.fb.isVariable(ident.Name) {
		if fn, ok := em.functions[em.pkg][ident.Name]; ok {
			stackShift := em.fb.currentStackShift()
			regs, types := em.prepareCallParameters(fn.Type, call.Args, callOptions{callHasDots: call.IsVariadic})
			index := em.functionIndex(fn)
			if goStmt {
				em.fb.emitGo()
			}
			if deferStmt {
				args := stackDifference(em.fb.currentStackShift(), stackShift)
				reg := em.fb.newRegister(reflect.Func)
				em.fb.emitGetFunc(false, index, reg)
				// TODO(Gianluca): review vm.NoVariadicArgs.
				em.fb.emitDefer(reg, vm.NoVariadicArgs, stackShift, args)
				return regs, types
			}
			em.fb.emitCall(index, stackShift, call.Pos().Line)
			return regs, types
		}
	}

	// Scriggo-defined function (selector).
	if selector, ok := call.Func.(*ast.Selector); ok {
		if ident, ok := selector.Expr.(*ast.Identifier); ok {
			if fun, ok := em.functions[em.pkg][ident.Name+"."+selector.Ident]; ok {
				stackShift := em.fb.currentStackShift()
				regs, types := em.prepareCallParameters(fun.Type, call.Args, callOptions{callHasDots: call.IsVariadic})
				index := em.functionIndex(fun)
				if goStmt {
					em.fb.emitGo()
				}
				if deferStmt {
					panic("TODO: not implemented") // TODO(Gianluca): to implement.
				}
				em.fb.emitCall(index, stackShift, call.Pos().Line)
				return regs, types
			}
		}
	}

	// Indirect function.
	reg := em.emitExpr(call.Func, em.ti(call.Func).Type)
	stackShift := em.fb.currentStackShift()
	opts := callOptions{predefined: false, callHasDots: call.IsVariadic}
	regs, types := em.prepareCallParameters(funTi.Type, call.Args, opts)
	// CallIndirect is always emitted with 'NoVariadicArgs' because the emitter
	// cannot distinguish between Scriggo defined functions (that require a
	// []Type) and predefined function (that require Type1, Type2 ...). For this
	// reason the arguments of an indirect call are emitted as if always calling
	// a Scriggo defined function.
	if goStmt {
		em.fb.emitGo()
	}
	if deferStmt {
		args := stackDifference(em.fb.currentStackShift(), stackShift)
		em.fb.emitDefer(reg, int8(vm.NoVariadicArgs), stackShift, args)
		return regs, types
	}
	em.fb.emitCallIndirect(reg, int8(vm.NoVariadicArgs), stackShift)

	return regs, types
}

// emitSelector emits selector in register reg.
func (em *emitter) emitSelector(expr *ast.Selector, reg int8, dstType reflect.Type) {

	ti := em.ti(expr)

	// Method value on concrete and interface values.
	if ti.MethodType == MethodValueConcrete || ti.MethodType == MethodValueInterface {
		rcvrExpr := expr.Expr
		rcvrType := em.ti(rcvrExpr).Type
		rcvr := em.emitExpr(rcvrExpr, rcvrType)
		// MethodValue reads receiver from general.
		if kindToType(rcvrType.Kind()) != vm.TypeGeneral {
			oldRcvr := rcvr
			rcvr = em.fb.newRegister(reflect.Interface)
			em.fb.emitTypify(false, rcvrType, oldRcvr, rcvr)
		}
		if kindToType(dstType.Kind()) == vm.TypeGeneral {
			em.fb.emitMethodValue(expr.Ident, rcvr, reg)
		} else {
			panic("not implemented")
		}
		return
	}

	if ti.IsPredefined() {

		// TODO(Gianluca): this is the new way of accessing predefined vars.
		// Incrementally integrate into Scriggo, then remove the other checks.
		if index, ok := em.predefinedVarRefs[em.fb.fn][ti.value.(reflect.Value)]; ok {
			em.fb.emitGetVar(int(index), reg)
			return
		}

		// Predefined variable.
		index := em.predVarIndex(ti.value.(reflect.Value), ti.PredefPackageName, expr.Ident)
		em.fb.emitGetVar(int(index), reg)
		return
	}

	// Scriggo-defined package variables.
	if ident, ok := expr.Expr.(*ast.Identifier); ok {
		if index, ok := em.availableVarIndexes[em.pkg][ident.Name+"."+expr.Ident]; ok {
			if reg == 0 {
				return
			}
			if canEmitDirectly(ti.Type.Kind(), dstType.Kind()) {
				em.fb.emitGetVar(int(index), reg)
				return
			}
			tmp := em.fb.newRegister(ti.Type.Kind())
			em.fb.emitGetVar(int(index), tmp)
			em.changeRegister(false, tmp, reg, ti.Type, dstType)
			return
		}

		// Scriggo-defined package functions.
		if sf, ok := em.functions[em.pkg][ident.Name+"."+expr.Ident]; ok {
			if reg == 0 {
				return
			}
			index := em.functionIndex(sf)
			em.fb.emitGetFunc(false, index, reg)
			em.changeRegister(false, reg, reg, em.ti(expr).Type, dstType)
			return
		}
	}

	// Struct field.
	exprType := em.ti(expr.Expr).Type
	exprReg := em.emitExpr(expr.Expr, exprType)
	field, _ := exprType.FieldByName(expr.Ident)
	index := em.fb.makeIntConstant(encodeFieldIndex(field.Index))
	fieldType := em.ti(expr).Type
	if canEmitDirectly(fieldType.Kind(), dstType.Kind()) {
		em.fb.emitField(exprReg, index, reg)
		return
	}
	tmp := em.fb.newRegister(fieldType.Kind())
	em.fb.emitField(exprReg, index, tmp)
	em.changeRegister(false, tmp, reg, fieldType, dstType)

	return
}

// emitBuiltin emits instructions for a builtin call, writing the result, if
// necessary, into the register reg.
func (em *emitter) emitBuiltin(call *ast.Call, reg int8, dstType reflect.Type) {
	args := call.Args
	switch call.Func.(*ast.Identifier).Name {
	case "append":
		sliceType := em.ti(args[0]).Type
		slice := em.emitExpr(args[0], sliceType)
		if call.IsVariadic {
			tmp := em.fb.newRegister(sliceType.Kind())
			em.fb.emitMove(false, slice, tmp, sliceType.Kind())
			arg := em.emitExpr(args[1], em.ti(args[1]).Type)
			em.fb.emitAppendSlice(arg, tmp)
			em.changeRegister(false, tmp, reg, sliceType, dstType)
			return
		}
		// TODO(Gianluca): moving to a different register is not always
		// necessary. For instance, in case of `s = append(s, t)` moving can be
		// avoided. The problem is that now is too late to check for left-hand
		// symbol which receives the return value of the appending.
		em.fb.enterStack()
		tmp := em.fb.newRegister(sliceType.Kind())
		em.changeRegister(false, slice, tmp, sliceType, sliceType)
		elems := []int8{}
		for _, argExpr := range args[1:] {
			elem := em.fb.newRegister(sliceType.Elem().Kind())
			em.fb.enterStack()
			em.emitExprR(argExpr, sliceType.Elem(), elem)
			em.fb.exitStack()
			elems = append(elems, elem)
		}
		// TODO(Gianluca): if len(appendArgs) > 255 split in blocks
		if len(elems) > 0 {
			em.fb.emitAppend(elems[0], int8(len(elems)), tmp)
		}
		em.changeRegister(false, tmp, reg, sliceType, dstType)
		em.fb.exitStack()
	case "cap":
		typ := em.ti(args[0]).Type
		s := em.emitExpr(args[0], typ)
		if canEmitDirectly(intType.Kind(), dstType.Kind()) {
			em.fb.emitCap(s, reg)
			return
		}
		tmp := em.fb.newRegister(intType.Kind())
		em.fb.emitCap(s, tmp)
		em.changeRegister(false, tmp, reg, intType, dstType)
	case "close":
		chann := em.emitExpr(args[0], em.ti(args[0]).Type)
		em.fb.emitClose(chann)
	case "complex":
		floatType := em.ti(args[0]).Type
		r := em.emitExpr(args[0], floatType)
		i := em.emitExpr(args[1], floatType)
		complexType := complex128Type
		if floatType.Kind() == reflect.Float32 {
			complexType = complex64Type
		}
		if canEmitDirectly(complexType.Kind(), dstType.Kind()) {
			em.fb.emitComplex(r, i, reg, dstType.Kind())
			return
		}
		tmp := em.fb.newRegister(complexType.Kind())
		em.fb.emitComplex(r, i, tmp, complexType.Kind())
		em.changeRegister(false, tmp, reg, complexType, dstType)
	case "copy":
		dst := em.emitExpr(args[0], em.ti(args[0]).Type)
		src := em.emitExpr(args[1], em.ti(args[1]).Type)
		if reg == 0 {
			em.fb.emitCopy(dst, src, 0)
			return
		}
		if canEmitDirectly(reflect.Int, dstType.Kind()) {
			em.fb.emitCopy(dst, src, reg)
			return
		}
		em.fb.enterStack()
		tmp := em.fb.newRegister(reflect.Int)
		em.fb.emitCopy(dst, src, tmp)
		em.changeRegister(false, tmp, reg, intType, dstType)
		em.fb.exitStack()
	case "delete":
		mapp := em.emitExpr(args[0], emptyInterfaceType)
		key := em.emitExpr(args[1], emptyInterfaceType)
		em.fb.emitDelete(mapp, key)
	case "len":
		typ := em.ti(args[0]).Type
		s := em.emitExpr(args[0], typ)
		if canEmitDirectly(reflect.Int, dstType.Kind()) {
			em.fb.emitLen(s, reg, typ)
			return
		}
		em.fb.enterStack()
		tmp := em.fb.newRegister(reflect.Int)
		em.fb.emitLen(s, tmp, typ)
		em.changeRegister(false, tmp, reg, intType, dstType)
		em.fb.exitStack()
	case "make":
		typ := em.ti(args[0]).Type
		switch typ.Kind() {
		case reflect.Map:
			if len(args) == 1 {
				em.fb.emitMakeMap(typ, true, 0, reg)
			} else {
				size, kSize := em.emitExprK(args[1], intType)
				em.fb.emitMakeMap(typ, kSize, size, reg)
			}
		case reflect.Slice:
			lenExpr := args[1]
			lenn, kLen := em.emitExprK(lenExpr, intType)
			var kCap bool
			var capp int8
			if len(args) == 3 {
				capArg := args[2]
				capp, kCap = em.emitExprK(capArg, intType)
			} else {
				kCap = kLen
				capp = lenn
			}
			em.fb.emitMakeSlice(kLen, kCap, typ, lenn, capp, reg)
		case reflect.Chan:
			chanType := em.ti(args[0]).Type
			var kCapacity bool
			var capacity int8
			if len(args) == 1 {
				capacity = 0
				kCapacity = true
			} else {
				capacity, kCapacity = em.emitExprK(args[1], intType)
			}
			em.fb.emitMakeChan(chanType, kCapacity, capacity, reg)
		default:
			panic("bug")
		}
	case "new":
		newType := em.ti(args[0]).Type
		em.fb.emitNew(newType, reg)
	case "panic":
		arg := em.emitExpr(args[0], emptyInterfaceType)
		em.fb.emitPanic(arg, call.Pos().Line, nil)
	case "print":
		for _, argExpr := range args {
			arg := em.emitExpr(argExpr, emptyInterfaceType)
			em.fb.emitPrint(arg)
		}
	case "println":
		last := len(args) - 1
		for i, argExpr := range args {
			arg := em.emitExpr(argExpr, emptyInterfaceType)
			em.fb.emitPrint(arg)
			if i < last {
				str := em.fb.makeStringConstant(" ")
				sep := em.fb.newRegister(reflect.Interface)
				em.changeRegister(true, str, sep, stringType, emptyInterfaceType)
				em.fb.emitPrint(sep)
			}
		}
		str := em.fb.makeStringConstant("\n")
		sep := em.fb.newRegister(reflect.Interface)
		em.changeRegister(true, str, sep, stringType, emptyInterfaceType)
		em.fb.emitPrint(sep)
	case "real", "imag":
		complexType := em.ti(args[0]).Type
		complex, k := em.emitExprK(args[0], complexType)
		floatType := float64Type
		if complexType.Kind() == reflect.Complex64 {
			floatType = float32Type
		}
		if canEmitDirectly(floatType.Kind(), dstType.Kind()) {
			if call.Func.(*ast.Identifier).Name == "real" {
				em.fb.emitRealImag(k, complex, reg, 0)
			} else {
				em.fb.emitRealImag(k, complex, 0, reg)
			}
			return
		}
		tmp := em.fb.newRegister(floatType.Kind())
		if call.Func.(*ast.Identifier).Name == "real" {
			em.fb.emitRealImag(k, complex, tmp, 0)
		} else {
			em.fb.emitRealImag(k, complex, 0, tmp)
		}
		em.changeRegister(false, tmp, reg, floatType, dstType)
	case "recover":
		em.fb.emitRecover(reg, false)
	default:
		panic("unknown builtin") // TODO(Gianluca): remove.
	}
}

// emitNodes emits instructions for nodes.
func (em *emitter) emitNodes(nodes []ast.Node) {

	for _, node := range nodes {
		switch node := node.(type) {

		case *ast.Assignment:
			em.emitAssignmentNode(node)

		case *ast.Block:
			em.fb.enterScope()
			em.emitNodes(node.Nodes)
			em.fb.exitScope()

		case *ast.Break:
			if em.breakable {
				if em.breakLabel == nil {
					label := em.fb.newLabel()
					em.breakLabel = &label
				}
				em.fb.emitGoto(*em.breakLabel)
			} else {
				if node.Label != nil {
					panic("TODO(Gianluca): not implemented")
				}
				em.fb.emitBreak(em.rangeLabels[len(em.rangeLabels)-1][0])
				em.fb.emitGoto(em.rangeLabels[len(em.rangeLabels)-1][1])
			}

		case *ast.Comment:
			// Nothing to do.

		case *ast.Const:
			// Nothing to do.

		case *ast.Continue:
			if node.Label != nil {
				panic("TODO(Gianluca): not implemented")
			}
			em.fb.emitContinue(em.rangeLabels[len(em.rangeLabels)-1][0])

		case *ast.Defer:
			call := node.Call.(*ast.Call)
			if em.ti(call.Func) == showMacroIgnoredTi {
				// Nothing to do
				continue
			}
			if em.isBuiltinCall(call, "recover") {
				stackShift := em.fb.currentStackShift()
				backup := em.fb
				fnReg := em.fb.newRegister(reflect.Func)
				fn := em.fb.emitFunc(fnReg, reflect.FuncOf(nil, nil, false))
				em.fb = newBuilder(fn)
				em.fb.emitRecover(0, true)
				em.fb.emitReturn()
				em.fb = backup
				em.fb.emitDefer(fnReg, 0, stackShift, vm.StackShift{0, 0, 0, 0})
				continue
			}
			em.fb.enterStack()
			_, _ = em.emitCallNode(call, false, true)
			em.fb.exitStack()

		case *ast.Import:
			if em.isTemplate {
				if node.Ident != nil && node.Ident.Name == "_" {
					// Nothing to do: template pages cannot have
					// collateral effects.
				} else {
					backupBuilder := em.fb
					backupPkg := em.pkg
					functions, vars, inits := em.emitPackage(node.Tree.Nodes[0].(*ast.Package), false)
					var importName string
					if node.Ident == nil {
						// Imports without identifiers are handled as 'import . "path"'.
						importName = ""
					} else {
						importName = node.Ident.Name
						if node.Ident.Name == "." {
							importName = ""
						}
					}
					if em.functions[backupPkg] == nil {
						em.functions[backupPkg] = map[string]*vm.Function{}
					}
					for name, fn := range functions {
						if importName == "" {
							em.functions[backupPkg][name] = fn
						} else {
							em.functions[backupPkg][importName+"."+name] = fn
						}
					}
					if em.availableVarIndexes[backupPkg] == nil {
						em.availableVarIndexes[backupPkg] = map[string]int16{}
					}
					for name, v := range vars {
						if importName == "" {
							em.availableVarIndexes[backupPkg][name] = v
						} else {
							em.availableVarIndexes[backupPkg][importName+"."+name] = v
						}
					}
					if len(inits) > 0 {
						panic("have inits!") // TODO(Gianluca): review.
					}
					em.fb = backupBuilder
					em.pkg = backupPkg
				}
			}

		case *ast.Fallthrough:
			// Nothing to do: fallthrough nodes are handled by method
			// emitter.emitSwitch.

		case *ast.For:
			currentBreakable := em.breakable
			currentBreakLabel := em.breakLabel
			em.breakable = true
			em.breakLabel = nil
			em.fb.enterScope()
			if node.Init != nil {
				em.emitNodes([]ast.Node{node.Init})
			}
			if node.Condition != nil {
				forLabel := em.fb.newLabel()
				em.fb.setLabelAddr(forLabel)
				em.emitCondition(node.Condition)
				endForLabel := em.fb.newLabel()
				em.fb.emitGoto(endForLabel)
				em.emitNodes(node.Body)
				if node.Post != nil {
					em.emitNodes([]ast.Node{node.Post})
				}
				em.fb.emitGoto(forLabel)
				em.fb.setLabelAddr(endForLabel)
			} else {
				forLabel := em.fb.newLabel()
				em.fb.setLabelAddr(forLabel)
				em.emitNodes(node.Body)
				if node.Post != nil {
					em.emitNodes([]ast.Node{node.Post})
				}
				em.fb.emitGoto(forLabel)
			}
			em.fb.exitScope()
			if em.breakLabel != nil {
				em.fb.setLabelAddr(*em.breakLabel)
			}
			em.breakable = currentBreakable
			em.breakLabel = currentBreakLabel

		case *ast.ForRange:
			em.fb.enterScope()
			vars := node.Assignment.Lhs
			indexReg := int8(0)
			if len(vars) >= 1 && !isBlankIdentifier(vars[0]) {
				name := vars[0].(*ast.Identifier).Name
				if node.Assignment.Type == ast.AssignmentDeclaration {
					indexReg = em.fb.newRegister(reflect.Int)
					em.fb.bindVarReg(name, indexReg)
				} else {
					indexReg = em.fb.scopeLookup(name)
				}
			}
			elem := int8(0)
			if len(vars) == 2 && !isBlankIdentifier(vars[1]) {
				typ := em.ti(vars[1]).Type
				name := vars[1].(*ast.Identifier).Name
				if node.Assignment.Type == ast.AssignmentDeclaration {
					elem = em.fb.newRegister(typ.Kind())
					em.fb.bindVarReg(name, elem)
				} else {
					elem = em.fb.scopeLookup(name)
				}
			}
			expr := node.Assignment.Rhs[0]
			exprType := em.ti(expr).Type
			exprReg, kExpr := em.emitExprK(expr, exprType)
			if exprType.Kind() != reflect.String && kExpr {
				kExpr = false
				exprReg = em.emitExpr(expr, exprType)
			}
			rangeLabel := em.fb.newLabel()
			em.fb.setLabelAddr(rangeLabel)
			endRange := em.fb.newLabel()
			em.rangeLabels = append(em.rangeLabels, [2]uint32{rangeLabel, endRange})
			em.fb.emitRange(kExpr, exprReg, indexReg, elem, exprType.Kind())
			em.fb.emitGoto(endRange)
			em.fb.enterScope()
			em.emitNodes(node.Body)
			em.fb.emitContinue(rangeLabel)
			em.fb.setLabelAddr(endRange)
			em.rangeLabels = em.rangeLabels[:len(em.rangeLabels)-1]
			em.fb.exitScope()
			em.fb.exitScope()

		case *ast.Go:
			call := node.Call.(*ast.Call)
			if em.ti(call.Func) == showMacroIgnoredTi {
				// Nothing to do
				continue
			}
			em.fb.enterStack()
			_, _ = em.emitCallNode(call, true, false)
			em.fb.exitStack()

		case *ast.Goto:
			if label, ok := em.labels[em.fb.fn][node.Label.Name]; ok {
				em.fb.emitGoto(label)
			} else {
				if em.labels[em.fb.fn] == nil {
					em.labels[em.fb.fn] = make(map[string]uint32)
				}
				label = em.fb.newLabel()
				em.fb.emitGoto(label)
				em.labels[em.fb.fn][node.Label.Name] = label
			}

		case *ast.If:
			em.fb.enterScope()
			if node.Assignment != nil {
				em.emitNodes([]ast.Node{node.Assignment})
			}
			em.emitCondition(node.Condition)
			if node.Else == nil {
				endIfLabel := em.fb.newLabel()
				em.fb.emitGoto(endIfLabel)
				em.fb.enterScope()
				em.emitNodes(node.Then.Nodes)
				em.fb.exitScope()
				em.fb.setLabelAddr(endIfLabel)
			} else {
				elseLabel := em.fb.newLabel()
				em.fb.emitGoto(elseLabel)
				em.fb.enterScope()
				em.emitNodes(node.Then.Nodes)
				em.fb.exitScope()
				endIfLabel := em.fb.newLabel()
				em.fb.emitGoto(endIfLabel)
				em.fb.setLabelAddr(elseLabel)
				switch els := node.Else.(type) {
				case *ast.If:
					em.emitNodes([]ast.Node{els})
				case *ast.Block:
					em.emitNodes(els.Nodes)
				}
				em.fb.setLabelAddr(endIfLabel)
			}
			em.fb.exitScope()

		case *ast.Include:
			em.emitNodes(node.Tree.Nodes)

		case *ast.Label:
			if _, found := em.labels[em.fb.fn][node.Name.Name]; !found {
				if em.labels[em.fb.fn] == nil {
					em.labels[em.fb.fn] = make(map[string]uint32)
				}
				em.labels[em.fb.fn][node.Name.Name] = em.fb.newLabel()
			}
			em.fb.setLabelAddr(em.labels[em.fb.fn][node.Name.Name])
			if node.Statement != nil {
				em.emitNodes([]ast.Node{node.Statement})
			}

		case *ast.Return:
			// TODO(Gianluca): complete implementation of tail call optimization.
			// if len(node.Rhs) == 1 {
			// 	if call, ok := node.Rhs[0].(*ast.Call); ok {
			// 		tmpRegs := make([]int8, len(call.Args))
			// 		paramPosition := make([]int8, len(call.Args))
			// 		tmpTypes := make([]reflect.Type, len(call.Args))
			// 		shift := vm.StackShift{}
			// 		for i := range call.Args {
			// 			tmpTypes[i] = em.TypeInfo[call.Args[i]].Type
			// 			t := int(kindToType(tmpTypes[i].Kind()))
			// 			tmpRegs[i] = em.FB.newRegister(tmpTypes[i].Kind())
			// 			shift[t]++
			// 			c.compileExpr(call.Args[i], tmpRegs[i], tmpTypes[i])
			// 			paramPosition[i] = shift[t]
			// 		}
			// 		for i := range call.Args {
			// 			em.changeRegister(false, tmpRegs[i], paramPosition[i], tmpTypes[i], em.TypeInfo[call.Func].Type.In(i))
			// 		}
			// 		em.FB.TailCall(vm.CurrentFunction, node.pos().Line)
			// 		continue
			// 	}
			// }
			offset := [4]int8{}
			for i, v := range node.Values {
				typ := em.fb.fn.Type.Out(i)
				var reg int8
				switch kindToType(typ.Kind()) {
				case vm.TypeInt:
					offset[0]++
					reg = offset[0]
				case vm.TypeFloat:
					offset[1]++
					reg = offset[1]
				case vm.TypeString:
					offset[2]++
					reg = offset[2]
				case vm.TypeGeneral:
					offset[3]++
					reg = offset[3]
				}
				em.emitExprR(v, typ, reg)
			}
			em.fb.emitReturn()

		case *ast.Select:
			em.emitSelect(node)

		case *ast.Send:
			chann := em.emitExpr(node.Channel, em.ti(node.Channel).Type)
			value := em.emitExpr(node.Value, em.ti(node.Value).Type)
			em.fb.emitSend(chann, value)

		case *ast.Show:
			// render([implicit *vm.Env,] gD io.Writer, gE interface{}, iA ast.Context)
			em.emitExprR(node.Expr, emptyInterfaceType, em.templateRegs.gE)
			em.fb.emitMove(true, int8(node.Context), em.templateRegs.iA, reflect.Int)
			if em.inURL {
				// In a URL context: use the urlWriter, that implements io.Writer.
				em.fb.emitMove(false, em.templateRegs.gF, em.templateRegs.gD, reflect.Interface)
			} else {
				// Not in a URL context: use the default writer.
				em.fb.emitMove(false, em.templateRegs.gA, em.templateRegs.gD, reflect.Interface)
			}
			em.fb.emitCallIndirect(em.templateRegs.gC, 0, vm.StackShift{em.templateRegs.iA - 1, 0, 0, em.templateRegs.gC})

		case *ast.Switch:
			currentBreakable := em.breakable
			currentBreakLabel := em.breakLabel
			em.breakable = true
			em.breakLabel = nil
			em.emitSwitch(node)
			if em.breakLabel != nil {
				em.fb.setLabelAddr(*em.breakLabel)
			}
			em.breakable = currentBreakable
			em.breakLabel = currentBreakLabel

		case *ast.Text:
			// Write(gE []byte) (iA int, gD error)
			index := len(em.fb.fn.Data)
			em.fb.fn.Data = append(em.fb.fn.Data, node.Text) // TODO(Gianluca): cut text.
			em.fb.emitLoadData(int16(index), em.templateRegs.gE)
			var writeFun int8
			if em.inURL {
				// In a URL context: getting the method WriteText of an the
				// urlWriter, that has the same sign of the method Write which
				// implements interface io.Writer.
				em.fb.enterStack()
				writeFun = em.fb.newRegister(reflect.Func)
				em.fb.emitMethodValue("WriteText", em.templateRegs.gF, writeFun)
				em.fb.exitStack()
			} else {
				writeFun = em.templateRegs.gB
			}
			em.fb.emitCallIndirect(writeFun, 0, vm.StackShift{em.templateRegs.iA - 1, 0, 0, em.templateRegs.gC})

		case *ast.TypeDeclaration:
			// Nothing to do.

		case *ast.TypeSwitch:
			currentBreakable := em.breakable
			currentBreakLabel := em.breakLabel
			em.breakable = true
			em.breakLabel = nil
			em.emitTypeSwitch(node)
			if em.breakLabel != nil {
				em.fb.setLabelAddr(*em.breakLabel)
			}
			em.breakable = currentBreakable
			em.breakLabel = currentBreakLabel

		case *ast.URL:
			// Entering inside an URL context; this will affect the way that
			// values and text are rendered.
			em.inURL = true
			// Call method Reset of urlWriter.
			em.fb.enterStack()
			method := em.fb.newRegister(reflect.Func)
			em.fb.emitMethodValue("StartURL", em.templateRegs.gF, method)
			ss := em.fb.currentStackShift()
			quoteArg := em.fb.newRegister(reflect.Bool)
			isSetArg := em.fb.newRegister(reflect.Bool)
			var quote, isSet int8
			if node.Context == ast.ContextAttribute {
				quote = 1
			}
			if node.Attribute == "srcset" {
				isSet = 1
			}
			em.changeRegister(true, quote, quoteArg, boolType, boolType)
			em.changeRegister(true, isSet, isSetArg, boolType, boolType)
			em.fb.emitCallIndirect(method, 0, ss)
			em.fb.exitStack()
			// Emit the nodes in the URL.
			em.emitNodes(node.Value)
			// Exiting from an URL context.
			em.inURL = false

		case *ast.Var:
			addresses := make([]address, len(node.Lhs))
			for i, v := range node.Lhs {
				if isBlankIdentifier(v) {
					addresses[i] = em.newAddress(addressBlank, reflect.Type(nil), 0, 0)
				} else {
					staticType := em.ti(v).Type
					if em.indirectVars[v] {
						varr := -em.fb.newRegister(reflect.Interface)
						em.fb.bindVarReg(v.Name, varr)
						addresses[i] = em.newAddress(addressIndirectDeclaration, staticType, varr, 0)
					} else {
						varr := em.fb.newRegister(staticType.Kind())
						em.fb.bindVarReg(v.Name, varr)
						addresses[i] = em.newAddress(addressRegister, staticType, varr, 0)
					}
				}
			}
			em.assign(addresses, node.Rhs)

		case ast.Expression:
			em.emitExprR(node, reflect.Type(nil), 0)

		default:
			panic(fmt.Sprintf("node %T not supported", node)) // TODO(Gianluca): remove.

		}

	}

}

// emitExpr emits expr into a register of a given type. emitExpr tries to not
// create a new register, but to use an existing one. The register used for
// emission is returned.
// TODO(Gianluca): add an option/another method to force the creation of an new
// register? Is necessary?
func (em *emitter) emitExpr(expr ast.Expression, dstType reflect.Type) int8 {
	reg, _ := em._emitExpr(expr, dstType, 0, false, false)
	return reg
}

// emitExprK emits expr into a register of a given type. The boolean return
// parameter reports whether the returned int8 is a constant or not.
func (em *emitter) emitExprK(expr ast.Expression, dstType reflect.Type) (int8, bool) {
	return em._emitExpr(expr, dstType, 0, false, true)
}

// emitExprR emits expr into register reg with the given type.
func (em *emitter) emitExprR(expr ast.Expression, dstType reflect.Type, reg int8) {
	_, _ = em._emitExpr(expr, dstType, reg, true, false)
}

// _emitExpr emits expression expr.
//
// If a register is given and putInReg is true, then such register is used for
// emission; otherwise _emitExpr chooses the output register, returning it to
// the caller.
//
// If allowK is true, then the returned register can be an immediante value and
// the boolean return parameters is true.
//
// _emitExpr is an internal support method, and should be called by emitExpr,
// emitExprK and emitExprR exclusively.
//
func (em *emitter) _emitExpr(expr ast.Expression, dstType reflect.Type, reg int8, useGivenReg bool, allowK bool) (int8, bool) {

	if allowK && !useGivenReg {
		ti := em.ti(expr)
		if ti.HasValue() && !ti.IsPredefined() {
			switch v := ti.value.(type) {
			case int64:
				if kindToType(dstType.Kind()) == vm.TypeInt {
					if -127 < v && v < 126 {
						return int8(v), true
					}
				}
			case float64:
				if kindToType(dstType.Kind()) == vm.TypeFloat {
					if math.Floor(v) == v && -127 < v && v < 126 {
						return int8(v), true
					}
				}
			}
		}
		if expr, ok := expr.(*ast.Identifier); ok && em.fb.isVariable(expr.Name) {
			return em.fb.scopeLookup(expr.Name), false
		}
	}

	if !useGivenReg {
		if expr, ok := expr.(*ast.Identifier); ok && em.fb.isVariable(expr.Name) {
			if canEmitDirectly(em.ti(expr).Type.Kind(), dstType.Kind()) {
				return em.fb.scopeLookup(expr.Name), false
			}
		}
		reg = em.fb.newRegister(dstType.Kind())
	}

	// If the instructions that emit expr put result in a register type
	// different than the register type of dstType, use an intermediate
	// temporary register. Consider that this is not always necessary to check
	// this: for example if expr is a function, dstType must be a function or an
	// interface (this is guaranteed by the type checker) and in the current
	// implementation of the VM functions and interfaces use the same register
	// type.
	//
	// Not that this does not imply that method 'changeRegister' doesn't have to
	// be called: in case when internal representation is different than the
	// external one (for example arrays and functions), the calls to
	// 'changeRegister' may emit a Typify instruction to ensure that values are
	// correctly converted.

	if ti := em.ti(expr); ti != nil && ti.HasValue() && !ti.IsPredefined() {
		typ := ti.Type
		if reg == 0 {
			return reg, false
		}
		// Handle nil values.
		if ti.value == nil {
			c := em.fb.makeGeneralConstant(nil)
			em.changeRegister(true, c, reg, typ, dstType)
			return reg, false
		}
		switch v := ti.value.(type) {
		case int64:
			c := em.fb.makeIntConstant(v)
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				em.fb.emitLoadNumber(vm.TypeInt, c, reg)
				em.changeRegister(false, reg, reg, typ, dstType)
				return reg, false
			}
			tmp := em.fb.newRegister(typ.Kind())
			em.fb.emitLoadNumber(vm.TypeInt, c, tmp)
			em.changeRegister(false, tmp, reg, typ, dstType)
			return reg, false
		case float64:
			var c int8
			if typ.Kind() == reflect.Float32 {
				c = em.fb.makeFloatConstant(float64(float32(v)))
			} else {
				c = em.fb.makeFloatConstant(v)
			}
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				em.fb.emitLoadNumber(vm.TypeFloat, c, reg)
				em.changeRegister(false, reg, reg, typ, dstType)
				return reg, false
			}
			tmp := em.fb.newRegister(typ.Kind())
			em.fb.emitLoadNumber(vm.TypeFloat, c, tmp)
			em.changeRegister(false, tmp, reg, typ, dstType)
			return reg, false
		case string:
			c := em.fb.makeStringConstant(v)
			em.changeRegister(true, c, reg, typ, dstType)
			return reg, false
		}
		v := reflect.ValueOf(em.ti(expr).value)
		switch v.Kind() {
		case reflect.Interface:
			panic("not implemented") // TODO(Gianluca).
		case reflect.Slice,
			reflect.Complex64,
			reflect.Complex128,
			reflect.Array,
			reflect.Chan,
			reflect.Func,
			reflect.Map,
			reflect.Ptr,
			reflect.Struct:
			c := em.fb.makeGeneralConstant(v.Interface())
			em.changeRegister(true, c, reg, typ, dstType)
		case reflect.UnsafePointer:
			panic("not implemented") // TODO(Gianluca).
		default:
			panic(fmt.Errorf("unsupported value type %T (expr: %s)", em.ti(expr).value, expr))
		}
		return reg, false
	}

	// Predefined values.
	if ti := em.ti(expr); ti != nil && ti.IsPredefined() && ti.MethodType == NoMethod {

		// Predefined functions.
		if ti.Type.Kind() == reflect.Func {
			name := ""
			switch expr := expr.(type) {
			case *ast.Identifier:
				name = expr.Name
			case *ast.Selector:
				name = expr.Ident
			case *ast.Placeholder:
			default:
				panic("bug") // TODO(Gianluca).
			}
			index := em.predFuncIndex(ti.value.(reflect.Value), ti.PredefPackageName, name)
			em.fb.emitGetFunc(true, index, reg)
			em.changeRegister(false, reg, reg, ti.Type, dstType)
			return reg, false
		}

		// Predefined variable.
		if ident, ok := expr.(*ast.Identifier); ok {
			index := em.predVarIndex(ti.value.(reflect.Value), ti.PredefPackageName, ident.Name)
			if canEmitDirectly(ti.Type.Kind(), dstType.Kind()) {
				em.fb.emitGetVar(int(index), reg)
				return reg, false
			}
			tmp := em.fb.newRegister(ti.Type.Kind())
			em.fb.emitGetVar(int(index), tmp)
			em.changeRegister(false, tmp, reg, ti.Type, dstType)
			return reg, false
		}

	}

	switch expr := expr.(type) {

	case *ast.BinaryOperator:

		// Binary operations on complex numbers.
		if exprType := em.ti(expr).Type; exprType.Kind() == reflect.Complex64 || exprType.Kind() == reflect.Complex128 {
			stackShift := em.fb.currentStackShift()
			em.fb.enterScope()
			index := em.fb.complexOperationIndex(expr.Operator(), false)
			ret := em.fb.newRegister(reflect.Complex128)
			c1 := em.fb.newRegister(reflect.Complex128)
			c2 := em.fb.newRegister(reflect.Complex128)
			em.fb.enterScope()
			em.emitExprR(expr.Expr1, exprType, c1)
			em.fb.exitScope()
			em.fb.enterScope()
			em.emitExprR(expr.Expr2, exprType, c2)
			em.fb.exitScope()
			em.fb.emitCallPredefined(index, 0, stackShift)
			em.changeRegister(false, ret, reg, exprType, dstType)
			em.fb.exitScope()
			return reg, false
		}

		// Binary && and ||.
		if op := expr.Operator(); op == ast.OperatorAndAnd || op == ast.OperatorOrOr {
			cmp := int8(0)
			if op == ast.OperatorAndAnd {
				cmp = 1
			}
			if canEmitDirectly(dstType.Kind(), reflect.Bool) {
				em.emitExprR(expr.Expr1, dstType, reg)
				endIf := em.fb.newLabel()
				em.fb.emitIf(true, reg, vm.ConditionEqual, cmp, reflect.Int)
				em.fb.emitGoto(endIf)
				em.emitExprR(expr.Expr2, dstType, reg)
				em.fb.setLabelAddr(endIf)
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(reflect.Bool)
			em.emitExprR(expr.Expr1, boolType, tmp)
			endIf := em.fb.newLabel()
			em.fb.emitIf(true, tmp, vm.ConditionEqual, cmp, reflect.Int)
			em.fb.emitGoto(endIf)
			em.emitExprR(expr.Expr2, boolType, tmp)
			em.fb.setLabelAddr(endIf)
			em.changeRegister(false, tmp, reg, boolType, dstType)
			em.fb.exitStack()
			return reg, false
		}

		// Equality (or not-equality) checking with the predeclared identifier 'nil'.
		if em.ti(expr.Expr1).Nil() || em.ti(expr.Expr2).Nil() {
			em.changeRegister(true, 1, reg, boolType, dstType)
			em.emitCondition(expr)
			em.changeRegister(true, 0, reg, boolType, dstType)
			return reg, false
		}

		// ==, !=, <, <=, >=, >, &&, ||, +, -, *, /, %, ^, &^, <<, >>.
		exprType := em.ti(expr).Type
		t1 := em.ti(expr.Expr1).Type
		t2 := em.ti(expr.Expr2).Type
		v1 := em.emitExpr(expr.Expr1, t1)
		v2, k := em.emitExprK(expr.Expr2, t2)
		if reg == 0 {
			return reg, false
		}
		// String concatenation.
		if expr.Operator() == ast.OperatorAddition && t1.Kind() == reflect.String {
			if k {
				v2 = em.emitExpr(expr.Expr2, t2)
			}
			if canEmitDirectly(exprType.Kind(), dstType.Kind()) {
				em.fb.emitConcat(v1, v2, reg)
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(exprType.Kind())
			em.fb.emitConcat(v1, v2, tmp)
			em.changeRegister(false, tmp, reg, exprType, dstType)
			em.fb.exitStack()
			return reg, false
		}
		switch expr.Operator() {
		case ast.OperatorAddition, ast.OperatorSubtraction, ast.OperatorMultiplication, ast.OperatorDivision,
			ast.OperatorModulo, ast.OperatorAnd, ast.OperatorOr, ast.OperatorXor, ast.OperatorAndNot,
			ast.OperatorLeftShift, ast.OperatorRightShift:
			emitFn := map[ast.OperatorType]func(bool, int8, int8, int8, reflect.Kind){
				ast.OperatorAddition:       em.fb.emitAdd,
				ast.OperatorSubtraction:    em.fb.emitSub,
				ast.OperatorMultiplication: em.fb.emitMul,
				ast.OperatorDivision:       em.fb.emitDiv,
				ast.OperatorModulo:         em.fb.emitRem,
				ast.OperatorAnd:            em.fb.emitAnd,
				ast.OperatorOr:             em.fb.emitOr,
				ast.OperatorXor:            em.fb.emitXor,
				ast.OperatorAndNot:         em.fb.emitAndNot,
				ast.OperatorLeftShift:      em.fb.emitLeftShift,
				ast.OperatorRightShift:     em.fb.emitRightShift,
			}[expr.Operator()]
			if canEmitDirectly(exprType.Kind(), dstType.Kind()) {
				emitFn(k, v1, v2, reg, exprType.Kind())
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(exprType.Kind())
			emitFn(k, v1, v2, tmp, exprType.Kind())
			em.changeRegister(false, tmp, reg, exprType, dstType)
			em.fb.exitStack()
			return reg, false
		case ast.OperatorEqual, ast.OperatorNotEqual, ast.OperatorLess, ast.OperatorLessOrEqual,
			ast.OperatorGreaterOrEqual, ast.OperatorGreater:
			cond := map[ast.OperatorType]vm.Condition{
				ast.OperatorEqual:          vm.ConditionEqual,
				ast.OperatorNotEqual:       vm.ConditionNotEqual,
				ast.OperatorLess:           vm.ConditionLess,
				ast.OperatorLessOrEqual:    vm.ConditionLessOrEqual,
				ast.OperatorGreater:        vm.ConditionGreater,
				ast.OperatorGreaterOrEqual: vm.ConditionGreaterOrEqual,
			}[expr.Operator()]
			if canEmitDirectly(exprType.Kind(), dstType.Kind()) {
				em.fb.emitMove(true, 1, reg, reflect.Bool)
				em.fb.emitIf(k, v1, cond, v2, t1.Kind())
				em.fb.emitMove(true, 0, reg, reflect.Bool)
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(exprType.Kind())
			em.fb.emitMove(true, 1, tmp, reflect.Bool)
			em.fb.emitIf(k, v1, cond, v2, t1.Kind())
			em.fb.emitMove(true, 0, tmp, reflect.Bool)
			em.changeRegister(false, tmp, reg, exprType, dstType)
			em.fb.exitStack()
		}

	case *ast.Call:

		// ShowMacro which must be ignored (cannot be resolved).
		if em.ti(expr.Func) == showMacroIgnoredTi {
			return reg, false
		}

		// Predeclared built-in function call.
		if em.isPredeclaredBuiltinFunc(expr.Func) {
			em.emitBuiltin(expr, reg, dstType)
			return reg, false
		}

		// Conversion.
		if em.ti(expr.Func).IsType() {
			convertType := em.ti(expr.Func).Type
			// A conversion cannot have side-effects.
			if reg == 0 {
				return reg, false
			}
			typ := em.ti(expr.Args[0]).Type
			arg := em.emitExpr(expr.Args[0], typ)
			if canEmitDirectly(convertType.Kind(), dstType.Kind()) {
				em.changeRegister(false, arg, reg, typ, convertType)
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(convertType.Kind())
			em.changeRegister(false, arg, tmp, typ, convertType)
			em.changeRegister(false, tmp, reg, convertType, dstType)
			em.fb.exitStack()
			return reg, false
		}

		// Function call.
		em.fb.enterStack()
		regs, types := em.emitCallNode(expr, false, false)
		if reg != 0 {
			em.changeRegister(false, regs[0], reg, types[0], dstType)
		}
		em.fb.exitStack()

	case *ast.CompositeLiteral:

		typ := em.ti(expr.Type).Type
		switch typ.Kind() {
		case reflect.Slice, reflect.Array:
			if reg == 0 {
				for _, kv := range expr.KeyValues {
					typ := em.ti(kv.Value).Type
					em.emitExprR(kv.Value, typ, 0)
				}
				return reg, false
			}
			length := int8(em.compositeLiteralLen(expr)) // TODO(Gianluca): length is int
			if typ.Kind() == reflect.Array {
				length = int8(typ.Len())
				typ = reflect.SliceOf(typ.Elem())
			}
			em.fb.emitMakeSlice(true, true, typ, length, length, reg)
			var index int8 = -1
			for _, kv := range expr.KeyValues {
				if kv.Key != nil {
					index = int8(em.ti(kv.Key).Constant.int64())
				} else {
					index++
				}
				em.fb.enterStack()
				indexReg := em.fb.newRegister(reflect.Int)
				em.fb.emitMove(true, index, indexReg, reflect.Int)
				elem, k := em.emitExprK(kv.Value, typ.Elem())
				if reg != 0 {
					em.fb.emitSetSlice(k, reg, elem, indexReg)
				}
				em.fb.exitStack()
			}
			em.changeRegister(false, reg, reg, em.ti(expr.Type).Type, dstType)
		case reflect.Struct:
			// Struct should no be created, but its values must be emitted.
			if reg == 0 {
				for _, kv := range expr.KeyValues {
					em.emitExprR(kv.Value, em.ti(kv.Value).Type, 0)
				}
				return reg, false
			}
			structZero := em.fb.makeGeneralConstant(reflect.Zero(typ).Interface())
			// When there are no values in the composite literal, optimize the
			// creation of the struct.
			if len(expr.KeyValues) == 0 {
				em.changeRegister(true, structZero, reg, typ, dstType)
				return reg, false
			}
			// Assign key-value pairs to the struct fields.
			em.fb.enterStack()
			var structt int8
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				structt = em.fb.newRegister(reflect.Struct)
			} else {
				structt = reg
			}
			em.changeRegister(true, structZero, structt, typ, typ)
			for _, kv := range expr.KeyValues {
				name := kv.Key.(*ast.Identifier).Name
				field, _ := typ.FieldByName(name)
				valueType := em.ti(kv.Value).Type
				if canEmitDirectly(field.Type.Kind(), valueType.Kind()) {
					value, k := em.emitExprK(kv.Value, valueType)
					index := em.fb.makeIntConstant(encodeFieldIndex(field.Index))
					em.fb.emitSetField(k, structt, index, value)
				} else {
					tmpValue := em.emitExpr(kv.Value, valueType)
					value := em.fb.newRegister(field.Type.Kind())
					em.changeRegister(false, tmpValue, value, valueType, field.Type)
					index := em.fb.makeIntConstant(encodeFieldIndex(field.Index))
					em.fb.emitSetField(false, structt, index, value)
				}
				// TODO(Gianluca): use field "k" of SetField.
			}
			em.changeRegister(false, structt, reg, typ, dstType)
			em.fb.exitStack()

		case reflect.Map:
			if reg == 0 {
				for _, kv := range expr.KeyValues {
					typ := em.ti(kv.Value).Type
					em.emitExprR(kv.Value, typ, 0)
				}
				return reg, false
			}
			size := len(expr.KeyValues)
			if 0 <= size && size < 126 {
				em.fb.emitMakeMap(typ, true, int8(size), reg)
			} else {
				sizeReg := em.fb.makeIntConstant(int64(size))
				em.fb.emitMakeMap(typ, false, sizeReg, reg)
			}
			for _, kv := range expr.KeyValues {
				key := em.fb.newRegister(typ.Key().Kind())
				em.fb.enterStack()
				em.emitExprR(kv.Key, typ.Key(), key)
				value, k := em.emitExprK(kv.Value, typ.Elem())
				em.fb.exitStack()
				em.fb.emitSetMap(k, reg, value, key, typ)
			}
		}

	case *ast.TypeAssertion:

		exprType := em.ti(expr.Expr).Type
		exprReg := em.emitExpr(expr.Expr, exprType)
		assertType := em.ti(expr.Type).Type
		var panicLine int
		if expr.Pos() != nil {
			panicLine = expr.Pos().Line
		}
		if canEmitDirectly(assertType.Kind(), dstType.Kind()) {
			em.fb.emitAssert(exprReg, assertType, reg)
			em.fb.emitPanic(0, panicLine, exprType)
			return reg, false
		}
		em.fb.enterScope()
		tmp := em.fb.newRegister(assertType.Kind())
		em.fb.emitAssert(exprReg, assertType, tmp)
		em.fb.emitPanic(0, panicLine, exprType)
		em.changeRegister(false, tmp, reg, assertType, dstType)
		em.fb.exitScope()

	case *ast.Selector:

		em.emitSelector(expr, reg, dstType)

	case *ast.UnaryOperator:

		// Receive operation on channel.
		//
		//	v     = <- ch
		//  v, ok = <- ch
		//          <- ch
		if expr.Operator() == ast.OperatorReceive {
			chanType := em.ti(expr.Expr).Type
			valueType := em.ti(expr).Type
			chann := em.emitExpr(expr.Expr, chanType)
			if reg == 0 {
				em.fb.emitReceive(chann, 0, 0)
				return reg, false
			}
			if canEmitDirectly(valueType.Kind(), dstType.Kind()) {
				em.fb.emitReceive(chann, 0, reg)
				return reg, false
			}
			tmp := em.fb.newRegister(valueType.Kind())
			em.fb.emitReceive(chann, 0, tmp)
			em.changeRegister(false, tmp, reg, valueType, dstType)
			return reg, false
		}

		// Unary operation (negation) on a complex number.
		if exprType := em.ti(expr).Type; exprType.Kind() == reflect.Complex64 || exprType.Kind() == reflect.Complex128 {
			if expr.Operator() != ast.OperatorSubtraction {
				panic("bug: expected operator subtraction")
			}
			stackShift := em.fb.currentStackShift()
			em.fb.enterScope()
			index := em.fb.complexOperationIndex(ast.OperatorSubtraction, true)
			ret := em.fb.newRegister(reflect.Complex128)
			arg := em.fb.newRegister(reflect.Complex128)
			em.fb.enterScope()
			em.emitExprR(expr.Expr, exprType, arg)
			em.fb.exitScope()
			em.fb.emitCallPredefined(index, 0, stackShift)
			em.changeRegister(false, ret, reg, exprType, dstType)
			em.fb.exitScope()
			return reg, false
		}

		exprType := em.ti(expr.Expr).Type
		typ := em.ti(expr).Type
		switch expr.Operator() {
		case ast.OperatorNot:
			if reg == 0 {
				em.emitExprR(expr.Expr, exprType, 0)
				return reg, false
			}
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				em.emitExprR(expr.Expr, exprType, reg)
				em.fb.emitSubInv(true, reg, int8(1), reg, reflect.Int)
				return reg, false
			}
			em.fb.enterScope()
			exprReg := em.emitExpr(expr.Expr, exprType)
			em.fb.emitSubInv(true, exprReg, int8(1), exprReg, reflect.Int)
			em.changeRegister(false, exprReg, reg, exprType, dstType)
			em.fb.exitScope()
		case ast.OperatorMultiplication:
			if reg == 0 {
				em.emitExprR(expr.Expr, exprType, 0)
				return reg, false
			}
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				exprReg := em.emitExpr(expr.Expr, exprType)
				em.changeRegister(false, -exprReg, reg, exprType.Elem(), dstType)
				return reg, false
			}
			exprReg := em.emitExpr(expr.Expr, exprType)
			tmp := em.fb.newRegister(exprType.Elem().Kind())
			em.changeRegister(false, -exprReg, tmp, exprType.Elem(), exprType.Elem())
			em.changeRegister(false, tmp, reg, exprType.Elem(), dstType)
		case ast.OperatorAnd:
			switch expr := expr.Expr.(type) {
			case *ast.Identifier:
				if em.fb.isVariable(expr.Name) {
					varr := em.fb.scopeLookup(expr.Name)
					em.fb.emitNew(reflect.PtrTo(typ), reg)
					em.fb.emitMove(false, -varr, reg, dstType.Kind())
				} else {
					panic("TODO(Gianluca): not implemented")
				}
			case *ast.UnaryOperator:
				if expr.Operator() != ast.OperatorMultiplication {
					panic("bug") // TODO(Gianluca): to review.
				}
				em.emitExprR(expr.Expr, dstType, reg)
			case *ast.Index:
				panic("TODO(Gianluca): not implemented")
			case *ast.Selector:
				panic("TODO(Gianluca): not implemented")
			case *ast.CompositeLiteral:
				tmp := em.fb.newRegister(reflect.Ptr)
				em.fb.emitNew(exprType, tmp)
				em.emitExprR(expr, exprType, -tmp)
				em.changeRegister(false, tmp, reg, typ, dstType)
			default:
				panic("TODO(Gianluca): not implemented")
			}
		case ast.OperatorAddition:
			// Do nothing.
		case ast.OperatorSubtraction:
			if reg == 0 {
				em.emitExprR(expr.Expr, dstType, 0)
				return reg, false
			}
			exprReg := em.emitExpr(expr.Expr, dstType)
			if canEmitDirectly(exprType.Kind(), dstType.Kind()) {
				em.fb.emitSubInv(true, exprReg, 0, reg, dstType.Kind())
				return reg, false
			}
			em.fb.enterStack()
			tmp := em.fb.newRegister(exprType.Kind())
			em.fb.emitSubInv(true, exprReg, 0, tmp, exprType.Kind())
			em.changeRegister(false, tmp, reg, exprType, dstType)
			em.fb.exitStack()

		default:
			panic(fmt.Errorf("TODO: not implemented operator %s", expr.Operator()))
		}

	case *ast.Func:

		// Template macro definition.
		if expr.Ident != nil && em.isTemplate {
			macroFn := newFunction("", expr.Ident.Name, expr.Type.Reflect)
			if em.functions[em.pkg] == nil {
				em.functions[em.pkg] = map[string]*vm.Function{}
			}
			em.functions[em.pkg][expr.Ident.Name] = macroFn
			fb := em.fb
			em.setClosureRefs(macroFn, expr.Upvars)
			em.fb = newBuilder(macroFn)
			em.fb.emitSetAlloc(em.options.MemoryLimit)
			em.fb.enterScope()
			em.prepareFunctionBodyParameters(expr)
			em.emitNodes(expr.Body.Nodes)
			em.fb.end()
			em.fb.exitScope()
			em.fb = fb
			return reg, false
		}

		// Script function definition.
		if expr.Ident != nil && !em.isTemplate {
			varr := em.fb.newRegister(reflect.Func)
			em.fb.bindVarReg(expr.Ident.Name, varr)
			ident := expr.Ident
			expr.Ident = nil // avoids recursive calls.
			funcType := em.ti(expr).Type
			if em.isTemplate {
				addr := em.newAddress(addressRegister, funcType, varr, 0)
				em.assign([]address{addr}, []ast.Expression{expr})
			}
			expr.Ident = ident
			return reg, false
		}

		if reg == 0 {
			return reg, false
		}

		var tmp int8
		if canEmitDirectly(reflect.Func, dstType.Kind()) {
			tmp = reg
		} else {
			tmp = em.fb.newRegister(reflect.Func)
		}

		fn := em.fb.emitFunc(tmp, em.ti(expr).Type)
		em.setClosureRefs(fn, expr.Upvars)

		funcLitBuilder := newBuilder(fn)
		funcLitBuilder.emitSetAlloc(em.options.MemoryLimit)
		currFB := em.fb
		em.fb = funcLitBuilder

		em.fb.enterScope()
		em.prepareFunctionBodyParameters(expr)
		em.emitNodes(expr.Body.Nodes)
		em.fb.exitScope()
		em.fb.end()
		em.fb = currFB

		em.changeRegister(false, tmp, reg, em.ti(expr).Type, dstType)

	case *ast.Identifier:

		// An identifier evaluation cannot have side effects.
		if reg == 0 {
			return reg, false
		}

		typ := em.ti(expr).Type

		if em.fb.isVariable(expr.Name) {
			ident := em.fb.scopeLookup(expr.Name)
			em.changeRegister(false, ident, reg, typ, dstType)
			return reg, false
		}

		// Identifier represents a function.
		if fun, ok := em.functions[em.pkg][expr.Name]; ok {
			em.fb.emitGetFunc(false, em.functionIndex(fun), reg)
			em.changeRegister(false, reg, reg, em.ti(expr).Type, dstType)
			return reg, false
		}

		// Clojure variable.
		if index, ok := em.closureVarRefs[em.fb.fn][expr.Name]; ok {
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				em.fb.emitGetVar(index, reg)
				return reg, false
			}
			tmp := em.fb.newRegister(typ.Kind())
			em.fb.emitGetVar(index, tmp)
			em.changeRegister(false, tmp, reg, typ, dstType)
			return reg, false
		}

		// Scriggo variable.
		if index, ok := em.availableVarIndexes[em.pkg][expr.Name]; ok {
			if canEmitDirectly(typ.Kind(), dstType.Kind()) {
				em.fb.emitGetVar(int(index), reg)
				return reg, false
			}
			tmp := em.fb.newRegister(typ.Kind())
			em.fb.emitGetVar(int(index), tmp)
			em.changeRegister(false, tmp, reg, typ, dstType)
			return reg, false
		}

		panic(fmt.Errorf("bug: none of the previous conditions matched identifier %v", expr))

	case *ast.Index:

		exprType := em.ti(expr.Expr).Type
		exprReg := em.emitExpr(expr.Expr, exprType)
		var indexType reflect.Type
		if exprType.Kind() == reflect.Map {
			indexType = exprType.Key()
		} else {
			indexType = intType
		}
		index, kindex := em.emitExprK(expr.Index, indexType)
		var elemType reflect.Type
		if exprType.Kind() == reflect.String {
			elemType = uint8Type
		} else {
			elemType = exprType.Elem()
		}
		if canEmitDirectly(elemType.Kind(), dstType.Kind()) {
			em.fb.emitIndex(kindex, exprReg, index, reg, exprType)
			return reg, false
		}
		em.fb.enterStack()
		tmp := em.fb.newRegister(elemType.Kind())
		em.fb.emitIndex(kindex, exprReg, index, tmp, exprType)
		em.changeRegister(false, tmp, reg, elemType, dstType)
		em.fb.exitStack()

	case *ast.Slicing:

		exprType := em.ti(expr.Expr).Type
		src := em.emitExpr(expr.Expr, exprType)
		var low, high int8 = 0, -1
		var kLow, kHigh = true, true
		// emit low
		if expr.Low != nil {
			typ := em.ti(expr.Low).Type
			low, kLow = em.emitExprK(expr.Low, typ)
		}
		// emit high
		if expr.High != nil {
			typ := em.ti(expr.High).Type
			high, kHigh = em.emitExprK(expr.High, typ)
		}
		if exprType.Kind() == reflect.String {
			em.fb.emitSliceString(kLow, kHigh, src, reg, low, high)
		} else {
			// emit max
			var max int8 = -1
			var kMax = true
			if expr.Max != nil {
				typ := em.ti(expr.Max).Type
				max, kMax = em.emitExprK(expr.Max, typ)
			}
			em.fb.emitSlice(kLow, kHigh, kMax, src, reg, low, high, max)
		}

	default:

		panic(fmt.Sprintf("emitExpr currently does not support %T nodes (expr: %s)", expr, expr))

	}

	return reg, false
}

// emitTypeSwitch emits instructions for a type switch node.
func (em *emitter) emitTypeSwitch(node *ast.TypeSwitch) {

	em.fb.enterScope()

	if node.Init != nil {
		em.emitNodes([]ast.Node{node.Init})
	}

	typeAssertion := node.Assignment.Rhs[0].(*ast.TypeAssertion)
	expr := em.emitExpr(typeAssertion.Expr, em.ti(typeAssertion.Expr).Type)

	bodyLabels := make([]uint32, len(node.Cases))
	endSwitchLabel := em.fb.newLabel()

	var defaultLabel uint32
	hasDefault := false

	for i, cas := range node.Cases {
		bodyLabels[i] = em.fb.newLabel()
		hasDefault = hasDefault || cas.Expressions == nil
		if len(cas.Expressions) == 1 {
			// If the type switch has an assignment, assign to the variable
			// using the type of the case.
			if len(node.Assignment.Lhs) == 1 && !em.ti(cas.Expressions[0]).Nil() {
				ta := ast.NewTypeAssertion(nil, typeAssertion.Expr, cas.Expressions[0])
				em.typeInfos[ta] = &TypeInfo{
					Type: em.ti(cas.Expressions[0]).Type,
				}
				blank := ast.NewIdentifier(nil, "_")
				n := ast.NewAssignment(nil,
					[]ast.Expression{
						node.Assignment.Lhs[0], // the variable
						blank,                  // a dummy blank identifier that prevent panicking
					},
					node.Assignment.Type,
					[]ast.Expression{ta},
				)
				em.emitNodes([]ast.Node{n})
			}
		} else {
			// If the type switch has an assignment, assign to the variable
			// keeping the type. Note that this assignment does not involve type
			// assertion statements, just takes the expression from the type
			// assertion of the type switch.
			if len(node.Assignment.Lhs) == 1 {
				n := ast.NewAssignment(nil,
					[]ast.Expression{node.Assignment.Lhs[0]},
					node.Assignment.Type,
					[]ast.Expression{typeAssertion.Expr},
				)
				em.emitNodes([]ast.Node{n})
			}
		}
		for _, caseExpr := range cas.Expressions {
			if em.ti(caseExpr).Nil() {
				em.fb.emitIf(false, expr, vm.ConditionInterfaceNil, 0, reflect.Interface)
			} else {
				caseType := em.ti(caseExpr).Type
				em.fb.emitAssert(expr, caseType, 0)
			}
			next := em.fb.newLabel()
			em.fb.emitGoto(next)
			em.fb.emitGoto(bodyLabels[i])
			em.fb.setLabelAddr(next)
		}
	}

	if hasDefault {
		defaultLabel = em.fb.newLabel()
		em.fb.emitGoto(defaultLabel)
	} else {
		em.fb.emitGoto(endSwitchLabel)
	}

	for i, cas := range node.Cases {
		if cas.Expressions == nil {
			em.fb.setLabelAddr(defaultLabel)
		}
		em.fb.setLabelAddr(bodyLabels[i])
		em.fb.enterScope()
		em.emitNodes(cas.Body)
		em.fb.exitScope()
		em.fb.emitGoto(endSwitchLabel)
	}

	em.fb.setLabelAddr(endSwitchLabel)
	em.fb.exitScope()

	return
}

// emitSwitch emits instructions for a switch node.
func (em *emitter) emitSwitch(node *ast.Switch) {

	em.fb.enterScope()

	if node.Init != nil {
		em.emitNodes([]ast.Node{node.Init})
	}

	var expr int8
	var typ reflect.Type

	if node.Expr == nil {
		typ = boolType
		expr = em.fb.newRegister(typ.Kind())
		em.fb.emitMove(true, 1, expr, typ.Kind())
		node.Expr = ast.NewIdentifier(nil, "true")
		em.typeInfos[node.Expr] = &TypeInfo{
			Constant:   boolConst(true),
			Type:       boolType,
			value:      int64(1), // true
			valueType:  boolType,
			Properties: PropertyUntyped | PropertyHasValue,
		}
	} else {
		typ = em.ti(node.Expr).Type
		expr = em.emitExpr(node.Expr, typ)
	}

	bodyLabels := make([]uint32, len(node.Cases))
	endSwitchLabel := em.fb.newLabel()

	var defaultLabel uint32
	hasDefault := false

	for i, cas := range node.Cases {
		bodyLabels[i] = em.fb.newLabel()
		hasDefault = hasDefault || cas.Expressions == nil
		for _, caseExpr := range cas.Expressions {
			binOp := ast.NewBinaryOperator(nil, ast.OperatorNotEqual, node.Expr, caseExpr)
			em.typeInfos[binOp] = &TypeInfo{
				Type: boolType,
			}
			em.emitCondition(binOp)
			em.fb.emitGoto(bodyLabels[i])
		}
	}

	if hasDefault {
		defaultLabel = em.fb.newLabel()
		em.fb.emitGoto(defaultLabel)
	} else {
		em.fb.emitGoto(endSwitchLabel)
	}

	for i, cas := range node.Cases {
		if cas.Expressions == nil {
			em.fb.setLabelAddr(defaultLabel)
		}
		em.fb.setLabelAddr(bodyLabels[i])
		em.fb.enterScope()
		em.emitNodes(cas.Body)
		hasFallthrough := false
		for i := len(cas.Body) - 1; i >= 0; i-- {
			if _, ok := cas.Body[i].(*ast.Fallthrough); ok {
				hasFallthrough = true
				break
			}
		}
		if !hasFallthrough {
			em.fb.emitGoto(endSwitchLabel)
		}
		em.fb.exitScope()
	}

	em.fb.setLabelAddr(endSwitchLabel)

	em.fb.exitScope()

	return
}

// emitCondition emits the instructions for a condition. The last instruction
// emitted is always the "If" instruction.
func (em *emitter) emitCondition(cond ast.Expression) {

	// cond is a boolean constant. Given that the 'if' instruction requires a
	// binary operation as condition, any boolean constant expressions 'b' is
	// converted to 'b == true'.
	if ti := em.ti(cond); ti != nil && ti.HasValue() {
		if ti.Type.Kind() != reflect.Bool {
			panic("bug: expected a boolean constant") // TODO(Gianluca): remove.
		}
		v1 := em.emitExpr(cond, ti.Type)
		k2 := em.fb.makeIntConstant(1) // true
		v2 := em.fb.newRegister(reflect.Bool)
		em.fb.emitLoadNumber(vm.TypeInt, k2, v2)
		em.fb.emitIf(false, v1, vm.ConditionEqual, v2, reflect.Bool) // v1 == true
		return
	}

	// if v   == nil
	// if v   != nil
	// if nil == v
	// if nil != v
	if cond, ok := cond.(*ast.BinaryOperator); ok {
		if em.ti(cond.Expr1).Nil() != em.ti(cond.Expr2).Nil() {
			expr := cond.Expr1
			if em.ti(cond.Expr1).Nil() {
				expr = cond.Expr2
			}
			typ := em.ti(expr).Type
			v := em.emitExpr(expr, typ)
			condType := vm.ConditionNotNil
			if cond.Operator() == ast.OperatorEqual {
				condType = vm.ConditionNil
			}
			if em.ti(expr).Type.Kind() == reflect.Interface {
				if condType == vm.ConditionNil {
					condType = vm.ConditionInterfaceNil
				} else {
					condType = vm.ConditionInterfaceNotNil
				}
			}
			em.fb.emitIf(false, v, condType, 0, typ.Kind())
			return
		}
	}

	// if len("str") == v
	// if len("str") != v
	// if len("str") <  v
	// if len("str") <= v
	// if len("str") >  v
	// if len("str") >= v
	// if v == len("str")
	// if v != len("str")
	// if v <  len("str")
	// if v <= len("str")
	// if v >  len("str")
	// if v >= len("str")
	if cond, ok := cond.(*ast.BinaryOperator); ok {
		if em.isBuiltinCall(cond.Expr1, "len") != em.isBuiltinCall(cond.Expr2, "len") {
			var lenArg, expr ast.Expression
			if em.isBuiltinCall(cond.Expr1, "len") {
				lenArg = cond.Expr1.(*ast.Call).Args[0]
				expr = cond.Expr2
			} else {
				lenArg = cond.Expr2.(*ast.Call).Args[0]
				expr = cond.Expr1
			}
			if em.ti(lenArg).Type.Kind() == reflect.String { // len is optimized for strings only.
				v1 := em.emitExpr(lenArg, em.ti(lenArg).Type)
				typ := em.ti(expr).Type
				v2, k2 := em.emitExprK(expr, typ)
				condType := map[ast.OperatorType]vm.Condition{
					ast.OperatorEqual:          vm.ConditionEqualLen,
					ast.OperatorNotEqual:       vm.ConditionNotEqualLen,
					ast.OperatorLess:           vm.ConditionLessLen,
					ast.OperatorLessOrEqual:    vm.ConditionLessOrEqualLen,
					ast.OperatorGreater:        vm.ConditionGreaterLen,
					ast.OperatorGreaterOrEqual: vm.ConditionGreaterOrEqualLen,
				}[cond.Operator()]
				em.fb.emitIf(k2, v1, condType, v2, reflect.String)
				return
			}
		}
	}

	// Binary operations that involves specific kinds of values that are
	// optimized in the VM.
	//
	// if v1 == v2
	// if v1 != v2
	// if v1 <  v2
	// if v1 <= v2
	// if v1 >  v2
	// if v1 >= v2
	if cond, ok := cond.(*ast.BinaryOperator); ok {
		t1 := em.ti(cond.Expr1).Type
		t2 := em.ti(cond.Expr2).Type
		if t1.Kind() == t2.Kind() {
			if kind := t1.Kind(); reflect.Int <= kind && kind <= reflect.Float64 {
				v1 := em.emitExpr(cond.Expr1, t1)
				v2, k2 := em.emitExprK(cond.Expr2, t2)
				condType := map[ast.OperatorType]vm.Condition{
					ast.OperatorEqual:          vm.ConditionEqual,
					ast.OperatorNotEqual:       vm.ConditionNotEqual,
					ast.OperatorLess:           vm.ConditionLess,
					ast.OperatorLessOrEqual:    vm.ConditionLessOrEqual,
					ast.OperatorGreater:        vm.ConditionGreater,
					ast.OperatorGreaterOrEqual: vm.ConditionGreaterOrEqual,
				}[cond.Operator()]
				// Equality and not equality checks are not optimized for
				// uints, so these kinds must use the instructions of
				// integers.
				if reflect.Uint <= kind && kind <= reflect.Uintptr && condType == vm.ConditionEqual || condType == vm.ConditionNotEqual {
					em.fb.emitIf(k2, v1, condType, v2, reflect.Int)
					return
				}
				em.fb.emitIf(k2, v1, condType, v2, kind)
				return
			}
		}
	}

	// // Any other binary condition is evaluated and compared to 'true'. For
	// // example 'if a == b || c == d' becomes 'if (a == b || c == d) == 1'.
	v1 := em.emitExpr(cond, em.ti(cond).Type)
	k2 := em.fb.makeIntConstant(1)
	v2 := em.fb.newRegister(reflect.Bool)
	em.fb.emitLoadNumber(vm.TypeInt, k2, v2)
	em.fb.emitIf(false, v1, vm.ConditionEqual, v2, reflect.Bool)
	return

}

// emitSelect emits the 'select' statements.
// The emission is composed by 4 main parts:
//
// 1) Preparation of the channel and value registers.
//
// 2) Emission of the 'case' instructions. Every case must be followed by a
// 'goto' which points to the respective case body below.
//
// 3) Emission of the 'select' instruction.
//
// 4) Emission of the assignment node (in case of a case with assignment) and of
// all the rest of the registers.
//
func (em *emitter) emitSelect(selectNode *ast.Select) {

	// select { }
	if len(selectNode.Cases) == 0 {
		em.fb.emitSelect()
		return
	}

	// Enter in a new stack: all registers allocated during the execution of the
	// 'select' statement will be released at the end of it.
	em.fb.enterStack()

	// Create some shared registers; preallocation is not a problem: when the
	// select statement will be ended, all registers will be released.
	ch := em.fb.newRegister(reflect.Chan)
	ok := em.fb.newRegister(reflect.Bool)
	value := map[vm.Type]int8{
		vm.TypeInt:     em.fb.newRegister(reflect.Int),
		vm.TypeFloat:   em.fb.newRegister(reflect.Float64),
		vm.TypeString:  em.fb.newRegister(reflect.String),
		vm.TypeGeneral: em.fb.newRegister(reflect.Interface),
	}

	// Prepare registers for the 'select' instruction.
	for _, caseNode := range selectNode.Cases {
		switch caseNode := caseNode.Comm.(type) {
		case nil: // default: nothing to do.
		case *ast.UnaryOperator:
			// <- ch
			chExpr := caseNode.Expr
			em.emitExprR(chExpr, em.ti(chExpr).Type, ch)
		case *ast.Assignment:
			// v [, ok ] = <- ch
			chExpr := caseNode.Rhs[0].(*ast.UnaryOperator).Expr
			em.emitExprR(chExpr, em.ti(chExpr).Type, ch)
		case *ast.Send:
			// ch <- v
			chExpr := caseNode.Channel
			chType := em.ti(chExpr).Type
			chElemType := chType.Elem()
			em.emitExprR(chExpr, chType, ch)
			valueExpr := caseNode.Value
			em.emitExprR(valueExpr, chElemType, value[kindToType(chElemType.Kind())])
		}
	}

	// Emit all the 'case' instructions.
	casesLabel := make([]uint32, len(selectNode.Cases), len(selectNode.Cases))
	for i := range casesLabel {
		casesLabel[i] = em.fb.newLabel()
	}
	for i, caseNode := range selectNode.Cases {
		switch caseNode := caseNode.Comm.(type) {
		case nil:
			// default
			em.fb.emitCase(false, reflect.SelectDefault, 0, 0, reflect.Invalid)
		case *ast.UnaryOperator:
			// <- ch
			chExpr := caseNode.Expr
			chElemType := em.ti(chExpr).Type.Elem()
			em.fb.emitCase(false, reflect.SelectRecv, 0, ch, chElemType.Kind())
		case *ast.Assignment:
			// v [, ok ] = <- ch
			chExpr := caseNode.Rhs[0].(*ast.UnaryOperator).Expr
			chType := em.ti(chExpr).Type
			chElemType := chType.Elem()
			em.fb.emitCase(false, reflect.SelectRecv, value[kindToType(chElemType.Kind())], ch, chElemType.Kind())
		case *ast.Send:
			// ch <- v
			chExpr := caseNode.Channel
			chType := em.ti(chExpr).Type
			chElemType := chType.Elem()
			em.fb.emitCase(false, reflect.SelectSend, value[kindToType(chElemType.Kind())], ch, chElemType.Kind())
		}
		em.fb.emitGoto(casesLabel[i])
	}

	// Emit the 'select' instruction.
	em.fb.emitSelect()

	// Emit bodies of the 'select' cases.
	casesEnd := em.fb.newLabel()
	for i, caseNode := range selectNode.Cases {
		// Make the previous 'goto' point here.
		em.fb.setLabelAddr(casesLabel[i])
		// If the case is a receive case with an assignment, emit the assignment.
		if assignment, isAssignment := caseNode.Comm.(*ast.Assignment); isAssignment {
			receiveExpr := assignment.Rhs[0].(*ast.UnaryOperator)
			chExpr := receiveExpr.Expr
			chType := em.ti(chExpr).Type
			chElemType := chType.Elem()
			// Split assignment in two parts: the first is the value assignment;
			// the second, if exists, is the 'ok' assignment.
			em.fb.bindVarReg("$chanElem", value[kindToType(chElemType.Kind())])
			valueExpr := ast.NewIdentifier(nil, "$chanElem")
			em.typeInfos[valueExpr] = em.typeInfos[receiveExpr]
			valueAssignment := ast.NewAssignment(nil, assignment.Lhs[0:1], assignment.Type, []ast.Expression{valueExpr})
			em.emitAssignmentNode(valueAssignment)
			if len(assignment.Lhs) == 2 { // case has 'ok'
				em.fb.emitMove(true, 1, ok, reflect.Bool)
				em.fb.emitIf(false, 0, vm.ConditionOK, 0, reflect.Interface)
				em.fb.emitMove(true, 0, ok, reflect.Bool)
				okExpr := ast.NewIdentifier(nil, "$ok")
				em.typeInfos[okExpr] = &TypeInfo{
					Type: boolType,
				}
				em.fb.bindVarReg("$ok", ok)
				okAssignment := ast.NewAssignment(nil, assignment.Lhs[1:2], assignment.Type, []ast.Expression{okExpr})
				em.emitAssignmentNode(okAssignment)
			}
		}
		// Emit the nodes of the body of the case.
		em.emitNodes(caseNode.Body)
		// Every case body (except last) jumps to the end of all bodies.
		if i < len(selectNode.Cases)-1 {
			em.fb.emitGoto(casesEnd)
		}
	}
	em.fb.setLabelAddr(casesEnd)

	// Release all registers allocated during the execution of the 'select' statement.
	em.fb.exitStack()

}
